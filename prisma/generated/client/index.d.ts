
/**
 * Client
**/

import * as runtime from './runtime/library';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model arte
 * 
 */
export type arte = $Result.DefaultSelection<Prisma.$artePayload>
/**
 * Model cliente
 * 
 */
export type cliente = $Result.DefaultSelection<Prisma.$clientePayload>
/**
 * Model color
 * 
 */
export type color = $Result.DefaultSelection<Prisma.$colorPayload>
/**
 * Model configuracionlaboral
 * 
 */
export type configuracionlaboral = $Result.DefaultSelection<Prisma.$configuracionlaboralPayload>
/**
 * Model cotizacion
 * 
 */
export type cotizacion = $Result.DefaultSelection<Prisma.$cotizacionPayload>
/**
 * Model datos
 * 
 */
export type datos = $Result.DefaultSelection<Prisma.$datosPayload>
/**
 * Model detcot
 * 
 */
export type detcot = $Result.DefaultSelection<Prisma.$detcotPayload>
/**
 * Model detot
 * 
 */
export type detot = $Result.DefaultSelection<Prisma.$detotPayload>
/**
 * Model empresa
 * 
 */
export type empresa = $Result.DefaultSelection<Prisma.$empresaPayload>
/**
 * Model eventos
 * 
 */
export type eventos = $Result.DefaultSelection<Prisma.$eventosPayload>
/**
 * Model factura
 * 
 */
export type factura = $Result.DefaultSelection<Prisma.$facturaPayload>
/**
 * Model inventario
 * 
 */
export type inventario = $Result.DefaultSelection<Prisma.$inventarioPayload>
/**
 * Model leyenda
 * 
 */
export type leyenda = $Result.DefaultSelection<Prisma.$leyendaPayload>
/**
 * Model marca
 * 
 */
export type marca = $Result.DefaultSelection<Prisma.$marcaPayload>
/**
 * Model menu
 * 
 */
export type menu = $Result.DefaultSelection<Prisma.$menuPayload>
/**
 * Model ordent
 * 
 */
export type ordent = $Result.DefaultSelection<Prisma.$ordentPayload>
/**
 * Model pago
 * 
 */
export type pago = $Result.DefaultSelection<Prisma.$pagoPayload>
/**
 * Model persona
 * 
 */
export type persona = $Result.DefaultSelection<Prisma.$personaPayload>
/**
 * Model producto
 * 
 */
export type producto = $Result.DefaultSelection<Prisma.$productoPayload>
/**
 * Model proveedor
 * 
 */
export type proveedor = $Result.DefaultSelection<Prisma.$proveedorPayload>
/**
 * Model registrolaboral
 * 
 */
export type registrolaboral = $Result.DefaultSelection<Prisma.$registrolaboralPayload>
/**
 * Model roles
 * 
 */
export type roles = $Result.DefaultSelection<Prisma.$rolesPayload>
/**
 * Model rolmenu
 * 
 */
export type rolmenu = $Result.DefaultSelection<Prisma.$rolmenuPayload>
/**
 * Model telefono
 * 
 */
export type telefono = $Result.DefaultSelection<Prisma.$telefonoPayload>
/**
 * Model terminado
 * 
 */
export type terminado = $Result.DefaultSelection<Prisma.$terminadoPayload>
/**
 * Model usuario
 * 
 */
export type usuario = $Result.DefaultSelection<Prisma.$usuarioPayload>
/**
 * Model usurol
 * 
 */
export type usurol = $Result.DefaultSelection<Prisma.$usurolPayload>

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Artes
 * const artes = await prisma.arte.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Artes
   * const artes = await prisma.arte.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<'extends', Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.arte`: Exposes CRUD operations for the **arte** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Artes
    * const artes = await prisma.arte.findMany()
    * ```
    */
  get arte(): Prisma.arteDelegate<ExtArgs>;

  /**
   * `prisma.cliente`: Exposes CRUD operations for the **cliente** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Clientes
    * const clientes = await prisma.cliente.findMany()
    * ```
    */
  get cliente(): Prisma.clienteDelegate<ExtArgs>;

  /**
   * `prisma.color`: Exposes CRUD operations for the **color** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Colors
    * const colors = await prisma.color.findMany()
    * ```
    */
  get color(): Prisma.colorDelegate<ExtArgs>;

  /**
   * `prisma.configuracionlaboral`: Exposes CRUD operations for the **configuracionlaboral** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Configuracionlaborals
    * const configuracionlaborals = await prisma.configuracionlaboral.findMany()
    * ```
    */
  get configuracionlaboral(): Prisma.configuracionlaboralDelegate<ExtArgs>;

  /**
   * `prisma.cotizacion`: Exposes CRUD operations for the **cotizacion** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Cotizacions
    * const cotizacions = await prisma.cotizacion.findMany()
    * ```
    */
  get cotizacion(): Prisma.cotizacionDelegate<ExtArgs>;

  /**
   * `prisma.datos`: Exposes CRUD operations for the **datos** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Datos
    * const datos = await prisma.datos.findMany()
    * ```
    */
  get datos(): Prisma.datosDelegate<ExtArgs>;

  /**
   * `prisma.detcot`: Exposes CRUD operations for the **detcot** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Detcots
    * const detcots = await prisma.detcot.findMany()
    * ```
    */
  get detcot(): Prisma.detcotDelegate<ExtArgs>;

  /**
   * `prisma.detot`: Exposes CRUD operations for the **detot** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Detots
    * const detots = await prisma.detot.findMany()
    * ```
    */
  get detot(): Prisma.detotDelegate<ExtArgs>;

  /**
   * `prisma.empresa`: Exposes CRUD operations for the **empresa** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Empresas
    * const empresas = await prisma.empresa.findMany()
    * ```
    */
  get empresa(): Prisma.empresaDelegate<ExtArgs>;

  /**
   * `prisma.eventos`: Exposes CRUD operations for the **eventos** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Eventos
    * const eventos = await prisma.eventos.findMany()
    * ```
    */
  get eventos(): Prisma.eventosDelegate<ExtArgs>;

  /**
   * `prisma.factura`: Exposes CRUD operations for the **factura** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Facturas
    * const facturas = await prisma.factura.findMany()
    * ```
    */
  get factura(): Prisma.facturaDelegate<ExtArgs>;

  /**
   * `prisma.inventario`: Exposes CRUD operations for the **inventario** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Inventarios
    * const inventarios = await prisma.inventario.findMany()
    * ```
    */
  get inventario(): Prisma.inventarioDelegate<ExtArgs>;

  /**
   * `prisma.leyenda`: Exposes CRUD operations for the **leyenda** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Leyendas
    * const leyendas = await prisma.leyenda.findMany()
    * ```
    */
  get leyenda(): Prisma.leyendaDelegate<ExtArgs>;

  /**
   * `prisma.marca`: Exposes CRUD operations for the **marca** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Marcas
    * const marcas = await prisma.marca.findMany()
    * ```
    */
  get marca(): Prisma.marcaDelegate<ExtArgs>;

  /**
   * `prisma.menu`: Exposes CRUD operations for the **menu** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Menus
    * const menus = await prisma.menu.findMany()
    * ```
    */
  get menu(): Prisma.menuDelegate<ExtArgs>;

  /**
   * `prisma.ordent`: Exposes CRUD operations for the **ordent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Ordents
    * const ordents = await prisma.ordent.findMany()
    * ```
    */
  get ordent(): Prisma.ordentDelegate<ExtArgs>;

  /**
   * `prisma.pago`: Exposes CRUD operations for the **pago** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Pagos
    * const pagos = await prisma.pago.findMany()
    * ```
    */
  get pago(): Prisma.pagoDelegate<ExtArgs>;

  /**
   * `prisma.persona`: Exposes CRUD operations for the **persona** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Personas
    * const personas = await prisma.persona.findMany()
    * ```
    */
  get persona(): Prisma.personaDelegate<ExtArgs>;

  /**
   * `prisma.producto`: Exposes CRUD operations for the **producto** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Productos
    * const productos = await prisma.producto.findMany()
    * ```
    */
  get producto(): Prisma.productoDelegate<ExtArgs>;

  /**
   * `prisma.proveedor`: Exposes CRUD operations for the **proveedor** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Proveedors
    * const proveedors = await prisma.proveedor.findMany()
    * ```
    */
  get proveedor(): Prisma.proveedorDelegate<ExtArgs>;

  /**
   * `prisma.registrolaboral`: Exposes CRUD operations for the **registrolaboral** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Registrolaborals
    * const registrolaborals = await prisma.registrolaboral.findMany()
    * ```
    */
  get registrolaboral(): Prisma.registrolaboralDelegate<ExtArgs>;

  /**
   * `prisma.roles`: Exposes CRUD operations for the **roles** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Roles
    * const roles = await prisma.roles.findMany()
    * ```
    */
  get roles(): Prisma.rolesDelegate<ExtArgs>;

  /**
   * `prisma.rolmenu`: Exposes CRUD operations for the **rolmenu** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Rolmenus
    * const rolmenus = await prisma.rolmenu.findMany()
    * ```
    */
  get rolmenu(): Prisma.rolmenuDelegate<ExtArgs>;

  /**
   * `prisma.telefono`: Exposes CRUD operations for the **telefono** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Telefonos
    * const telefonos = await prisma.telefono.findMany()
    * ```
    */
  get telefono(): Prisma.telefonoDelegate<ExtArgs>;

  /**
   * `prisma.terminado`: Exposes CRUD operations for the **terminado** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Terminados
    * const terminados = await prisma.terminado.findMany()
    * ```
    */
  get terminado(): Prisma.terminadoDelegate<ExtArgs>;

  /**
   * `prisma.usuario`: Exposes CRUD operations for the **usuario** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Usuarios
    * const usuarios = await prisma.usuario.findMany()
    * ```
    */
  get usuario(): Prisma.usuarioDelegate<ExtArgs>;

  /**
   * `prisma.usurol`: Exposes CRUD operations for the **usurol** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Usurols
    * const usurols = await prisma.usurol.findMany()
    * ```
    */
  get usurol(): Prisma.usurolDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.6.0
   * Query Engine version: ac9d7041ed77bcc8a8dbd2ab6616b39013829574
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray | { toJSON(): unknown }

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    arte: 'arte',
    cliente: 'cliente',
    color: 'color',
    configuracionlaboral: 'configuracionlaboral',
    cotizacion: 'cotizacion',
    datos: 'datos',
    detcot: 'detcot',
    detot: 'detot',
    empresa: 'empresa',
    eventos: 'eventos',
    factura: 'factura',
    inventario: 'inventario',
    leyenda: 'leyenda',
    marca: 'marca',
    menu: 'menu',
    ordent: 'ordent',
    pago: 'pago',
    persona: 'persona',
    producto: 'producto',
    proveedor: 'proveedor',
    registrolaboral: 'registrolaboral',
    roles: 'roles',
    rolmenu: 'rolmenu',
    telefono: 'telefono',
    terminado: 'terminado',
    usuario: 'usuario',
    usurol: 'usurol'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }


  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs}, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    meta: {
      modelProps: 'arte' | 'cliente' | 'color' | 'configuracionlaboral' | 'cotizacion' | 'datos' | 'detcot' | 'detot' | 'empresa' | 'eventos' | 'factura' | 'inventario' | 'leyenda' | 'marca' | 'menu' | 'ordent' | 'pago' | 'persona' | 'producto' | 'proveedor' | 'registrolaboral' | 'roles' | 'rolmenu' | 'telefono' | 'terminado' | 'usuario' | 'usurol'
      txIsolationLevel: Prisma.TransactionIsolationLevel
    },
    model: {
      arte: {
        payload: Prisma.$artePayload<ExtArgs>
        fields: Prisma.arteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.arteFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$artePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.arteFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$artePayload>
          }
          findFirst: {
            args: Prisma.arteFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$artePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.arteFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$artePayload>
          }
          findMany: {
            args: Prisma.arteFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$artePayload>[]
          }
          create: {
            args: Prisma.arteCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$artePayload>
          }
          createMany: {
            args: Prisma.arteCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.arteDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$artePayload>
          }
          update: {
            args: Prisma.arteUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$artePayload>
          }
          deleteMany: {
            args: Prisma.arteDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.arteUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.arteUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$artePayload>
          }
          aggregate: {
            args: Prisma.ArteAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateArte>
          }
          groupBy: {
            args: Prisma.arteGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ArteGroupByOutputType>[]
          }
          count: {
            args: Prisma.arteCountArgs<ExtArgs>,
            result: $Utils.Optional<ArteCountAggregateOutputType> | number
          }
        }
      }
      cliente: {
        payload: Prisma.$clientePayload<ExtArgs>
        fields: Prisma.clienteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.clienteFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$clientePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.clienteFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$clientePayload>
          }
          findFirst: {
            args: Prisma.clienteFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$clientePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.clienteFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$clientePayload>
          }
          findMany: {
            args: Prisma.clienteFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$clientePayload>[]
          }
          create: {
            args: Prisma.clienteCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$clientePayload>
          }
          createMany: {
            args: Prisma.clienteCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.clienteDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$clientePayload>
          }
          update: {
            args: Prisma.clienteUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$clientePayload>
          }
          deleteMany: {
            args: Prisma.clienteDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.clienteUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.clienteUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$clientePayload>
          }
          aggregate: {
            args: Prisma.ClienteAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateCliente>
          }
          groupBy: {
            args: Prisma.clienteGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ClienteGroupByOutputType>[]
          }
          count: {
            args: Prisma.clienteCountArgs<ExtArgs>,
            result: $Utils.Optional<ClienteCountAggregateOutputType> | number
          }
        }
      }
      color: {
        payload: Prisma.$colorPayload<ExtArgs>
        fields: Prisma.colorFieldRefs
        operations: {
          findUnique: {
            args: Prisma.colorFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$colorPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.colorFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$colorPayload>
          }
          findFirst: {
            args: Prisma.colorFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$colorPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.colorFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$colorPayload>
          }
          findMany: {
            args: Prisma.colorFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$colorPayload>[]
          }
          create: {
            args: Prisma.colorCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$colorPayload>
          }
          createMany: {
            args: Prisma.colorCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.colorDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$colorPayload>
          }
          update: {
            args: Prisma.colorUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$colorPayload>
          }
          deleteMany: {
            args: Prisma.colorDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.colorUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.colorUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$colorPayload>
          }
          aggregate: {
            args: Prisma.ColorAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateColor>
          }
          groupBy: {
            args: Prisma.colorGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ColorGroupByOutputType>[]
          }
          count: {
            args: Prisma.colorCountArgs<ExtArgs>,
            result: $Utils.Optional<ColorCountAggregateOutputType> | number
          }
        }
      }
      configuracionlaboral: {
        payload: Prisma.$configuracionlaboralPayload<ExtArgs>
        fields: Prisma.configuracionlaboralFieldRefs
        operations: {
          findUnique: {
            args: Prisma.configuracionlaboralFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$configuracionlaboralPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.configuracionlaboralFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$configuracionlaboralPayload>
          }
          findFirst: {
            args: Prisma.configuracionlaboralFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$configuracionlaboralPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.configuracionlaboralFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$configuracionlaboralPayload>
          }
          findMany: {
            args: Prisma.configuracionlaboralFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$configuracionlaboralPayload>[]
          }
          create: {
            args: Prisma.configuracionlaboralCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$configuracionlaboralPayload>
          }
          createMany: {
            args: Prisma.configuracionlaboralCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.configuracionlaboralDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$configuracionlaboralPayload>
          }
          update: {
            args: Prisma.configuracionlaboralUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$configuracionlaboralPayload>
          }
          deleteMany: {
            args: Prisma.configuracionlaboralDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.configuracionlaboralUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.configuracionlaboralUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$configuracionlaboralPayload>
          }
          aggregate: {
            args: Prisma.ConfiguracionlaboralAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateConfiguracionlaboral>
          }
          groupBy: {
            args: Prisma.configuracionlaboralGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ConfiguracionlaboralGroupByOutputType>[]
          }
          count: {
            args: Prisma.configuracionlaboralCountArgs<ExtArgs>,
            result: $Utils.Optional<ConfiguracionlaboralCountAggregateOutputType> | number
          }
        }
      }
      cotizacion: {
        payload: Prisma.$cotizacionPayload<ExtArgs>
        fields: Prisma.cotizacionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.cotizacionFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$cotizacionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.cotizacionFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$cotizacionPayload>
          }
          findFirst: {
            args: Prisma.cotizacionFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$cotizacionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.cotizacionFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$cotizacionPayload>
          }
          findMany: {
            args: Prisma.cotizacionFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$cotizacionPayload>[]
          }
          create: {
            args: Prisma.cotizacionCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$cotizacionPayload>
          }
          createMany: {
            args: Prisma.cotizacionCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.cotizacionDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$cotizacionPayload>
          }
          update: {
            args: Prisma.cotizacionUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$cotizacionPayload>
          }
          deleteMany: {
            args: Prisma.cotizacionDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.cotizacionUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.cotizacionUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$cotizacionPayload>
          }
          aggregate: {
            args: Prisma.CotizacionAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateCotizacion>
          }
          groupBy: {
            args: Prisma.cotizacionGroupByArgs<ExtArgs>,
            result: $Utils.Optional<CotizacionGroupByOutputType>[]
          }
          count: {
            args: Prisma.cotizacionCountArgs<ExtArgs>,
            result: $Utils.Optional<CotizacionCountAggregateOutputType> | number
          }
        }
      }
      datos: {
        payload: Prisma.$datosPayload<ExtArgs>
        fields: Prisma.datosFieldRefs
        operations: {
          findUnique: {
            args: Prisma.datosFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$datosPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.datosFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$datosPayload>
          }
          findFirst: {
            args: Prisma.datosFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$datosPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.datosFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$datosPayload>
          }
          findMany: {
            args: Prisma.datosFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$datosPayload>[]
          }
          create: {
            args: Prisma.datosCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$datosPayload>
          }
          createMany: {
            args: Prisma.datosCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.datosDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$datosPayload>
          }
          update: {
            args: Prisma.datosUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$datosPayload>
          }
          deleteMany: {
            args: Prisma.datosDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.datosUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.datosUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$datosPayload>
          }
          aggregate: {
            args: Prisma.DatosAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateDatos>
          }
          groupBy: {
            args: Prisma.datosGroupByArgs<ExtArgs>,
            result: $Utils.Optional<DatosGroupByOutputType>[]
          }
          count: {
            args: Prisma.datosCountArgs<ExtArgs>,
            result: $Utils.Optional<DatosCountAggregateOutputType> | number
          }
        }
      }
      detcot: {
        payload: Prisma.$detcotPayload<ExtArgs>
        fields: Prisma.detcotFieldRefs
        operations: {
          findUnique: {
            args: Prisma.detcotFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$detcotPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.detcotFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$detcotPayload>
          }
          findFirst: {
            args: Prisma.detcotFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$detcotPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.detcotFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$detcotPayload>
          }
          findMany: {
            args: Prisma.detcotFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$detcotPayload>[]
          }
          create: {
            args: Prisma.detcotCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$detcotPayload>
          }
          createMany: {
            args: Prisma.detcotCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.detcotDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$detcotPayload>
          }
          update: {
            args: Prisma.detcotUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$detcotPayload>
          }
          deleteMany: {
            args: Prisma.detcotDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.detcotUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.detcotUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$detcotPayload>
          }
          aggregate: {
            args: Prisma.DetcotAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateDetcot>
          }
          groupBy: {
            args: Prisma.detcotGroupByArgs<ExtArgs>,
            result: $Utils.Optional<DetcotGroupByOutputType>[]
          }
          count: {
            args: Prisma.detcotCountArgs<ExtArgs>,
            result: $Utils.Optional<DetcotCountAggregateOutputType> | number
          }
        }
      }
      detot: {
        payload: Prisma.$detotPayload<ExtArgs>
        fields: Prisma.detotFieldRefs
        operations: {
          findUnique: {
            args: Prisma.detotFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$detotPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.detotFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$detotPayload>
          }
          findFirst: {
            args: Prisma.detotFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$detotPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.detotFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$detotPayload>
          }
          findMany: {
            args: Prisma.detotFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$detotPayload>[]
          }
          create: {
            args: Prisma.detotCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$detotPayload>
          }
          createMany: {
            args: Prisma.detotCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.detotDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$detotPayload>
          }
          update: {
            args: Prisma.detotUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$detotPayload>
          }
          deleteMany: {
            args: Prisma.detotDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.detotUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.detotUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$detotPayload>
          }
          aggregate: {
            args: Prisma.DetotAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateDetot>
          }
          groupBy: {
            args: Prisma.detotGroupByArgs<ExtArgs>,
            result: $Utils.Optional<DetotGroupByOutputType>[]
          }
          count: {
            args: Prisma.detotCountArgs<ExtArgs>,
            result: $Utils.Optional<DetotCountAggregateOutputType> | number
          }
        }
      }
      empresa: {
        payload: Prisma.$empresaPayload<ExtArgs>
        fields: Prisma.empresaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.empresaFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$empresaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.empresaFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$empresaPayload>
          }
          findFirst: {
            args: Prisma.empresaFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$empresaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.empresaFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$empresaPayload>
          }
          findMany: {
            args: Prisma.empresaFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$empresaPayload>[]
          }
          create: {
            args: Prisma.empresaCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$empresaPayload>
          }
          createMany: {
            args: Prisma.empresaCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.empresaDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$empresaPayload>
          }
          update: {
            args: Prisma.empresaUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$empresaPayload>
          }
          deleteMany: {
            args: Prisma.empresaDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.empresaUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.empresaUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$empresaPayload>
          }
          aggregate: {
            args: Prisma.EmpresaAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateEmpresa>
          }
          groupBy: {
            args: Prisma.empresaGroupByArgs<ExtArgs>,
            result: $Utils.Optional<EmpresaGroupByOutputType>[]
          }
          count: {
            args: Prisma.empresaCountArgs<ExtArgs>,
            result: $Utils.Optional<EmpresaCountAggregateOutputType> | number
          }
        }
      }
      eventos: {
        payload: Prisma.$eventosPayload<ExtArgs>
        fields: Prisma.eventosFieldRefs
        operations: {
          findUnique: {
            args: Prisma.eventosFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$eventosPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.eventosFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$eventosPayload>
          }
          findFirst: {
            args: Prisma.eventosFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$eventosPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.eventosFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$eventosPayload>
          }
          findMany: {
            args: Prisma.eventosFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$eventosPayload>[]
          }
          create: {
            args: Prisma.eventosCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$eventosPayload>
          }
          createMany: {
            args: Prisma.eventosCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.eventosDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$eventosPayload>
          }
          update: {
            args: Prisma.eventosUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$eventosPayload>
          }
          deleteMany: {
            args: Prisma.eventosDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.eventosUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.eventosUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$eventosPayload>
          }
          aggregate: {
            args: Prisma.EventosAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateEventos>
          }
          groupBy: {
            args: Prisma.eventosGroupByArgs<ExtArgs>,
            result: $Utils.Optional<EventosGroupByOutputType>[]
          }
          count: {
            args: Prisma.eventosCountArgs<ExtArgs>,
            result: $Utils.Optional<EventosCountAggregateOutputType> | number
          }
        }
      }
      factura: {
        payload: Prisma.$facturaPayload<ExtArgs>
        fields: Prisma.facturaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.facturaFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$facturaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.facturaFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$facturaPayload>
          }
          findFirst: {
            args: Prisma.facturaFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$facturaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.facturaFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$facturaPayload>
          }
          findMany: {
            args: Prisma.facturaFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$facturaPayload>[]
          }
          create: {
            args: Prisma.facturaCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$facturaPayload>
          }
          createMany: {
            args: Prisma.facturaCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.facturaDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$facturaPayload>
          }
          update: {
            args: Prisma.facturaUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$facturaPayload>
          }
          deleteMany: {
            args: Prisma.facturaDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.facturaUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.facturaUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$facturaPayload>
          }
          aggregate: {
            args: Prisma.FacturaAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateFactura>
          }
          groupBy: {
            args: Prisma.facturaGroupByArgs<ExtArgs>,
            result: $Utils.Optional<FacturaGroupByOutputType>[]
          }
          count: {
            args: Prisma.facturaCountArgs<ExtArgs>,
            result: $Utils.Optional<FacturaCountAggregateOutputType> | number
          }
        }
      }
      inventario: {
        payload: Prisma.$inventarioPayload<ExtArgs>
        fields: Prisma.inventarioFieldRefs
        operations: {
          findUnique: {
            args: Prisma.inventarioFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inventarioPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.inventarioFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inventarioPayload>
          }
          findFirst: {
            args: Prisma.inventarioFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inventarioPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.inventarioFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inventarioPayload>
          }
          findMany: {
            args: Prisma.inventarioFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inventarioPayload>[]
          }
          create: {
            args: Prisma.inventarioCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inventarioPayload>
          }
          createMany: {
            args: Prisma.inventarioCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.inventarioDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inventarioPayload>
          }
          update: {
            args: Prisma.inventarioUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inventarioPayload>
          }
          deleteMany: {
            args: Prisma.inventarioDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.inventarioUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.inventarioUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inventarioPayload>
          }
          aggregate: {
            args: Prisma.InventarioAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateInventario>
          }
          groupBy: {
            args: Prisma.inventarioGroupByArgs<ExtArgs>,
            result: $Utils.Optional<InventarioGroupByOutputType>[]
          }
          count: {
            args: Prisma.inventarioCountArgs<ExtArgs>,
            result: $Utils.Optional<InventarioCountAggregateOutputType> | number
          }
        }
      }
      leyenda: {
        payload: Prisma.$leyendaPayload<ExtArgs>
        fields: Prisma.leyendaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.leyendaFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$leyendaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.leyendaFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$leyendaPayload>
          }
          findFirst: {
            args: Prisma.leyendaFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$leyendaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.leyendaFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$leyendaPayload>
          }
          findMany: {
            args: Prisma.leyendaFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$leyendaPayload>[]
          }
          create: {
            args: Prisma.leyendaCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$leyendaPayload>
          }
          createMany: {
            args: Prisma.leyendaCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.leyendaDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$leyendaPayload>
          }
          update: {
            args: Prisma.leyendaUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$leyendaPayload>
          }
          deleteMany: {
            args: Prisma.leyendaDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.leyendaUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.leyendaUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$leyendaPayload>
          }
          aggregate: {
            args: Prisma.LeyendaAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateLeyenda>
          }
          groupBy: {
            args: Prisma.leyendaGroupByArgs<ExtArgs>,
            result: $Utils.Optional<LeyendaGroupByOutputType>[]
          }
          count: {
            args: Prisma.leyendaCountArgs<ExtArgs>,
            result: $Utils.Optional<LeyendaCountAggregateOutputType> | number
          }
        }
      }
      marca: {
        payload: Prisma.$marcaPayload<ExtArgs>
        fields: Prisma.marcaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.marcaFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$marcaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.marcaFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$marcaPayload>
          }
          findFirst: {
            args: Prisma.marcaFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$marcaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.marcaFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$marcaPayload>
          }
          findMany: {
            args: Prisma.marcaFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$marcaPayload>[]
          }
          create: {
            args: Prisma.marcaCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$marcaPayload>
          }
          createMany: {
            args: Prisma.marcaCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.marcaDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$marcaPayload>
          }
          update: {
            args: Prisma.marcaUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$marcaPayload>
          }
          deleteMany: {
            args: Prisma.marcaDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.marcaUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.marcaUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$marcaPayload>
          }
          aggregate: {
            args: Prisma.MarcaAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateMarca>
          }
          groupBy: {
            args: Prisma.marcaGroupByArgs<ExtArgs>,
            result: $Utils.Optional<MarcaGroupByOutputType>[]
          }
          count: {
            args: Prisma.marcaCountArgs<ExtArgs>,
            result: $Utils.Optional<MarcaCountAggregateOutputType> | number
          }
        }
      }
      menu: {
        payload: Prisma.$menuPayload<ExtArgs>
        fields: Prisma.menuFieldRefs
        operations: {
          findUnique: {
            args: Prisma.menuFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$menuPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.menuFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$menuPayload>
          }
          findFirst: {
            args: Prisma.menuFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$menuPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.menuFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$menuPayload>
          }
          findMany: {
            args: Prisma.menuFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$menuPayload>[]
          }
          create: {
            args: Prisma.menuCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$menuPayload>
          }
          createMany: {
            args: Prisma.menuCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.menuDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$menuPayload>
          }
          update: {
            args: Prisma.menuUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$menuPayload>
          }
          deleteMany: {
            args: Prisma.menuDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.menuUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.menuUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$menuPayload>
          }
          aggregate: {
            args: Prisma.MenuAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateMenu>
          }
          groupBy: {
            args: Prisma.menuGroupByArgs<ExtArgs>,
            result: $Utils.Optional<MenuGroupByOutputType>[]
          }
          count: {
            args: Prisma.menuCountArgs<ExtArgs>,
            result: $Utils.Optional<MenuCountAggregateOutputType> | number
          }
        }
      }
      ordent: {
        payload: Prisma.$ordentPayload<ExtArgs>
        fields: Prisma.ordentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ordentFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ordentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ordentFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ordentPayload>
          }
          findFirst: {
            args: Prisma.ordentFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ordentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ordentFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ordentPayload>
          }
          findMany: {
            args: Prisma.ordentFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ordentPayload>[]
          }
          create: {
            args: Prisma.ordentCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ordentPayload>
          }
          createMany: {
            args: Prisma.ordentCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ordentDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ordentPayload>
          }
          update: {
            args: Prisma.ordentUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ordentPayload>
          }
          deleteMany: {
            args: Prisma.ordentDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ordentUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ordentUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ordentPayload>
          }
          aggregate: {
            args: Prisma.OrdentAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateOrdent>
          }
          groupBy: {
            args: Prisma.ordentGroupByArgs<ExtArgs>,
            result: $Utils.Optional<OrdentGroupByOutputType>[]
          }
          count: {
            args: Prisma.ordentCountArgs<ExtArgs>,
            result: $Utils.Optional<OrdentCountAggregateOutputType> | number
          }
        }
      }
      pago: {
        payload: Prisma.$pagoPayload<ExtArgs>
        fields: Prisma.pagoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.pagoFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$pagoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.pagoFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$pagoPayload>
          }
          findFirst: {
            args: Prisma.pagoFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$pagoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.pagoFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$pagoPayload>
          }
          findMany: {
            args: Prisma.pagoFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$pagoPayload>[]
          }
          create: {
            args: Prisma.pagoCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$pagoPayload>
          }
          createMany: {
            args: Prisma.pagoCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.pagoDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$pagoPayload>
          }
          update: {
            args: Prisma.pagoUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$pagoPayload>
          }
          deleteMany: {
            args: Prisma.pagoDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.pagoUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.pagoUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$pagoPayload>
          }
          aggregate: {
            args: Prisma.PagoAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregatePago>
          }
          groupBy: {
            args: Prisma.pagoGroupByArgs<ExtArgs>,
            result: $Utils.Optional<PagoGroupByOutputType>[]
          }
          count: {
            args: Prisma.pagoCountArgs<ExtArgs>,
            result: $Utils.Optional<PagoCountAggregateOutputType> | number
          }
        }
      }
      persona: {
        payload: Prisma.$personaPayload<ExtArgs>
        fields: Prisma.personaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.personaFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$personaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.personaFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$personaPayload>
          }
          findFirst: {
            args: Prisma.personaFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$personaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.personaFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$personaPayload>
          }
          findMany: {
            args: Prisma.personaFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$personaPayload>[]
          }
          create: {
            args: Prisma.personaCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$personaPayload>
          }
          createMany: {
            args: Prisma.personaCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.personaDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$personaPayload>
          }
          update: {
            args: Prisma.personaUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$personaPayload>
          }
          deleteMany: {
            args: Prisma.personaDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.personaUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.personaUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$personaPayload>
          }
          aggregate: {
            args: Prisma.PersonaAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregatePersona>
          }
          groupBy: {
            args: Prisma.personaGroupByArgs<ExtArgs>,
            result: $Utils.Optional<PersonaGroupByOutputType>[]
          }
          count: {
            args: Prisma.personaCountArgs<ExtArgs>,
            result: $Utils.Optional<PersonaCountAggregateOutputType> | number
          }
        }
      }
      producto: {
        payload: Prisma.$productoPayload<ExtArgs>
        fields: Prisma.productoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.productoFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$productoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.productoFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$productoPayload>
          }
          findFirst: {
            args: Prisma.productoFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$productoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.productoFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$productoPayload>
          }
          findMany: {
            args: Prisma.productoFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$productoPayload>[]
          }
          create: {
            args: Prisma.productoCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$productoPayload>
          }
          createMany: {
            args: Prisma.productoCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.productoDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$productoPayload>
          }
          update: {
            args: Prisma.productoUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$productoPayload>
          }
          deleteMany: {
            args: Prisma.productoDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.productoUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.productoUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$productoPayload>
          }
          aggregate: {
            args: Prisma.ProductoAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateProducto>
          }
          groupBy: {
            args: Prisma.productoGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ProductoGroupByOutputType>[]
          }
          count: {
            args: Prisma.productoCountArgs<ExtArgs>,
            result: $Utils.Optional<ProductoCountAggregateOutputType> | number
          }
        }
      }
      proveedor: {
        payload: Prisma.$proveedorPayload<ExtArgs>
        fields: Prisma.proveedorFieldRefs
        operations: {
          findUnique: {
            args: Prisma.proveedorFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$proveedorPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.proveedorFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$proveedorPayload>
          }
          findFirst: {
            args: Prisma.proveedorFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$proveedorPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.proveedorFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$proveedorPayload>
          }
          findMany: {
            args: Prisma.proveedorFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$proveedorPayload>[]
          }
          create: {
            args: Prisma.proveedorCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$proveedorPayload>
          }
          createMany: {
            args: Prisma.proveedorCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.proveedorDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$proveedorPayload>
          }
          update: {
            args: Prisma.proveedorUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$proveedorPayload>
          }
          deleteMany: {
            args: Prisma.proveedorDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.proveedorUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.proveedorUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$proveedorPayload>
          }
          aggregate: {
            args: Prisma.ProveedorAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateProveedor>
          }
          groupBy: {
            args: Prisma.proveedorGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ProveedorGroupByOutputType>[]
          }
          count: {
            args: Prisma.proveedorCountArgs<ExtArgs>,
            result: $Utils.Optional<ProveedorCountAggregateOutputType> | number
          }
        }
      }
      registrolaboral: {
        payload: Prisma.$registrolaboralPayload<ExtArgs>
        fields: Prisma.registrolaboralFieldRefs
        operations: {
          findUnique: {
            args: Prisma.registrolaboralFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$registrolaboralPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.registrolaboralFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$registrolaboralPayload>
          }
          findFirst: {
            args: Prisma.registrolaboralFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$registrolaboralPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.registrolaboralFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$registrolaboralPayload>
          }
          findMany: {
            args: Prisma.registrolaboralFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$registrolaboralPayload>[]
          }
          create: {
            args: Prisma.registrolaboralCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$registrolaboralPayload>
          }
          createMany: {
            args: Prisma.registrolaboralCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.registrolaboralDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$registrolaboralPayload>
          }
          update: {
            args: Prisma.registrolaboralUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$registrolaboralPayload>
          }
          deleteMany: {
            args: Prisma.registrolaboralDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.registrolaboralUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.registrolaboralUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$registrolaboralPayload>
          }
          aggregate: {
            args: Prisma.RegistrolaboralAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateRegistrolaboral>
          }
          groupBy: {
            args: Prisma.registrolaboralGroupByArgs<ExtArgs>,
            result: $Utils.Optional<RegistrolaboralGroupByOutputType>[]
          }
          count: {
            args: Prisma.registrolaboralCountArgs<ExtArgs>,
            result: $Utils.Optional<RegistrolaboralCountAggregateOutputType> | number
          }
        }
      }
      roles: {
        payload: Prisma.$rolesPayload<ExtArgs>
        fields: Prisma.rolesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.rolesFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$rolesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.rolesFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$rolesPayload>
          }
          findFirst: {
            args: Prisma.rolesFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$rolesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.rolesFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$rolesPayload>
          }
          findMany: {
            args: Prisma.rolesFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$rolesPayload>[]
          }
          create: {
            args: Prisma.rolesCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$rolesPayload>
          }
          createMany: {
            args: Prisma.rolesCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.rolesDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$rolesPayload>
          }
          update: {
            args: Prisma.rolesUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$rolesPayload>
          }
          deleteMany: {
            args: Prisma.rolesDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.rolesUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.rolesUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$rolesPayload>
          }
          aggregate: {
            args: Prisma.RolesAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateRoles>
          }
          groupBy: {
            args: Prisma.rolesGroupByArgs<ExtArgs>,
            result: $Utils.Optional<RolesGroupByOutputType>[]
          }
          count: {
            args: Prisma.rolesCountArgs<ExtArgs>,
            result: $Utils.Optional<RolesCountAggregateOutputType> | number
          }
        }
      }
      rolmenu: {
        payload: Prisma.$rolmenuPayload<ExtArgs>
        fields: Prisma.rolmenuFieldRefs
        operations: {
          findUnique: {
            args: Prisma.rolmenuFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$rolmenuPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.rolmenuFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$rolmenuPayload>
          }
          findFirst: {
            args: Prisma.rolmenuFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$rolmenuPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.rolmenuFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$rolmenuPayload>
          }
          findMany: {
            args: Prisma.rolmenuFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$rolmenuPayload>[]
          }
          create: {
            args: Prisma.rolmenuCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$rolmenuPayload>
          }
          createMany: {
            args: Prisma.rolmenuCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.rolmenuDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$rolmenuPayload>
          }
          update: {
            args: Prisma.rolmenuUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$rolmenuPayload>
          }
          deleteMany: {
            args: Prisma.rolmenuDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.rolmenuUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.rolmenuUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$rolmenuPayload>
          }
          aggregate: {
            args: Prisma.RolmenuAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateRolmenu>
          }
          groupBy: {
            args: Prisma.rolmenuGroupByArgs<ExtArgs>,
            result: $Utils.Optional<RolmenuGroupByOutputType>[]
          }
          count: {
            args: Prisma.rolmenuCountArgs<ExtArgs>,
            result: $Utils.Optional<RolmenuCountAggregateOutputType> | number
          }
        }
      }
      telefono: {
        payload: Prisma.$telefonoPayload<ExtArgs>
        fields: Prisma.telefonoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.telefonoFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$telefonoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.telefonoFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$telefonoPayload>
          }
          findFirst: {
            args: Prisma.telefonoFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$telefonoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.telefonoFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$telefonoPayload>
          }
          findMany: {
            args: Prisma.telefonoFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$telefonoPayload>[]
          }
          create: {
            args: Prisma.telefonoCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$telefonoPayload>
          }
          createMany: {
            args: Prisma.telefonoCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.telefonoDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$telefonoPayload>
          }
          update: {
            args: Prisma.telefonoUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$telefonoPayload>
          }
          deleteMany: {
            args: Prisma.telefonoDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.telefonoUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.telefonoUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$telefonoPayload>
          }
          aggregate: {
            args: Prisma.TelefonoAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateTelefono>
          }
          groupBy: {
            args: Prisma.telefonoGroupByArgs<ExtArgs>,
            result: $Utils.Optional<TelefonoGroupByOutputType>[]
          }
          count: {
            args: Prisma.telefonoCountArgs<ExtArgs>,
            result: $Utils.Optional<TelefonoCountAggregateOutputType> | number
          }
        }
      }
      terminado: {
        payload: Prisma.$terminadoPayload<ExtArgs>
        fields: Prisma.terminadoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.terminadoFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$terminadoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.terminadoFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$terminadoPayload>
          }
          findFirst: {
            args: Prisma.terminadoFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$terminadoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.terminadoFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$terminadoPayload>
          }
          findMany: {
            args: Prisma.terminadoFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$terminadoPayload>[]
          }
          create: {
            args: Prisma.terminadoCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$terminadoPayload>
          }
          createMany: {
            args: Prisma.terminadoCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.terminadoDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$terminadoPayload>
          }
          update: {
            args: Prisma.terminadoUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$terminadoPayload>
          }
          deleteMany: {
            args: Prisma.terminadoDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.terminadoUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.terminadoUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$terminadoPayload>
          }
          aggregate: {
            args: Prisma.TerminadoAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateTerminado>
          }
          groupBy: {
            args: Prisma.terminadoGroupByArgs<ExtArgs>,
            result: $Utils.Optional<TerminadoGroupByOutputType>[]
          }
          count: {
            args: Prisma.terminadoCountArgs<ExtArgs>,
            result: $Utils.Optional<TerminadoCountAggregateOutputType> | number
          }
        }
      }
      usuario: {
        payload: Prisma.$usuarioPayload<ExtArgs>
        fields: Prisma.usuarioFieldRefs
        operations: {
          findUnique: {
            args: Prisma.usuarioFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$usuarioPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.usuarioFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$usuarioPayload>
          }
          findFirst: {
            args: Prisma.usuarioFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$usuarioPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.usuarioFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$usuarioPayload>
          }
          findMany: {
            args: Prisma.usuarioFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$usuarioPayload>[]
          }
          create: {
            args: Prisma.usuarioCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$usuarioPayload>
          }
          createMany: {
            args: Prisma.usuarioCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.usuarioDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$usuarioPayload>
          }
          update: {
            args: Prisma.usuarioUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$usuarioPayload>
          }
          deleteMany: {
            args: Prisma.usuarioDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.usuarioUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.usuarioUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$usuarioPayload>
          }
          aggregate: {
            args: Prisma.UsuarioAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateUsuario>
          }
          groupBy: {
            args: Prisma.usuarioGroupByArgs<ExtArgs>,
            result: $Utils.Optional<UsuarioGroupByOutputType>[]
          }
          count: {
            args: Prisma.usuarioCountArgs<ExtArgs>,
            result: $Utils.Optional<UsuarioCountAggregateOutputType> | number
          }
        }
      }
      usurol: {
        payload: Prisma.$usurolPayload<ExtArgs>
        fields: Prisma.usurolFieldRefs
        operations: {
          findUnique: {
            args: Prisma.usurolFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$usurolPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.usurolFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$usurolPayload>
          }
          findFirst: {
            args: Prisma.usurolFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$usurolPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.usurolFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$usurolPayload>
          }
          findMany: {
            args: Prisma.usurolFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$usurolPayload>[]
          }
          create: {
            args: Prisma.usurolCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$usurolPayload>
          }
          createMany: {
            args: Prisma.usurolCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.usurolDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$usurolPayload>
          }
          update: {
            args: Prisma.usurolUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$usurolPayload>
          }
          deleteMany: {
            args: Prisma.usurolDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.usurolUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.usurolUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$usurolPayload>
          }
          aggregate: {
            args: Prisma.UsurolAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateUsurol>
          }
          groupBy: {
            args: Prisma.usurolGroupByArgs<ExtArgs>,
            result: $Utils.Optional<UsurolGroupByOutputType>[]
          }
          count: {
            args: Prisma.usurolCountArgs<ExtArgs>,
            result: $Utils.Optional<UsurolCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<'define', Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type ClienteCountOutputType
   */

  export type ClienteCountOutputType = {
    cotizacion: number
    ordent: number
  }

  export type ClienteCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cotizacion?: boolean | ClienteCountOutputTypeCountCotizacionArgs
    ordent?: boolean | ClienteCountOutputTypeCountOrdentArgs
  }

  // Custom InputTypes

  /**
   * ClienteCountOutputType without action
   */
  export type ClienteCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClienteCountOutputType
     */
    select?: ClienteCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * ClienteCountOutputType without action
   */
  export type ClienteCountOutputTypeCountCotizacionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: cotizacionWhereInput
  }


  /**
   * ClienteCountOutputType without action
   */
  export type ClienteCountOutputTypeCountOrdentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ordentWhereInput
  }



  /**
   * Count Type CotizacionCountOutputType
   */

  export type CotizacionCountOutputType = {
    detcot: number
    ordent: number
  }

  export type CotizacionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    detcot?: boolean | CotizacionCountOutputTypeCountDetcotArgs
    ordent?: boolean | CotizacionCountOutputTypeCountOrdentArgs
  }

  // Custom InputTypes

  /**
   * CotizacionCountOutputType without action
   */
  export type CotizacionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CotizacionCountOutputType
     */
    select?: CotizacionCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * CotizacionCountOutputType without action
   */
  export type CotizacionCountOutputTypeCountDetcotArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: detcotWhereInput
  }


  /**
   * CotizacionCountOutputType without action
   */
  export type CotizacionCountOutputTypeCountOrdentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ordentWhereInput
  }



  /**
   * Count Type EmpresaCountOutputType
   */

  export type EmpresaCountOutputType = {
    leyenda: number
    usuario: number
  }

  export type EmpresaCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    leyenda?: boolean | EmpresaCountOutputTypeCountLeyendaArgs
    usuario?: boolean | EmpresaCountOutputTypeCountUsuarioArgs
  }

  // Custom InputTypes

  /**
   * EmpresaCountOutputType without action
   */
  export type EmpresaCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmpresaCountOutputType
     */
    select?: EmpresaCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * EmpresaCountOutputType without action
   */
  export type EmpresaCountOutputTypeCountLeyendaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: leyendaWhereInput
  }


  /**
   * EmpresaCountOutputType without action
   */
  export type EmpresaCountOutputTypeCountUsuarioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: usuarioWhereInput
  }



  /**
   * Count Type MarcaCountOutputType
   */

  export type MarcaCountOutputType = {
    color: number
    producto: number
    terminado: number
  }

  export type MarcaCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    color?: boolean | MarcaCountOutputTypeCountColorArgs
    producto?: boolean | MarcaCountOutputTypeCountProductoArgs
    terminado?: boolean | MarcaCountOutputTypeCountTerminadoArgs
  }

  // Custom InputTypes

  /**
   * MarcaCountOutputType without action
   */
  export type MarcaCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarcaCountOutputType
     */
    select?: MarcaCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * MarcaCountOutputType without action
   */
  export type MarcaCountOutputTypeCountColorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: colorWhereInput
  }


  /**
   * MarcaCountOutputType without action
   */
  export type MarcaCountOutputTypeCountProductoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: productoWhereInput
  }


  /**
   * MarcaCountOutputType without action
   */
  export type MarcaCountOutputTypeCountTerminadoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: terminadoWhereInput
  }



  /**
   * Count Type MenuCountOutputType
   */

  export type MenuCountOutputType = {
    rolmenu: number
  }

  export type MenuCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    rolmenu?: boolean | MenuCountOutputTypeCountRolmenuArgs
  }

  // Custom InputTypes

  /**
   * MenuCountOutputType without action
   */
  export type MenuCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenuCountOutputType
     */
    select?: MenuCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * MenuCountOutputType without action
   */
  export type MenuCountOutputTypeCountRolmenuArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: rolmenuWhereInput
  }



  /**
   * Count Type OrdentCountOutputType
   */

  export type OrdentCountOutputType = {
    arte1: number
    detot: number
    factura1: number
    pago: number
  }

  export type OrdentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    arte1?: boolean | OrdentCountOutputTypeCountArte1Args
    detot?: boolean | OrdentCountOutputTypeCountDetotArgs
    factura1?: boolean | OrdentCountOutputTypeCountFactura1Args
    pago?: boolean | OrdentCountOutputTypeCountPagoArgs
  }

  // Custom InputTypes

  /**
   * OrdentCountOutputType without action
   */
  export type OrdentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrdentCountOutputType
     */
    select?: OrdentCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * OrdentCountOutputType without action
   */
  export type OrdentCountOutputTypeCountArte1Args<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: arteWhereInput
  }


  /**
   * OrdentCountOutputType without action
   */
  export type OrdentCountOutputTypeCountDetotArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: detotWhereInput
  }


  /**
   * OrdentCountOutputType without action
   */
  export type OrdentCountOutputTypeCountFactura1Args<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: facturaWhereInput
  }


  /**
   * OrdentCountOutputType without action
   */
  export type OrdentCountOutputTypeCountPagoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: pagoWhereInput
  }



  /**
   * Count Type PersonaCountOutputType
   */

  export type PersonaCountOutputType = {
    cliente: number
    empresa: number
    proveedor: number
    telefono: number
    usuario: number
  }

  export type PersonaCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cliente?: boolean | PersonaCountOutputTypeCountClienteArgs
    empresa?: boolean | PersonaCountOutputTypeCountEmpresaArgs
    proveedor?: boolean | PersonaCountOutputTypeCountProveedorArgs
    telefono?: boolean | PersonaCountOutputTypeCountTelefonoArgs
    usuario?: boolean | PersonaCountOutputTypeCountUsuarioArgs
  }

  // Custom InputTypes

  /**
   * PersonaCountOutputType without action
   */
  export type PersonaCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonaCountOutputType
     */
    select?: PersonaCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * PersonaCountOutputType without action
   */
  export type PersonaCountOutputTypeCountClienteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: clienteWhereInput
  }


  /**
   * PersonaCountOutputType without action
   */
  export type PersonaCountOutputTypeCountEmpresaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: empresaWhereInput
  }


  /**
   * PersonaCountOutputType without action
   */
  export type PersonaCountOutputTypeCountProveedorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: proveedorWhereInput
  }


  /**
   * PersonaCountOutputType without action
   */
  export type PersonaCountOutputTypeCountTelefonoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: telefonoWhereInput
  }


  /**
   * PersonaCountOutputType without action
   */
  export type PersonaCountOutputTypeCountUsuarioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: usuarioWhereInput
  }



  /**
   * Count Type ProductoCountOutputType
   */

  export type ProductoCountOutputType = {
    detcot: number
    detot: number
  }

  export type ProductoCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    detcot?: boolean | ProductoCountOutputTypeCountDetcotArgs
    detot?: boolean | ProductoCountOutputTypeCountDetotArgs
  }

  // Custom InputTypes

  /**
   * ProductoCountOutputType without action
   */
  export type ProductoCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductoCountOutputType
     */
    select?: ProductoCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * ProductoCountOutputType without action
   */
  export type ProductoCountOutputTypeCountDetcotArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: detcotWhereInput
  }


  /**
   * ProductoCountOutputType without action
   */
  export type ProductoCountOutputTypeCountDetotArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: detotWhereInput
  }



  /**
   * Count Type ProveedorCountOutputType
   */

  export type ProveedorCountOutputType = {
    inventario: number
  }

  export type ProveedorCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    inventario?: boolean | ProveedorCountOutputTypeCountInventarioArgs
  }

  // Custom InputTypes

  /**
   * ProveedorCountOutputType without action
   */
  export type ProveedorCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProveedorCountOutputType
     */
    select?: ProveedorCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * ProveedorCountOutputType without action
   */
  export type ProveedorCountOutputTypeCountInventarioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: inventarioWhereInput
  }



  /**
   * Count Type RolesCountOutputType
   */

  export type RolesCountOutputType = {
    rolmenu: number
    usurol: number
  }

  export type RolesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    rolmenu?: boolean | RolesCountOutputTypeCountRolmenuArgs
    usurol?: boolean | RolesCountOutputTypeCountUsurolArgs
  }

  // Custom InputTypes

  /**
   * RolesCountOutputType without action
   */
  export type RolesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolesCountOutputType
     */
    select?: RolesCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * RolesCountOutputType without action
   */
  export type RolesCountOutputTypeCountRolmenuArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: rolmenuWhereInput
  }


  /**
   * RolesCountOutputType without action
   */
  export type RolesCountOutputTypeCountUsurolArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: usurolWhereInput
  }



  /**
   * Count Type UsuarioCountOutputType
   */

  export type UsuarioCountOutputType = {
    arte_arte_iduTousuario: number
    arte_arte_iduaTousuario: number
    cotizacion: number
    datos: number
    factura: number
    ordent: number
    registrolaboral: number
    usurol: number
  }

  export type UsuarioCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    arte_arte_iduTousuario?: boolean | UsuarioCountOutputTypeCountArte_arte_iduTousuarioArgs
    arte_arte_iduaTousuario?: boolean | UsuarioCountOutputTypeCountArte_arte_iduaTousuarioArgs
    cotizacion?: boolean | UsuarioCountOutputTypeCountCotizacionArgs
    datos?: boolean | UsuarioCountOutputTypeCountDatosArgs
    factura?: boolean | UsuarioCountOutputTypeCountFacturaArgs
    ordent?: boolean | UsuarioCountOutputTypeCountOrdentArgs
    registrolaboral?: boolean | UsuarioCountOutputTypeCountRegistrolaboralArgs
    usurol?: boolean | UsuarioCountOutputTypeCountUsurolArgs
  }

  // Custom InputTypes

  /**
   * UsuarioCountOutputType without action
   */
  export type UsuarioCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsuarioCountOutputType
     */
    select?: UsuarioCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * UsuarioCountOutputType without action
   */
  export type UsuarioCountOutputTypeCountArte_arte_iduTousuarioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: arteWhereInput
  }


  /**
   * UsuarioCountOutputType without action
   */
  export type UsuarioCountOutputTypeCountArte_arte_iduaTousuarioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: arteWhereInput
  }


  /**
   * UsuarioCountOutputType without action
   */
  export type UsuarioCountOutputTypeCountCotizacionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: cotizacionWhereInput
  }


  /**
   * UsuarioCountOutputType without action
   */
  export type UsuarioCountOutputTypeCountDatosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: datosWhereInput
  }


  /**
   * UsuarioCountOutputType without action
   */
  export type UsuarioCountOutputTypeCountFacturaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: facturaWhereInput
  }


  /**
   * UsuarioCountOutputType without action
   */
  export type UsuarioCountOutputTypeCountOrdentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ordentWhereInput
  }


  /**
   * UsuarioCountOutputType without action
   */
  export type UsuarioCountOutputTypeCountRegistrolaboralArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: registrolaboralWhereInput
  }


  /**
   * UsuarioCountOutputType without action
   */
  export type UsuarioCountOutputTypeCountUsurolArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: usurolWhereInput
  }



  /**
   * Models
   */

  /**
   * Model arte
   */

  export type AggregateArte = {
    _count: ArteCountAggregateOutputType | null
    _avg: ArteAvgAggregateOutputType | null
    _sum: ArteSumAggregateOutputType | null
    _min: ArteMinAggregateOutputType | null
    _max: ArteMaxAggregateOutputType | null
  }

  export type ArteAvgAggregateOutputType = {
    idar: number | null
    idu: number | null
    idot: number | null
    idua: number | null
    precio: number | null
  }

  export type ArteSumAggregateOutputType = {
    idar: number | null
    idu: number | null
    idot: number | null
    idua: number | null
    precio: number | null
  }

  export type ArteMinAggregateOutputType = {
    idar: number | null
    idu: number | null
    idot: number | null
    fechar: Date | null
    fechaa: Date | null
    idua: number | null
    estado: string | null
    obs: string | null
    precio: number | null
  }

  export type ArteMaxAggregateOutputType = {
    idar: number | null
    idu: number | null
    idot: number | null
    fechar: Date | null
    fechaa: Date | null
    idua: number | null
    estado: string | null
    obs: string | null
    precio: number | null
  }

  export type ArteCountAggregateOutputType = {
    idar: number
    idu: number
    idot: number
    fechar: number
    fechaa: number
    idua: number
    estado: number
    obs: number
    precio: number
    _all: number
  }


  export type ArteAvgAggregateInputType = {
    idar?: true
    idu?: true
    idot?: true
    idua?: true
    precio?: true
  }

  export type ArteSumAggregateInputType = {
    idar?: true
    idu?: true
    idot?: true
    idua?: true
    precio?: true
  }

  export type ArteMinAggregateInputType = {
    idar?: true
    idu?: true
    idot?: true
    fechar?: true
    fechaa?: true
    idua?: true
    estado?: true
    obs?: true
    precio?: true
  }

  export type ArteMaxAggregateInputType = {
    idar?: true
    idu?: true
    idot?: true
    fechar?: true
    fechaa?: true
    idua?: true
    estado?: true
    obs?: true
    precio?: true
  }

  export type ArteCountAggregateInputType = {
    idar?: true
    idu?: true
    idot?: true
    fechar?: true
    fechaa?: true
    idua?: true
    estado?: true
    obs?: true
    precio?: true
    _all?: true
  }

  export type ArteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which arte to aggregate.
     */
    where?: arteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of artes to fetch.
     */
    orderBy?: arteOrderByWithRelationInput | arteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: arteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` artes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` artes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned artes
    **/
    _count?: true | ArteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ArteAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ArteSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ArteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ArteMaxAggregateInputType
  }

  export type GetArteAggregateType<T extends ArteAggregateArgs> = {
        [P in keyof T & keyof AggregateArte]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateArte[P]>
      : GetScalarType<T[P], AggregateArte[P]>
  }




  export type arteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: arteWhereInput
    orderBy?: arteOrderByWithAggregationInput | arteOrderByWithAggregationInput[]
    by: ArteScalarFieldEnum[] | ArteScalarFieldEnum
    having?: arteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ArteCountAggregateInputType | true
    _avg?: ArteAvgAggregateInputType
    _sum?: ArteSumAggregateInputType
    _min?: ArteMinAggregateInputType
    _max?: ArteMaxAggregateInputType
  }

  export type ArteGroupByOutputType = {
    idar: number
    idu: number | null
    idot: number | null
    fechar: Date | null
    fechaa: Date | null
    idua: number | null
    estado: string | null
    obs: string | null
    precio: number | null
    _count: ArteCountAggregateOutputType | null
    _avg: ArteAvgAggregateOutputType | null
    _sum: ArteSumAggregateOutputType | null
    _min: ArteMinAggregateOutputType | null
    _max: ArteMaxAggregateOutputType | null
  }

  type GetArteGroupByPayload<T extends arteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ArteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ArteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ArteGroupByOutputType[P]>
            : GetScalarType<T[P], ArteGroupByOutputType[P]>
        }
      >
    >


  export type arteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idar?: boolean
    idu?: boolean
    idot?: boolean
    fechar?: boolean
    fechaa?: boolean
    idua?: boolean
    estado?: boolean
    obs?: boolean
    precio?: boolean
    ordent?: boolean | arte$ordentArgs<ExtArgs>
    usuario_arte_iduTousuario?: boolean | arte$usuario_arte_iduTousuarioArgs<ExtArgs>
    usuario_arte_iduaTousuario?: boolean | arte$usuario_arte_iduaTousuarioArgs<ExtArgs>
  }, ExtArgs["result"]["arte"]>

  export type arteSelectScalar = {
    idar?: boolean
    idu?: boolean
    idot?: boolean
    fechar?: boolean
    fechaa?: boolean
    idua?: boolean
    estado?: boolean
    obs?: boolean
    precio?: boolean
  }

  export type arteInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ordent?: boolean | arte$ordentArgs<ExtArgs>
    usuario_arte_iduTousuario?: boolean | arte$usuario_arte_iduTousuarioArgs<ExtArgs>
    usuario_arte_iduaTousuario?: boolean | arte$usuario_arte_iduaTousuarioArgs<ExtArgs>
  }


  export type $artePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "arte"
    objects: {
      ordent: Prisma.$ordentPayload<ExtArgs> | null
      usuario_arte_iduTousuario: Prisma.$usuarioPayload<ExtArgs> | null
      usuario_arte_iduaTousuario: Prisma.$usuarioPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      idar: number
      idu: number | null
      idot: number | null
      fechar: Date | null
      fechaa: Date | null
      idua: number | null
      estado: string | null
      obs: string | null
      precio: number | null
    }, ExtArgs["result"]["arte"]>
    composites: {}
  }


  type arteGetPayload<S extends boolean | null | undefined | arteDefaultArgs> = $Result.GetResult<Prisma.$artePayload, S>

  type arteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<arteFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: ArteCountAggregateInputType | true
    }

  export interface arteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['arte'], meta: { name: 'arte' } }
    /**
     * Find zero or one Arte that matches the filter.
     * @param {arteFindUniqueArgs} args - Arguments to find a Arte
     * @example
     * // Get one Arte
     * const arte = await prisma.arte.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends arteFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, arteFindUniqueArgs<ExtArgs>>
    ): Prisma__arteClient<$Result.GetResult<Prisma.$artePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Arte that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {arteFindUniqueOrThrowArgs} args - Arguments to find a Arte
     * @example
     * // Get one Arte
     * const arte = await prisma.arte.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends arteFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, arteFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__arteClient<$Result.GetResult<Prisma.$artePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Arte that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {arteFindFirstArgs} args - Arguments to find a Arte
     * @example
     * // Get one Arte
     * const arte = await prisma.arte.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends arteFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, arteFindFirstArgs<ExtArgs>>
    ): Prisma__arteClient<$Result.GetResult<Prisma.$artePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Arte that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {arteFindFirstOrThrowArgs} args - Arguments to find a Arte
     * @example
     * // Get one Arte
     * const arte = await prisma.arte.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends arteFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, arteFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__arteClient<$Result.GetResult<Prisma.$artePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Artes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {arteFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Artes
     * const artes = await prisma.arte.findMany()
     * 
     * // Get first 10 Artes
     * const artes = await prisma.arte.findMany({ take: 10 })
     * 
     * // Only select the `idar`
     * const arteWithIdarOnly = await prisma.arte.findMany({ select: { idar: true } })
     * 
    **/
    findMany<T extends arteFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, arteFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$artePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Arte.
     * @param {arteCreateArgs} args - Arguments to create a Arte.
     * @example
     * // Create one Arte
     * const Arte = await prisma.arte.create({
     *   data: {
     *     // ... data to create a Arte
     *   }
     * })
     * 
    **/
    create<T extends arteCreateArgs<ExtArgs>>(
      args: SelectSubset<T, arteCreateArgs<ExtArgs>>
    ): Prisma__arteClient<$Result.GetResult<Prisma.$artePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Artes.
     *     @param {arteCreateManyArgs} args - Arguments to create many Artes.
     *     @example
     *     // Create many Artes
     *     const arte = await prisma.arte.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends arteCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, arteCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Arte.
     * @param {arteDeleteArgs} args - Arguments to delete one Arte.
     * @example
     * // Delete one Arte
     * const Arte = await prisma.arte.delete({
     *   where: {
     *     // ... filter to delete one Arte
     *   }
     * })
     * 
    **/
    delete<T extends arteDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, arteDeleteArgs<ExtArgs>>
    ): Prisma__arteClient<$Result.GetResult<Prisma.$artePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Arte.
     * @param {arteUpdateArgs} args - Arguments to update one Arte.
     * @example
     * // Update one Arte
     * const arte = await prisma.arte.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends arteUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, arteUpdateArgs<ExtArgs>>
    ): Prisma__arteClient<$Result.GetResult<Prisma.$artePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Artes.
     * @param {arteDeleteManyArgs} args - Arguments to filter Artes to delete.
     * @example
     * // Delete a few Artes
     * const { count } = await prisma.arte.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends arteDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, arteDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Artes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {arteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Artes
     * const arte = await prisma.arte.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends arteUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, arteUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Arte.
     * @param {arteUpsertArgs} args - Arguments to update or create a Arte.
     * @example
     * // Update or create a Arte
     * const arte = await prisma.arte.upsert({
     *   create: {
     *     // ... data to create a Arte
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Arte we want to update
     *   }
     * })
    **/
    upsert<T extends arteUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, arteUpsertArgs<ExtArgs>>
    ): Prisma__arteClient<$Result.GetResult<Prisma.$artePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Artes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {arteCountArgs} args - Arguments to filter Artes to count.
     * @example
     * // Count the number of Artes
     * const count = await prisma.arte.count({
     *   where: {
     *     // ... the filter for the Artes we want to count
     *   }
     * })
    **/
    count<T extends arteCountArgs>(
      args?: Subset<T, arteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ArteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Arte.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ArteAggregateArgs>(args: Subset<T, ArteAggregateArgs>): Prisma.PrismaPromise<GetArteAggregateType<T>>

    /**
     * Group by Arte.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {arteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends arteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: arteGroupByArgs['orderBy'] }
        : { orderBy?: arteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, arteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetArteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the arte model
   */
  readonly fields: arteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for arte.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__arteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    ordent<T extends arte$ordentArgs<ExtArgs> = {}>(args?: Subset<T, arte$ordentArgs<ExtArgs>>): Prisma__ordentClient<$Result.GetResult<Prisma.$ordentPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    usuario_arte_iduTousuario<T extends arte$usuario_arte_iduTousuarioArgs<ExtArgs> = {}>(args?: Subset<T, arte$usuario_arte_iduTousuarioArgs<ExtArgs>>): Prisma__usuarioClient<$Result.GetResult<Prisma.$usuarioPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    usuario_arte_iduaTousuario<T extends arte$usuario_arte_iduaTousuarioArgs<ExtArgs> = {}>(args?: Subset<T, arte$usuario_arte_iduaTousuarioArgs<ExtArgs>>): Prisma__usuarioClient<$Result.GetResult<Prisma.$usuarioPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the arte model
   */ 
  interface arteFieldRefs {
    readonly idar: FieldRef<"arte", 'Int'>
    readonly idu: FieldRef<"arte", 'Int'>
    readonly idot: FieldRef<"arte", 'Int'>
    readonly fechar: FieldRef<"arte", 'DateTime'>
    readonly fechaa: FieldRef<"arte", 'DateTime'>
    readonly idua: FieldRef<"arte", 'Int'>
    readonly estado: FieldRef<"arte", 'String'>
    readonly obs: FieldRef<"arte", 'String'>
    readonly precio: FieldRef<"arte", 'Float'>
  }
    

  // Custom InputTypes

  /**
   * arte findUnique
   */
  export type arteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the arte
     */
    select?: arteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: arteInclude<ExtArgs> | null
    /**
     * Filter, which arte to fetch.
     */
    where: arteWhereUniqueInput
  }


  /**
   * arte findUniqueOrThrow
   */
  export type arteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the arte
     */
    select?: arteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: arteInclude<ExtArgs> | null
    /**
     * Filter, which arte to fetch.
     */
    where: arteWhereUniqueInput
  }


  /**
   * arte findFirst
   */
  export type arteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the arte
     */
    select?: arteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: arteInclude<ExtArgs> | null
    /**
     * Filter, which arte to fetch.
     */
    where?: arteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of artes to fetch.
     */
    orderBy?: arteOrderByWithRelationInput | arteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for artes.
     */
    cursor?: arteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` artes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` artes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of artes.
     */
    distinct?: ArteScalarFieldEnum | ArteScalarFieldEnum[]
  }


  /**
   * arte findFirstOrThrow
   */
  export type arteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the arte
     */
    select?: arteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: arteInclude<ExtArgs> | null
    /**
     * Filter, which arte to fetch.
     */
    where?: arteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of artes to fetch.
     */
    orderBy?: arteOrderByWithRelationInput | arteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for artes.
     */
    cursor?: arteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` artes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` artes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of artes.
     */
    distinct?: ArteScalarFieldEnum | ArteScalarFieldEnum[]
  }


  /**
   * arte findMany
   */
  export type arteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the arte
     */
    select?: arteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: arteInclude<ExtArgs> | null
    /**
     * Filter, which artes to fetch.
     */
    where?: arteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of artes to fetch.
     */
    orderBy?: arteOrderByWithRelationInput | arteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing artes.
     */
    cursor?: arteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` artes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` artes.
     */
    skip?: number
    distinct?: ArteScalarFieldEnum | ArteScalarFieldEnum[]
  }


  /**
   * arte create
   */
  export type arteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the arte
     */
    select?: arteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: arteInclude<ExtArgs> | null
    /**
     * The data needed to create a arte.
     */
    data?: XOR<arteCreateInput, arteUncheckedCreateInput>
  }


  /**
   * arte createMany
   */
  export type arteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many artes.
     */
    data: arteCreateManyInput | arteCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * arte update
   */
  export type arteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the arte
     */
    select?: arteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: arteInclude<ExtArgs> | null
    /**
     * The data needed to update a arte.
     */
    data: XOR<arteUpdateInput, arteUncheckedUpdateInput>
    /**
     * Choose, which arte to update.
     */
    where: arteWhereUniqueInput
  }


  /**
   * arte updateMany
   */
  export type arteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update artes.
     */
    data: XOR<arteUpdateManyMutationInput, arteUncheckedUpdateManyInput>
    /**
     * Filter which artes to update
     */
    where?: arteWhereInput
  }


  /**
   * arte upsert
   */
  export type arteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the arte
     */
    select?: arteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: arteInclude<ExtArgs> | null
    /**
     * The filter to search for the arte to update in case it exists.
     */
    where: arteWhereUniqueInput
    /**
     * In case the arte found by the `where` argument doesn't exist, create a new arte with this data.
     */
    create: XOR<arteCreateInput, arteUncheckedCreateInput>
    /**
     * In case the arte was found with the provided `where` argument, update it with this data.
     */
    update: XOR<arteUpdateInput, arteUncheckedUpdateInput>
  }


  /**
   * arte delete
   */
  export type arteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the arte
     */
    select?: arteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: arteInclude<ExtArgs> | null
    /**
     * Filter which arte to delete.
     */
    where: arteWhereUniqueInput
  }


  /**
   * arte deleteMany
   */
  export type arteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which artes to delete
     */
    where?: arteWhereInput
  }


  /**
   * arte.ordent
   */
  export type arte$ordentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ordent
     */
    select?: ordentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ordentInclude<ExtArgs> | null
    where?: ordentWhereInput
  }


  /**
   * arte.usuario_arte_iduTousuario
   */
  export type arte$usuario_arte_iduTousuarioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usuario
     */
    select?: usuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: usuarioInclude<ExtArgs> | null
    where?: usuarioWhereInput
  }


  /**
   * arte.usuario_arte_iduaTousuario
   */
  export type arte$usuario_arte_iduaTousuarioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usuario
     */
    select?: usuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: usuarioInclude<ExtArgs> | null
    where?: usuarioWhereInput
  }


  /**
   * arte without action
   */
  export type arteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the arte
     */
    select?: arteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: arteInclude<ExtArgs> | null
  }



  /**
   * Model cliente
   */

  export type AggregateCliente = {
    _count: ClienteCountAggregateOutputType | null
    _avg: ClienteAvgAggregateOutputType | null
    _sum: ClienteSumAggregateOutputType | null
    _min: ClienteMinAggregateOutputType | null
    _max: ClienteMaxAggregateOutputType | null
  }

  export type ClienteAvgAggregateOutputType = {
    idcli: number | null
    idpe: number | null
  }

  export type ClienteSumAggregateOutputType = {
    idcli: number | null
    idpe: number | null
  }

  export type ClienteMinAggregateOutputType = {
    idcli: number | null
    idpe: number | null
    estado: boolean | null
  }

  export type ClienteMaxAggregateOutputType = {
    idcli: number | null
    idpe: number | null
    estado: boolean | null
  }

  export type ClienteCountAggregateOutputType = {
    idcli: number
    idpe: number
    estado: number
    _all: number
  }


  export type ClienteAvgAggregateInputType = {
    idcli?: true
    idpe?: true
  }

  export type ClienteSumAggregateInputType = {
    idcli?: true
    idpe?: true
  }

  export type ClienteMinAggregateInputType = {
    idcli?: true
    idpe?: true
    estado?: true
  }

  export type ClienteMaxAggregateInputType = {
    idcli?: true
    idpe?: true
    estado?: true
  }

  export type ClienteCountAggregateInputType = {
    idcli?: true
    idpe?: true
    estado?: true
    _all?: true
  }

  export type ClienteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which cliente to aggregate.
     */
    where?: clienteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of clientes to fetch.
     */
    orderBy?: clienteOrderByWithRelationInput | clienteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: clienteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` clientes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` clientes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned clientes
    **/
    _count?: true | ClienteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ClienteAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ClienteSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClienteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClienteMaxAggregateInputType
  }

  export type GetClienteAggregateType<T extends ClienteAggregateArgs> = {
        [P in keyof T & keyof AggregateCliente]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCliente[P]>
      : GetScalarType<T[P], AggregateCliente[P]>
  }




  export type clienteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: clienteWhereInput
    orderBy?: clienteOrderByWithAggregationInput | clienteOrderByWithAggregationInput[]
    by: ClienteScalarFieldEnum[] | ClienteScalarFieldEnum
    having?: clienteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClienteCountAggregateInputType | true
    _avg?: ClienteAvgAggregateInputType
    _sum?: ClienteSumAggregateInputType
    _min?: ClienteMinAggregateInputType
    _max?: ClienteMaxAggregateInputType
  }

  export type ClienteGroupByOutputType = {
    idcli: number
    idpe: number
    estado: boolean | null
    _count: ClienteCountAggregateOutputType | null
    _avg: ClienteAvgAggregateOutputType | null
    _sum: ClienteSumAggregateOutputType | null
    _min: ClienteMinAggregateOutputType | null
    _max: ClienteMaxAggregateOutputType | null
  }

  type GetClienteGroupByPayload<T extends clienteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClienteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClienteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClienteGroupByOutputType[P]>
            : GetScalarType<T[P], ClienteGroupByOutputType[P]>
        }
      >
    >


  export type clienteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idcli?: boolean
    idpe?: boolean
    estado?: boolean
    persona?: boolean | personaDefaultArgs<ExtArgs>
    cotizacion?: boolean | cliente$cotizacionArgs<ExtArgs>
    ordent?: boolean | cliente$ordentArgs<ExtArgs>
    _count?: boolean | ClienteCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cliente"]>

  export type clienteSelectScalar = {
    idcli?: boolean
    idpe?: boolean
    estado?: boolean
  }

  export type clienteInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    persona?: boolean | personaDefaultArgs<ExtArgs>
    cotizacion?: boolean | cliente$cotizacionArgs<ExtArgs>
    ordent?: boolean | cliente$ordentArgs<ExtArgs>
    _count?: boolean | ClienteCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $clientePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "cliente"
    objects: {
      persona: Prisma.$personaPayload<ExtArgs>
      cotizacion: Prisma.$cotizacionPayload<ExtArgs>[]
      ordent: Prisma.$ordentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      idcli: number
      idpe: number
      estado: boolean | null
    }, ExtArgs["result"]["cliente"]>
    composites: {}
  }


  type clienteGetPayload<S extends boolean | null | undefined | clienteDefaultArgs> = $Result.GetResult<Prisma.$clientePayload, S>

  type clienteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<clienteFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: ClienteCountAggregateInputType | true
    }

  export interface clienteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['cliente'], meta: { name: 'cliente' } }
    /**
     * Find zero or one Cliente that matches the filter.
     * @param {clienteFindUniqueArgs} args - Arguments to find a Cliente
     * @example
     * // Get one Cliente
     * const cliente = await prisma.cliente.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends clienteFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, clienteFindUniqueArgs<ExtArgs>>
    ): Prisma__clienteClient<$Result.GetResult<Prisma.$clientePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Cliente that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {clienteFindUniqueOrThrowArgs} args - Arguments to find a Cliente
     * @example
     * // Get one Cliente
     * const cliente = await prisma.cliente.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends clienteFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, clienteFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__clienteClient<$Result.GetResult<Prisma.$clientePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Cliente that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {clienteFindFirstArgs} args - Arguments to find a Cliente
     * @example
     * // Get one Cliente
     * const cliente = await prisma.cliente.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends clienteFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, clienteFindFirstArgs<ExtArgs>>
    ): Prisma__clienteClient<$Result.GetResult<Prisma.$clientePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Cliente that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {clienteFindFirstOrThrowArgs} args - Arguments to find a Cliente
     * @example
     * // Get one Cliente
     * const cliente = await prisma.cliente.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends clienteFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, clienteFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__clienteClient<$Result.GetResult<Prisma.$clientePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Clientes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {clienteFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Clientes
     * const clientes = await prisma.cliente.findMany()
     * 
     * // Get first 10 Clientes
     * const clientes = await prisma.cliente.findMany({ take: 10 })
     * 
     * // Only select the `idcli`
     * const clienteWithIdcliOnly = await prisma.cliente.findMany({ select: { idcli: true } })
     * 
    **/
    findMany<T extends clienteFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, clienteFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$clientePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Cliente.
     * @param {clienteCreateArgs} args - Arguments to create a Cliente.
     * @example
     * // Create one Cliente
     * const Cliente = await prisma.cliente.create({
     *   data: {
     *     // ... data to create a Cliente
     *   }
     * })
     * 
    **/
    create<T extends clienteCreateArgs<ExtArgs>>(
      args: SelectSubset<T, clienteCreateArgs<ExtArgs>>
    ): Prisma__clienteClient<$Result.GetResult<Prisma.$clientePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Clientes.
     *     @param {clienteCreateManyArgs} args - Arguments to create many Clientes.
     *     @example
     *     // Create many Clientes
     *     const cliente = await prisma.cliente.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends clienteCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, clienteCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Cliente.
     * @param {clienteDeleteArgs} args - Arguments to delete one Cliente.
     * @example
     * // Delete one Cliente
     * const Cliente = await prisma.cliente.delete({
     *   where: {
     *     // ... filter to delete one Cliente
     *   }
     * })
     * 
    **/
    delete<T extends clienteDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, clienteDeleteArgs<ExtArgs>>
    ): Prisma__clienteClient<$Result.GetResult<Prisma.$clientePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Cliente.
     * @param {clienteUpdateArgs} args - Arguments to update one Cliente.
     * @example
     * // Update one Cliente
     * const cliente = await prisma.cliente.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends clienteUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, clienteUpdateArgs<ExtArgs>>
    ): Prisma__clienteClient<$Result.GetResult<Prisma.$clientePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Clientes.
     * @param {clienteDeleteManyArgs} args - Arguments to filter Clientes to delete.
     * @example
     * // Delete a few Clientes
     * const { count } = await prisma.cliente.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends clienteDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, clienteDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Clientes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {clienteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Clientes
     * const cliente = await prisma.cliente.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends clienteUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, clienteUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Cliente.
     * @param {clienteUpsertArgs} args - Arguments to update or create a Cliente.
     * @example
     * // Update or create a Cliente
     * const cliente = await prisma.cliente.upsert({
     *   create: {
     *     // ... data to create a Cliente
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Cliente we want to update
     *   }
     * })
    **/
    upsert<T extends clienteUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, clienteUpsertArgs<ExtArgs>>
    ): Prisma__clienteClient<$Result.GetResult<Prisma.$clientePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Clientes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {clienteCountArgs} args - Arguments to filter Clientes to count.
     * @example
     * // Count the number of Clientes
     * const count = await prisma.cliente.count({
     *   where: {
     *     // ... the filter for the Clientes we want to count
     *   }
     * })
    **/
    count<T extends clienteCountArgs>(
      args?: Subset<T, clienteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClienteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Cliente.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClienteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClienteAggregateArgs>(args: Subset<T, ClienteAggregateArgs>): Prisma.PrismaPromise<GetClienteAggregateType<T>>

    /**
     * Group by Cliente.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {clienteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends clienteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: clienteGroupByArgs['orderBy'] }
        : { orderBy?: clienteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, clienteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClienteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the cliente model
   */
  readonly fields: clienteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for cliente.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__clienteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    persona<T extends personaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, personaDefaultArgs<ExtArgs>>): Prisma__personaClient<$Result.GetResult<Prisma.$personaPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    cotizacion<T extends cliente$cotizacionArgs<ExtArgs> = {}>(args?: Subset<T, cliente$cotizacionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$cotizacionPayload<ExtArgs>, T, 'findMany'> | Null>;

    ordent<T extends cliente$ordentArgs<ExtArgs> = {}>(args?: Subset<T, cliente$ordentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ordentPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the cliente model
   */ 
  interface clienteFieldRefs {
    readonly idcli: FieldRef<"cliente", 'Int'>
    readonly idpe: FieldRef<"cliente", 'Int'>
    readonly estado: FieldRef<"cliente", 'Boolean'>
  }
    

  // Custom InputTypes

  /**
   * cliente findUnique
   */
  export type clienteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cliente
     */
    select?: clienteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: clienteInclude<ExtArgs> | null
    /**
     * Filter, which cliente to fetch.
     */
    where: clienteWhereUniqueInput
  }


  /**
   * cliente findUniqueOrThrow
   */
  export type clienteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cliente
     */
    select?: clienteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: clienteInclude<ExtArgs> | null
    /**
     * Filter, which cliente to fetch.
     */
    where: clienteWhereUniqueInput
  }


  /**
   * cliente findFirst
   */
  export type clienteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cliente
     */
    select?: clienteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: clienteInclude<ExtArgs> | null
    /**
     * Filter, which cliente to fetch.
     */
    where?: clienteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of clientes to fetch.
     */
    orderBy?: clienteOrderByWithRelationInput | clienteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for clientes.
     */
    cursor?: clienteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` clientes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` clientes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of clientes.
     */
    distinct?: ClienteScalarFieldEnum | ClienteScalarFieldEnum[]
  }


  /**
   * cliente findFirstOrThrow
   */
  export type clienteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cliente
     */
    select?: clienteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: clienteInclude<ExtArgs> | null
    /**
     * Filter, which cliente to fetch.
     */
    where?: clienteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of clientes to fetch.
     */
    orderBy?: clienteOrderByWithRelationInput | clienteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for clientes.
     */
    cursor?: clienteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` clientes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` clientes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of clientes.
     */
    distinct?: ClienteScalarFieldEnum | ClienteScalarFieldEnum[]
  }


  /**
   * cliente findMany
   */
  export type clienteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cliente
     */
    select?: clienteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: clienteInclude<ExtArgs> | null
    /**
     * Filter, which clientes to fetch.
     */
    where?: clienteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of clientes to fetch.
     */
    orderBy?: clienteOrderByWithRelationInput | clienteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing clientes.
     */
    cursor?: clienteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` clientes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` clientes.
     */
    skip?: number
    distinct?: ClienteScalarFieldEnum | ClienteScalarFieldEnum[]
  }


  /**
   * cliente create
   */
  export type clienteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cliente
     */
    select?: clienteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: clienteInclude<ExtArgs> | null
    /**
     * The data needed to create a cliente.
     */
    data: XOR<clienteCreateInput, clienteUncheckedCreateInput>
  }


  /**
   * cliente createMany
   */
  export type clienteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many clientes.
     */
    data: clienteCreateManyInput | clienteCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * cliente update
   */
  export type clienteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cliente
     */
    select?: clienteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: clienteInclude<ExtArgs> | null
    /**
     * The data needed to update a cliente.
     */
    data: XOR<clienteUpdateInput, clienteUncheckedUpdateInput>
    /**
     * Choose, which cliente to update.
     */
    where: clienteWhereUniqueInput
  }


  /**
   * cliente updateMany
   */
  export type clienteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update clientes.
     */
    data: XOR<clienteUpdateManyMutationInput, clienteUncheckedUpdateManyInput>
    /**
     * Filter which clientes to update
     */
    where?: clienteWhereInput
  }


  /**
   * cliente upsert
   */
  export type clienteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cliente
     */
    select?: clienteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: clienteInclude<ExtArgs> | null
    /**
     * The filter to search for the cliente to update in case it exists.
     */
    where: clienteWhereUniqueInput
    /**
     * In case the cliente found by the `where` argument doesn't exist, create a new cliente with this data.
     */
    create: XOR<clienteCreateInput, clienteUncheckedCreateInput>
    /**
     * In case the cliente was found with the provided `where` argument, update it with this data.
     */
    update: XOR<clienteUpdateInput, clienteUncheckedUpdateInput>
  }


  /**
   * cliente delete
   */
  export type clienteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cliente
     */
    select?: clienteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: clienteInclude<ExtArgs> | null
    /**
     * Filter which cliente to delete.
     */
    where: clienteWhereUniqueInput
  }


  /**
   * cliente deleteMany
   */
  export type clienteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which clientes to delete
     */
    where?: clienteWhereInput
  }


  /**
   * cliente.cotizacion
   */
  export type cliente$cotizacionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cotizacion
     */
    select?: cotizacionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: cotizacionInclude<ExtArgs> | null
    where?: cotizacionWhereInput
    orderBy?: cotizacionOrderByWithRelationInput | cotizacionOrderByWithRelationInput[]
    cursor?: cotizacionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CotizacionScalarFieldEnum | CotizacionScalarFieldEnum[]
  }


  /**
   * cliente.ordent
   */
  export type cliente$ordentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ordent
     */
    select?: ordentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ordentInclude<ExtArgs> | null
    where?: ordentWhereInput
    orderBy?: ordentOrderByWithRelationInput | ordentOrderByWithRelationInput[]
    cursor?: ordentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrdentScalarFieldEnum | OrdentScalarFieldEnum[]
  }


  /**
   * cliente without action
   */
  export type clienteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cliente
     */
    select?: clienteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: clienteInclude<ExtArgs> | null
  }



  /**
   * Model color
   */

  export type AggregateColor = {
    _count: ColorCountAggregateOutputType | null
    _avg: ColorAvgAggregateOutputType | null
    _sum: ColorSumAggregateOutputType | null
    _min: ColorMinAggregateOutputType | null
    _max: ColorMaxAggregateOutputType | null
  }

  export type ColorAvgAggregateOutputType = {
    idcolor: number | null
    punit: number | null
    idmar: number | null
  }

  export type ColorSumAggregateOutputType = {
    idcolor: number | null
    punit: number | null
    idmar: number | null
  }

  export type ColorMinAggregateOutputType = {
    idcolor: number | null
    nom: string | null
    punit: number | null
    idmar: number | null
    estado: boolean | null
    des: string | null
  }

  export type ColorMaxAggregateOutputType = {
    idcolor: number | null
    nom: string | null
    punit: number | null
    idmar: number | null
    estado: boolean | null
    des: string | null
  }

  export type ColorCountAggregateOutputType = {
    idcolor: number
    nom: number
    punit: number
    idmar: number
    estado: number
    des: number
    _all: number
  }


  export type ColorAvgAggregateInputType = {
    idcolor?: true
    punit?: true
    idmar?: true
  }

  export type ColorSumAggregateInputType = {
    idcolor?: true
    punit?: true
    idmar?: true
  }

  export type ColorMinAggregateInputType = {
    idcolor?: true
    nom?: true
    punit?: true
    idmar?: true
    estado?: true
    des?: true
  }

  export type ColorMaxAggregateInputType = {
    idcolor?: true
    nom?: true
    punit?: true
    idmar?: true
    estado?: true
    des?: true
  }

  export type ColorCountAggregateInputType = {
    idcolor?: true
    nom?: true
    punit?: true
    idmar?: true
    estado?: true
    des?: true
    _all?: true
  }

  export type ColorAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which color to aggregate.
     */
    where?: colorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of colors to fetch.
     */
    orderBy?: colorOrderByWithRelationInput | colorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: colorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` colors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` colors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned colors
    **/
    _count?: true | ColorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ColorAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ColorSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ColorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ColorMaxAggregateInputType
  }

  export type GetColorAggregateType<T extends ColorAggregateArgs> = {
        [P in keyof T & keyof AggregateColor]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateColor[P]>
      : GetScalarType<T[P], AggregateColor[P]>
  }




  export type colorGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: colorWhereInput
    orderBy?: colorOrderByWithAggregationInput | colorOrderByWithAggregationInput[]
    by: ColorScalarFieldEnum[] | ColorScalarFieldEnum
    having?: colorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ColorCountAggregateInputType | true
    _avg?: ColorAvgAggregateInputType
    _sum?: ColorSumAggregateInputType
    _min?: ColorMinAggregateInputType
    _max?: ColorMaxAggregateInputType
  }

  export type ColorGroupByOutputType = {
    idcolor: number
    nom: string | null
    punit: number | null
    idmar: number | null
    estado: boolean | null
    des: string | null
    _count: ColorCountAggregateOutputType | null
    _avg: ColorAvgAggregateOutputType | null
    _sum: ColorSumAggregateOutputType | null
    _min: ColorMinAggregateOutputType | null
    _max: ColorMaxAggregateOutputType | null
  }

  type GetColorGroupByPayload<T extends colorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ColorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ColorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ColorGroupByOutputType[P]>
            : GetScalarType<T[P], ColorGroupByOutputType[P]>
        }
      >
    >


  export type colorSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idcolor?: boolean
    nom?: boolean
    punit?: boolean
    idmar?: boolean
    estado?: boolean
    des?: boolean
    marca?: boolean | color$marcaArgs<ExtArgs>
  }, ExtArgs["result"]["color"]>

  export type colorSelectScalar = {
    idcolor?: boolean
    nom?: boolean
    punit?: boolean
    idmar?: boolean
    estado?: boolean
    des?: boolean
  }

  export type colorInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    marca?: boolean | color$marcaArgs<ExtArgs>
  }


  export type $colorPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "color"
    objects: {
      marca: Prisma.$marcaPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      idcolor: number
      nom: string | null
      punit: number | null
      idmar: number | null
      estado: boolean | null
      des: string | null
    }, ExtArgs["result"]["color"]>
    composites: {}
  }


  type colorGetPayload<S extends boolean | null | undefined | colorDefaultArgs> = $Result.GetResult<Prisma.$colorPayload, S>

  type colorCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<colorFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: ColorCountAggregateInputType | true
    }

  export interface colorDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['color'], meta: { name: 'color' } }
    /**
     * Find zero or one Color that matches the filter.
     * @param {colorFindUniqueArgs} args - Arguments to find a Color
     * @example
     * // Get one Color
     * const color = await prisma.color.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends colorFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, colorFindUniqueArgs<ExtArgs>>
    ): Prisma__colorClient<$Result.GetResult<Prisma.$colorPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Color that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {colorFindUniqueOrThrowArgs} args - Arguments to find a Color
     * @example
     * // Get one Color
     * const color = await prisma.color.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends colorFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, colorFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__colorClient<$Result.GetResult<Prisma.$colorPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Color that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {colorFindFirstArgs} args - Arguments to find a Color
     * @example
     * // Get one Color
     * const color = await prisma.color.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends colorFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, colorFindFirstArgs<ExtArgs>>
    ): Prisma__colorClient<$Result.GetResult<Prisma.$colorPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Color that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {colorFindFirstOrThrowArgs} args - Arguments to find a Color
     * @example
     * // Get one Color
     * const color = await prisma.color.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends colorFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, colorFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__colorClient<$Result.GetResult<Prisma.$colorPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Colors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {colorFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Colors
     * const colors = await prisma.color.findMany()
     * 
     * // Get first 10 Colors
     * const colors = await prisma.color.findMany({ take: 10 })
     * 
     * // Only select the `idcolor`
     * const colorWithIdcolorOnly = await prisma.color.findMany({ select: { idcolor: true } })
     * 
    **/
    findMany<T extends colorFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, colorFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$colorPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Color.
     * @param {colorCreateArgs} args - Arguments to create a Color.
     * @example
     * // Create one Color
     * const Color = await prisma.color.create({
     *   data: {
     *     // ... data to create a Color
     *   }
     * })
     * 
    **/
    create<T extends colorCreateArgs<ExtArgs>>(
      args: SelectSubset<T, colorCreateArgs<ExtArgs>>
    ): Prisma__colorClient<$Result.GetResult<Prisma.$colorPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Colors.
     *     @param {colorCreateManyArgs} args - Arguments to create many Colors.
     *     @example
     *     // Create many Colors
     *     const color = await prisma.color.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends colorCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, colorCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Color.
     * @param {colorDeleteArgs} args - Arguments to delete one Color.
     * @example
     * // Delete one Color
     * const Color = await prisma.color.delete({
     *   where: {
     *     // ... filter to delete one Color
     *   }
     * })
     * 
    **/
    delete<T extends colorDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, colorDeleteArgs<ExtArgs>>
    ): Prisma__colorClient<$Result.GetResult<Prisma.$colorPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Color.
     * @param {colorUpdateArgs} args - Arguments to update one Color.
     * @example
     * // Update one Color
     * const color = await prisma.color.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends colorUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, colorUpdateArgs<ExtArgs>>
    ): Prisma__colorClient<$Result.GetResult<Prisma.$colorPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Colors.
     * @param {colorDeleteManyArgs} args - Arguments to filter Colors to delete.
     * @example
     * // Delete a few Colors
     * const { count } = await prisma.color.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends colorDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, colorDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Colors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {colorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Colors
     * const color = await prisma.color.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends colorUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, colorUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Color.
     * @param {colorUpsertArgs} args - Arguments to update or create a Color.
     * @example
     * // Update or create a Color
     * const color = await prisma.color.upsert({
     *   create: {
     *     // ... data to create a Color
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Color we want to update
     *   }
     * })
    **/
    upsert<T extends colorUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, colorUpsertArgs<ExtArgs>>
    ): Prisma__colorClient<$Result.GetResult<Prisma.$colorPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Colors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {colorCountArgs} args - Arguments to filter Colors to count.
     * @example
     * // Count the number of Colors
     * const count = await prisma.color.count({
     *   where: {
     *     // ... the filter for the Colors we want to count
     *   }
     * })
    **/
    count<T extends colorCountArgs>(
      args?: Subset<T, colorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ColorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Color.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ColorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ColorAggregateArgs>(args: Subset<T, ColorAggregateArgs>): Prisma.PrismaPromise<GetColorAggregateType<T>>

    /**
     * Group by Color.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {colorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends colorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: colorGroupByArgs['orderBy'] }
        : { orderBy?: colorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, colorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetColorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the color model
   */
  readonly fields: colorFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for color.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__colorClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    marca<T extends color$marcaArgs<ExtArgs> = {}>(args?: Subset<T, color$marcaArgs<ExtArgs>>): Prisma__marcaClient<$Result.GetResult<Prisma.$marcaPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the color model
   */ 
  interface colorFieldRefs {
    readonly idcolor: FieldRef<"color", 'Int'>
    readonly nom: FieldRef<"color", 'String'>
    readonly punit: FieldRef<"color", 'Float'>
    readonly idmar: FieldRef<"color", 'Int'>
    readonly estado: FieldRef<"color", 'Boolean'>
    readonly des: FieldRef<"color", 'String'>
  }
    

  // Custom InputTypes

  /**
   * color findUnique
   */
  export type colorFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the color
     */
    select?: colorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: colorInclude<ExtArgs> | null
    /**
     * Filter, which color to fetch.
     */
    where: colorWhereUniqueInput
  }


  /**
   * color findUniqueOrThrow
   */
  export type colorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the color
     */
    select?: colorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: colorInclude<ExtArgs> | null
    /**
     * Filter, which color to fetch.
     */
    where: colorWhereUniqueInput
  }


  /**
   * color findFirst
   */
  export type colorFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the color
     */
    select?: colorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: colorInclude<ExtArgs> | null
    /**
     * Filter, which color to fetch.
     */
    where?: colorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of colors to fetch.
     */
    orderBy?: colorOrderByWithRelationInput | colorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for colors.
     */
    cursor?: colorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` colors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` colors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of colors.
     */
    distinct?: ColorScalarFieldEnum | ColorScalarFieldEnum[]
  }


  /**
   * color findFirstOrThrow
   */
  export type colorFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the color
     */
    select?: colorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: colorInclude<ExtArgs> | null
    /**
     * Filter, which color to fetch.
     */
    where?: colorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of colors to fetch.
     */
    orderBy?: colorOrderByWithRelationInput | colorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for colors.
     */
    cursor?: colorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` colors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` colors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of colors.
     */
    distinct?: ColorScalarFieldEnum | ColorScalarFieldEnum[]
  }


  /**
   * color findMany
   */
  export type colorFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the color
     */
    select?: colorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: colorInclude<ExtArgs> | null
    /**
     * Filter, which colors to fetch.
     */
    where?: colorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of colors to fetch.
     */
    orderBy?: colorOrderByWithRelationInput | colorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing colors.
     */
    cursor?: colorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` colors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` colors.
     */
    skip?: number
    distinct?: ColorScalarFieldEnum | ColorScalarFieldEnum[]
  }


  /**
   * color create
   */
  export type colorCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the color
     */
    select?: colorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: colorInclude<ExtArgs> | null
    /**
     * The data needed to create a color.
     */
    data?: XOR<colorCreateInput, colorUncheckedCreateInput>
  }


  /**
   * color createMany
   */
  export type colorCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many colors.
     */
    data: colorCreateManyInput | colorCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * color update
   */
  export type colorUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the color
     */
    select?: colorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: colorInclude<ExtArgs> | null
    /**
     * The data needed to update a color.
     */
    data: XOR<colorUpdateInput, colorUncheckedUpdateInput>
    /**
     * Choose, which color to update.
     */
    where: colorWhereUniqueInput
  }


  /**
   * color updateMany
   */
  export type colorUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update colors.
     */
    data: XOR<colorUpdateManyMutationInput, colorUncheckedUpdateManyInput>
    /**
     * Filter which colors to update
     */
    where?: colorWhereInput
  }


  /**
   * color upsert
   */
  export type colorUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the color
     */
    select?: colorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: colorInclude<ExtArgs> | null
    /**
     * The filter to search for the color to update in case it exists.
     */
    where: colorWhereUniqueInput
    /**
     * In case the color found by the `where` argument doesn't exist, create a new color with this data.
     */
    create: XOR<colorCreateInput, colorUncheckedCreateInput>
    /**
     * In case the color was found with the provided `where` argument, update it with this data.
     */
    update: XOR<colorUpdateInput, colorUncheckedUpdateInput>
  }


  /**
   * color delete
   */
  export type colorDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the color
     */
    select?: colorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: colorInclude<ExtArgs> | null
    /**
     * Filter which color to delete.
     */
    where: colorWhereUniqueInput
  }


  /**
   * color deleteMany
   */
  export type colorDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which colors to delete
     */
    where?: colorWhereInput
  }


  /**
   * color.marca
   */
  export type color$marcaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the marca
     */
    select?: marcaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: marcaInclude<ExtArgs> | null
    where?: marcaWhereInput
  }


  /**
   * color without action
   */
  export type colorDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the color
     */
    select?: colorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: colorInclude<ExtArgs> | null
  }



  /**
   * Model configuracionlaboral
   */

  export type AggregateConfiguracionlaboral = {
    _count: ConfiguracionlaboralCountAggregateOutputType | null
    _avg: ConfiguracionlaboralAvgAggregateOutputType | null
    _sum: ConfiguracionlaboralSumAggregateOutputType | null
    _min: ConfiguracionlaboralMinAggregateOutputType | null
    _max: ConfiguracionlaboralMaxAggregateOutputType | null
  }

  export type ConfiguracionlaboralAvgAggregateOutputType = {
    idconf: number | null
  }

  export type ConfiguracionlaboralSumAggregateOutputType = {
    idconf: number | null
  }

  export type ConfiguracionlaboralMinAggregateOutputType = {
    idconf: number | null
    entrada: Date | null
    salida: Date | null
    tipo: string | null
    retrasopermitido: string | null
    adicional: Date | null
    adicional1: Date | null
  }

  export type ConfiguracionlaboralMaxAggregateOutputType = {
    idconf: number | null
    entrada: Date | null
    salida: Date | null
    tipo: string | null
    retrasopermitido: string | null
    adicional: Date | null
    adicional1: Date | null
  }

  export type ConfiguracionlaboralCountAggregateOutputType = {
    idconf: number
    entrada: number
    salida: number
    tipo: number
    retrasopermitido: number
    adicional: number
    adicional1: number
    _all: number
  }


  export type ConfiguracionlaboralAvgAggregateInputType = {
    idconf?: true
  }

  export type ConfiguracionlaboralSumAggregateInputType = {
    idconf?: true
  }

  export type ConfiguracionlaboralMinAggregateInputType = {
    idconf?: true
    entrada?: true
    salida?: true
    tipo?: true
    retrasopermitido?: true
    adicional?: true
    adicional1?: true
  }

  export type ConfiguracionlaboralMaxAggregateInputType = {
    idconf?: true
    entrada?: true
    salida?: true
    tipo?: true
    retrasopermitido?: true
    adicional?: true
    adicional1?: true
  }

  export type ConfiguracionlaboralCountAggregateInputType = {
    idconf?: true
    entrada?: true
    salida?: true
    tipo?: true
    retrasopermitido?: true
    adicional?: true
    adicional1?: true
    _all?: true
  }

  export type ConfiguracionlaboralAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which configuracionlaboral to aggregate.
     */
    where?: configuracionlaboralWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of configuracionlaborals to fetch.
     */
    orderBy?: configuracionlaboralOrderByWithRelationInput | configuracionlaboralOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: configuracionlaboralWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` configuracionlaborals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` configuracionlaborals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned configuracionlaborals
    **/
    _count?: true | ConfiguracionlaboralCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ConfiguracionlaboralAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ConfiguracionlaboralSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ConfiguracionlaboralMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ConfiguracionlaboralMaxAggregateInputType
  }

  export type GetConfiguracionlaboralAggregateType<T extends ConfiguracionlaboralAggregateArgs> = {
        [P in keyof T & keyof AggregateConfiguracionlaboral]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConfiguracionlaboral[P]>
      : GetScalarType<T[P], AggregateConfiguracionlaboral[P]>
  }




  export type configuracionlaboralGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: configuracionlaboralWhereInput
    orderBy?: configuracionlaboralOrderByWithAggregationInput | configuracionlaboralOrderByWithAggregationInput[]
    by: ConfiguracionlaboralScalarFieldEnum[] | ConfiguracionlaboralScalarFieldEnum
    having?: configuracionlaboralScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ConfiguracionlaboralCountAggregateInputType | true
    _avg?: ConfiguracionlaboralAvgAggregateInputType
    _sum?: ConfiguracionlaboralSumAggregateInputType
    _min?: ConfiguracionlaboralMinAggregateInputType
    _max?: ConfiguracionlaboralMaxAggregateInputType
  }

  export type ConfiguracionlaboralGroupByOutputType = {
    idconf: number
    entrada: Date | null
    salida: Date | null
    tipo: string | null
    retrasopermitido: string | null
    adicional: Date | null
    adicional1: Date | null
    _count: ConfiguracionlaboralCountAggregateOutputType | null
    _avg: ConfiguracionlaboralAvgAggregateOutputType | null
    _sum: ConfiguracionlaboralSumAggregateOutputType | null
    _min: ConfiguracionlaboralMinAggregateOutputType | null
    _max: ConfiguracionlaboralMaxAggregateOutputType | null
  }

  type GetConfiguracionlaboralGroupByPayload<T extends configuracionlaboralGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ConfiguracionlaboralGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ConfiguracionlaboralGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ConfiguracionlaboralGroupByOutputType[P]>
            : GetScalarType<T[P], ConfiguracionlaboralGroupByOutputType[P]>
        }
      >
    >


  export type configuracionlaboralSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idconf?: boolean
    entrada?: boolean
    salida?: boolean
    tipo?: boolean
    retrasopermitido?: boolean
    adicional?: boolean
    adicional1?: boolean
  }, ExtArgs["result"]["configuracionlaboral"]>

  export type configuracionlaboralSelectScalar = {
    idconf?: boolean
    entrada?: boolean
    salida?: boolean
    tipo?: boolean
    retrasopermitido?: boolean
    adicional?: boolean
    adicional1?: boolean
  }


  export type $configuracionlaboralPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "configuracionlaboral"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      idconf: number
      entrada: Date | null
      salida: Date | null
      tipo: string | null
      retrasopermitido: string | null
      adicional: Date | null
      adicional1: Date | null
    }, ExtArgs["result"]["configuracionlaboral"]>
    composites: {}
  }


  type configuracionlaboralGetPayload<S extends boolean | null | undefined | configuracionlaboralDefaultArgs> = $Result.GetResult<Prisma.$configuracionlaboralPayload, S>

  type configuracionlaboralCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<configuracionlaboralFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: ConfiguracionlaboralCountAggregateInputType | true
    }

  export interface configuracionlaboralDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['configuracionlaboral'], meta: { name: 'configuracionlaboral' } }
    /**
     * Find zero or one Configuracionlaboral that matches the filter.
     * @param {configuracionlaboralFindUniqueArgs} args - Arguments to find a Configuracionlaboral
     * @example
     * // Get one Configuracionlaboral
     * const configuracionlaboral = await prisma.configuracionlaboral.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends configuracionlaboralFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, configuracionlaboralFindUniqueArgs<ExtArgs>>
    ): Prisma__configuracionlaboralClient<$Result.GetResult<Prisma.$configuracionlaboralPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Configuracionlaboral that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {configuracionlaboralFindUniqueOrThrowArgs} args - Arguments to find a Configuracionlaboral
     * @example
     * // Get one Configuracionlaboral
     * const configuracionlaboral = await prisma.configuracionlaboral.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends configuracionlaboralFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, configuracionlaboralFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__configuracionlaboralClient<$Result.GetResult<Prisma.$configuracionlaboralPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Configuracionlaboral that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {configuracionlaboralFindFirstArgs} args - Arguments to find a Configuracionlaboral
     * @example
     * // Get one Configuracionlaboral
     * const configuracionlaboral = await prisma.configuracionlaboral.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends configuracionlaboralFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, configuracionlaboralFindFirstArgs<ExtArgs>>
    ): Prisma__configuracionlaboralClient<$Result.GetResult<Prisma.$configuracionlaboralPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Configuracionlaboral that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {configuracionlaboralFindFirstOrThrowArgs} args - Arguments to find a Configuracionlaboral
     * @example
     * // Get one Configuracionlaboral
     * const configuracionlaboral = await prisma.configuracionlaboral.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends configuracionlaboralFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, configuracionlaboralFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__configuracionlaboralClient<$Result.GetResult<Prisma.$configuracionlaboralPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Configuracionlaborals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {configuracionlaboralFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Configuracionlaborals
     * const configuracionlaborals = await prisma.configuracionlaboral.findMany()
     * 
     * // Get first 10 Configuracionlaborals
     * const configuracionlaborals = await prisma.configuracionlaboral.findMany({ take: 10 })
     * 
     * // Only select the `idconf`
     * const configuracionlaboralWithIdconfOnly = await prisma.configuracionlaboral.findMany({ select: { idconf: true } })
     * 
    **/
    findMany<T extends configuracionlaboralFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, configuracionlaboralFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$configuracionlaboralPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Configuracionlaboral.
     * @param {configuracionlaboralCreateArgs} args - Arguments to create a Configuracionlaboral.
     * @example
     * // Create one Configuracionlaboral
     * const Configuracionlaboral = await prisma.configuracionlaboral.create({
     *   data: {
     *     // ... data to create a Configuracionlaboral
     *   }
     * })
     * 
    **/
    create<T extends configuracionlaboralCreateArgs<ExtArgs>>(
      args: SelectSubset<T, configuracionlaboralCreateArgs<ExtArgs>>
    ): Prisma__configuracionlaboralClient<$Result.GetResult<Prisma.$configuracionlaboralPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Configuracionlaborals.
     *     @param {configuracionlaboralCreateManyArgs} args - Arguments to create many Configuracionlaborals.
     *     @example
     *     // Create many Configuracionlaborals
     *     const configuracionlaboral = await prisma.configuracionlaboral.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends configuracionlaboralCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, configuracionlaboralCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Configuracionlaboral.
     * @param {configuracionlaboralDeleteArgs} args - Arguments to delete one Configuracionlaboral.
     * @example
     * // Delete one Configuracionlaboral
     * const Configuracionlaboral = await prisma.configuracionlaboral.delete({
     *   where: {
     *     // ... filter to delete one Configuracionlaboral
     *   }
     * })
     * 
    **/
    delete<T extends configuracionlaboralDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, configuracionlaboralDeleteArgs<ExtArgs>>
    ): Prisma__configuracionlaboralClient<$Result.GetResult<Prisma.$configuracionlaboralPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Configuracionlaboral.
     * @param {configuracionlaboralUpdateArgs} args - Arguments to update one Configuracionlaboral.
     * @example
     * // Update one Configuracionlaboral
     * const configuracionlaboral = await prisma.configuracionlaboral.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends configuracionlaboralUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, configuracionlaboralUpdateArgs<ExtArgs>>
    ): Prisma__configuracionlaboralClient<$Result.GetResult<Prisma.$configuracionlaboralPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Configuracionlaborals.
     * @param {configuracionlaboralDeleteManyArgs} args - Arguments to filter Configuracionlaborals to delete.
     * @example
     * // Delete a few Configuracionlaborals
     * const { count } = await prisma.configuracionlaboral.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends configuracionlaboralDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, configuracionlaboralDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Configuracionlaborals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {configuracionlaboralUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Configuracionlaborals
     * const configuracionlaboral = await prisma.configuracionlaboral.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends configuracionlaboralUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, configuracionlaboralUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Configuracionlaboral.
     * @param {configuracionlaboralUpsertArgs} args - Arguments to update or create a Configuracionlaboral.
     * @example
     * // Update or create a Configuracionlaboral
     * const configuracionlaboral = await prisma.configuracionlaboral.upsert({
     *   create: {
     *     // ... data to create a Configuracionlaboral
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Configuracionlaboral we want to update
     *   }
     * })
    **/
    upsert<T extends configuracionlaboralUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, configuracionlaboralUpsertArgs<ExtArgs>>
    ): Prisma__configuracionlaboralClient<$Result.GetResult<Prisma.$configuracionlaboralPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Configuracionlaborals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {configuracionlaboralCountArgs} args - Arguments to filter Configuracionlaborals to count.
     * @example
     * // Count the number of Configuracionlaborals
     * const count = await prisma.configuracionlaboral.count({
     *   where: {
     *     // ... the filter for the Configuracionlaborals we want to count
     *   }
     * })
    **/
    count<T extends configuracionlaboralCountArgs>(
      args?: Subset<T, configuracionlaboralCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ConfiguracionlaboralCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Configuracionlaboral.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConfiguracionlaboralAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ConfiguracionlaboralAggregateArgs>(args: Subset<T, ConfiguracionlaboralAggregateArgs>): Prisma.PrismaPromise<GetConfiguracionlaboralAggregateType<T>>

    /**
     * Group by Configuracionlaboral.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {configuracionlaboralGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends configuracionlaboralGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: configuracionlaboralGroupByArgs['orderBy'] }
        : { orderBy?: configuracionlaboralGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, configuracionlaboralGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetConfiguracionlaboralGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the configuracionlaboral model
   */
  readonly fields: configuracionlaboralFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for configuracionlaboral.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__configuracionlaboralClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the configuracionlaboral model
   */ 
  interface configuracionlaboralFieldRefs {
    readonly idconf: FieldRef<"configuracionlaboral", 'Int'>
    readonly entrada: FieldRef<"configuracionlaboral", 'DateTime'>
    readonly salida: FieldRef<"configuracionlaboral", 'DateTime'>
    readonly tipo: FieldRef<"configuracionlaboral", 'String'>
    readonly retrasopermitido: FieldRef<"configuracionlaboral", 'String'>
    readonly adicional: FieldRef<"configuracionlaboral", 'DateTime'>
    readonly adicional1: FieldRef<"configuracionlaboral", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * configuracionlaboral findUnique
   */
  export type configuracionlaboralFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the configuracionlaboral
     */
    select?: configuracionlaboralSelect<ExtArgs> | null
    /**
     * Filter, which configuracionlaboral to fetch.
     */
    where: configuracionlaboralWhereUniqueInput
  }


  /**
   * configuracionlaboral findUniqueOrThrow
   */
  export type configuracionlaboralFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the configuracionlaboral
     */
    select?: configuracionlaboralSelect<ExtArgs> | null
    /**
     * Filter, which configuracionlaboral to fetch.
     */
    where: configuracionlaboralWhereUniqueInput
  }


  /**
   * configuracionlaboral findFirst
   */
  export type configuracionlaboralFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the configuracionlaboral
     */
    select?: configuracionlaboralSelect<ExtArgs> | null
    /**
     * Filter, which configuracionlaboral to fetch.
     */
    where?: configuracionlaboralWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of configuracionlaborals to fetch.
     */
    orderBy?: configuracionlaboralOrderByWithRelationInput | configuracionlaboralOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for configuracionlaborals.
     */
    cursor?: configuracionlaboralWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` configuracionlaborals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` configuracionlaborals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of configuracionlaborals.
     */
    distinct?: ConfiguracionlaboralScalarFieldEnum | ConfiguracionlaboralScalarFieldEnum[]
  }


  /**
   * configuracionlaboral findFirstOrThrow
   */
  export type configuracionlaboralFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the configuracionlaboral
     */
    select?: configuracionlaboralSelect<ExtArgs> | null
    /**
     * Filter, which configuracionlaboral to fetch.
     */
    where?: configuracionlaboralWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of configuracionlaborals to fetch.
     */
    orderBy?: configuracionlaboralOrderByWithRelationInput | configuracionlaboralOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for configuracionlaborals.
     */
    cursor?: configuracionlaboralWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` configuracionlaborals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` configuracionlaborals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of configuracionlaborals.
     */
    distinct?: ConfiguracionlaboralScalarFieldEnum | ConfiguracionlaboralScalarFieldEnum[]
  }


  /**
   * configuracionlaboral findMany
   */
  export type configuracionlaboralFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the configuracionlaboral
     */
    select?: configuracionlaboralSelect<ExtArgs> | null
    /**
     * Filter, which configuracionlaborals to fetch.
     */
    where?: configuracionlaboralWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of configuracionlaborals to fetch.
     */
    orderBy?: configuracionlaboralOrderByWithRelationInput | configuracionlaboralOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing configuracionlaborals.
     */
    cursor?: configuracionlaboralWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` configuracionlaborals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` configuracionlaborals.
     */
    skip?: number
    distinct?: ConfiguracionlaboralScalarFieldEnum | ConfiguracionlaboralScalarFieldEnum[]
  }


  /**
   * configuracionlaboral create
   */
  export type configuracionlaboralCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the configuracionlaboral
     */
    select?: configuracionlaboralSelect<ExtArgs> | null
    /**
     * The data needed to create a configuracionlaboral.
     */
    data?: XOR<configuracionlaboralCreateInput, configuracionlaboralUncheckedCreateInput>
  }


  /**
   * configuracionlaboral createMany
   */
  export type configuracionlaboralCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many configuracionlaborals.
     */
    data: configuracionlaboralCreateManyInput | configuracionlaboralCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * configuracionlaboral update
   */
  export type configuracionlaboralUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the configuracionlaboral
     */
    select?: configuracionlaboralSelect<ExtArgs> | null
    /**
     * The data needed to update a configuracionlaboral.
     */
    data: XOR<configuracionlaboralUpdateInput, configuracionlaboralUncheckedUpdateInput>
    /**
     * Choose, which configuracionlaboral to update.
     */
    where: configuracionlaboralWhereUniqueInput
  }


  /**
   * configuracionlaboral updateMany
   */
  export type configuracionlaboralUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update configuracionlaborals.
     */
    data: XOR<configuracionlaboralUpdateManyMutationInput, configuracionlaboralUncheckedUpdateManyInput>
    /**
     * Filter which configuracionlaborals to update
     */
    where?: configuracionlaboralWhereInput
  }


  /**
   * configuracionlaboral upsert
   */
  export type configuracionlaboralUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the configuracionlaboral
     */
    select?: configuracionlaboralSelect<ExtArgs> | null
    /**
     * The filter to search for the configuracionlaboral to update in case it exists.
     */
    where: configuracionlaboralWhereUniqueInput
    /**
     * In case the configuracionlaboral found by the `where` argument doesn't exist, create a new configuracionlaboral with this data.
     */
    create: XOR<configuracionlaboralCreateInput, configuracionlaboralUncheckedCreateInput>
    /**
     * In case the configuracionlaboral was found with the provided `where` argument, update it with this data.
     */
    update: XOR<configuracionlaboralUpdateInput, configuracionlaboralUncheckedUpdateInput>
  }


  /**
   * configuracionlaboral delete
   */
  export type configuracionlaboralDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the configuracionlaboral
     */
    select?: configuracionlaboralSelect<ExtArgs> | null
    /**
     * Filter which configuracionlaboral to delete.
     */
    where: configuracionlaboralWhereUniqueInput
  }


  /**
   * configuracionlaboral deleteMany
   */
  export type configuracionlaboralDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which configuracionlaborals to delete
     */
    where?: configuracionlaboralWhereInput
  }


  /**
   * configuracionlaboral without action
   */
  export type configuracionlaboralDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the configuracionlaboral
     */
    select?: configuracionlaboralSelect<ExtArgs> | null
  }



  /**
   * Model cotizacion
   */

  export type AggregateCotizacion = {
    _count: CotizacionCountAggregateOutputType | null
    _avg: CotizacionAvgAggregateOutputType | null
    _sum: CotizacionSumAggregateOutputType | null
    _min: CotizacionMinAggregateOutputType | null
    _max: CotizacionMaxAggregateOutputType | null
  }

  export type CotizacionAvgAggregateOutputType = {
    idcot: number | null
    idu: number | null
    idcli: number | null
    precio: number | null
    descuento: number | null
    preciofinal: number | null
    tiempo: number | null
  }

  export type CotizacionSumAggregateOutputType = {
    idcot: number | null
    idu: number | null
    idcli: number | null
    precio: number | null
    descuento: number | null
    preciofinal: number | null
    tiempo: number | null
  }

  export type CotizacionMinAggregateOutputType = {
    idcot: number | null
    idu: number | null
    idcli: number | null
    fecha: Date | null
    precio: number | null
    descuento: number | null
    preciofinal: number | null
    tiempo: number | null
    arte: string | null
    obs: string | null
    estado: string | null
  }

  export type CotizacionMaxAggregateOutputType = {
    idcot: number | null
    idu: number | null
    idcli: number | null
    fecha: Date | null
    precio: number | null
    descuento: number | null
    preciofinal: number | null
    tiempo: number | null
    arte: string | null
    obs: string | null
    estado: string | null
  }

  export type CotizacionCountAggregateOutputType = {
    idcot: number
    idu: number
    idcli: number
    fecha: number
    precio: number
    descuento: number
    preciofinal: number
    tiempo: number
    arte: number
    obs: number
    estado: number
    _all: number
  }


  export type CotizacionAvgAggregateInputType = {
    idcot?: true
    idu?: true
    idcli?: true
    precio?: true
    descuento?: true
    preciofinal?: true
    tiempo?: true
  }

  export type CotizacionSumAggregateInputType = {
    idcot?: true
    idu?: true
    idcli?: true
    precio?: true
    descuento?: true
    preciofinal?: true
    tiempo?: true
  }

  export type CotizacionMinAggregateInputType = {
    idcot?: true
    idu?: true
    idcli?: true
    fecha?: true
    precio?: true
    descuento?: true
    preciofinal?: true
    tiempo?: true
    arte?: true
    obs?: true
    estado?: true
  }

  export type CotizacionMaxAggregateInputType = {
    idcot?: true
    idu?: true
    idcli?: true
    fecha?: true
    precio?: true
    descuento?: true
    preciofinal?: true
    tiempo?: true
    arte?: true
    obs?: true
    estado?: true
  }

  export type CotizacionCountAggregateInputType = {
    idcot?: true
    idu?: true
    idcli?: true
    fecha?: true
    precio?: true
    descuento?: true
    preciofinal?: true
    tiempo?: true
    arte?: true
    obs?: true
    estado?: true
    _all?: true
  }

  export type CotizacionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which cotizacion to aggregate.
     */
    where?: cotizacionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cotizacions to fetch.
     */
    orderBy?: cotizacionOrderByWithRelationInput | cotizacionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: cotizacionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` cotizacions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cotizacions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned cotizacions
    **/
    _count?: true | CotizacionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CotizacionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CotizacionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CotizacionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CotizacionMaxAggregateInputType
  }

  export type GetCotizacionAggregateType<T extends CotizacionAggregateArgs> = {
        [P in keyof T & keyof AggregateCotizacion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCotizacion[P]>
      : GetScalarType<T[P], AggregateCotizacion[P]>
  }




  export type cotizacionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: cotizacionWhereInput
    orderBy?: cotizacionOrderByWithAggregationInput | cotizacionOrderByWithAggregationInput[]
    by: CotizacionScalarFieldEnum[] | CotizacionScalarFieldEnum
    having?: cotizacionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CotizacionCountAggregateInputType | true
    _avg?: CotizacionAvgAggregateInputType
    _sum?: CotizacionSumAggregateInputType
    _min?: CotizacionMinAggregateInputType
    _max?: CotizacionMaxAggregateInputType
  }

  export type CotizacionGroupByOutputType = {
    idcot: number
    idu: number | null
    idcli: number | null
    fecha: Date | null
    precio: number | null
    descuento: number | null
    preciofinal: number | null
    tiempo: number | null
    arte: string | null
    obs: string | null
    estado: string | null
    _count: CotizacionCountAggregateOutputType | null
    _avg: CotizacionAvgAggregateOutputType | null
    _sum: CotizacionSumAggregateOutputType | null
    _min: CotizacionMinAggregateOutputType | null
    _max: CotizacionMaxAggregateOutputType | null
  }

  type GetCotizacionGroupByPayload<T extends cotizacionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CotizacionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CotizacionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CotizacionGroupByOutputType[P]>
            : GetScalarType<T[P], CotizacionGroupByOutputType[P]>
        }
      >
    >


  export type cotizacionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idcot?: boolean
    idu?: boolean
    idcli?: boolean
    fecha?: boolean
    precio?: boolean
    descuento?: boolean
    preciofinal?: boolean
    tiempo?: boolean
    arte?: boolean
    obs?: boolean
    estado?: boolean
    cliente?: boolean | cotizacion$clienteArgs<ExtArgs>
    usuario?: boolean | cotizacion$usuarioArgs<ExtArgs>
    detcot?: boolean | cotizacion$detcotArgs<ExtArgs>
    ordent?: boolean | cotizacion$ordentArgs<ExtArgs>
    _count?: boolean | CotizacionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cotizacion"]>

  export type cotizacionSelectScalar = {
    idcot?: boolean
    idu?: boolean
    idcli?: boolean
    fecha?: boolean
    precio?: boolean
    descuento?: boolean
    preciofinal?: boolean
    tiempo?: boolean
    arte?: boolean
    obs?: boolean
    estado?: boolean
  }

  export type cotizacionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cliente?: boolean | cotizacion$clienteArgs<ExtArgs>
    usuario?: boolean | cotizacion$usuarioArgs<ExtArgs>
    detcot?: boolean | cotizacion$detcotArgs<ExtArgs>
    ordent?: boolean | cotizacion$ordentArgs<ExtArgs>
    _count?: boolean | CotizacionCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $cotizacionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "cotizacion"
    objects: {
      cliente: Prisma.$clientePayload<ExtArgs> | null
      usuario: Prisma.$usuarioPayload<ExtArgs> | null
      detcot: Prisma.$detcotPayload<ExtArgs>[]
      ordent: Prisma.$ordentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      idcot: number
      idu: number | null
      idcli: number | null
      fecha: Date | null
      precio: number | null
      descuento: number | null
      preciofinal: number | null
      tiempo: number | null
      arte: string | null
      obs: string | null
      estado: string | null
    }, ExtArgs["result"]["cotizacion"]>
    composites: {}
  }


  type cotizacionGetPayload<S extends boolean | null | undefined | cotizacionDefaultArgs> = $Result.GetResult<Prisma.$cotizacionPayload, S>

  type cotizacionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<cotizacionFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: CotizacionCountAggregateInputType | true
    }

  export interface cotizacionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['cotizacion'], meta: { name: 'cotizacion' } }
    /**
     * Find zero or one Cotizacion that matches the filter.
     * @param {cotizacionFindUniqueArgs} args - Arguments to find a Cotizacion
     * @example
     * // Get one Cotizacion
     * const cotizacion = await prisma.cotizacion.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends cotizacionFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, cotizacionFindUniqueArgs<ExtArgs>>
    ): Prisma__cotizacionClient<$Result.GetResult<Prisma.$cotizacionPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Cotizacion that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {cotizacionFindUniqueOrThrowArgs} args - Arguments to find a Cotizacion
     * @example
     * // Get one Cotizacion
     * const cotizacion = await prisma.cotizacion.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends cotizacionFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, cotizacionFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__cotizacionClient<$Result.GetResult<Prisma.$cotizacionPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Cotizacion that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cotizacionFindFirstArgs} args - Arguments to find a Cotizacion
     * @example
     * // Get one Cotizacion
     * const cotizacion = await prisma.cotizacion.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends cotizacionFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, cotizacionFindFirstArgs<ExtArgs>>
    ): Prisma__cotizacionClient<$Result.GetResult<Prisma.$cotizacionPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Cotizacion that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cotizacionFindFirstOrThrowArgs} args - Arguments to find a Cotizacion
     * @example
     * // Get one Cotizacion
     * const cotizacion = await prisma.cotizacion.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends cotizacionFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, cotizacionFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__cotizacionClient<$Result.GetResult<Prisma.$cotizacionPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Cotizacions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cotizacionFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Cotizacions
     * const cotizacions = await prisma.cotizacion.findMany()
     * 
     * // Get first 10 Cotizacions
     * const cotizacions = await prisma.cotizacion.findMany({ take: 10 })
     * 
     * // Only select the `idcot`
     * const cotizacionWithIdcotOnly = await prisma.cotizacion.findMany({ select: { idcot: true } })
     * 
    **/
    findMany<T extends cotizacionFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, cotizacionFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$cotizacionPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Cotizacion.
     * @param {cotizacionCreateArgs} args - Arguments to create a Cotizacion.
     * @example
     * // Create one Cotizacion
     * const Cotizacion = await prisma.cotizacion.create({
     *   data: {
     *     // ... data to create a Cotizacion
     *   }
     * })
     * 
    **/
    create<T extends cotizacionCreateArgs<ExtArgs>>(
      args: SelectSubset<T, cotizacionCreateArgs<ExtArgs>>
    ): Prisma__cotizacionClient<$Result.GetResult<Prisma.$cotizacionPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Cotizacions.
     *     @param {cotizacionCreateManyArgs} args - Arguments to create many Cotizacions.
     *     @example
     *     // Create many Cotizacions
     *     const cotizacion = await prisma.cotizacion.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends cotizacionCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, cotizacionCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Cotizacion.
     * @param {cotizacionDeleteArgs} args - Arguments to delete one Cotizacion.
     * @example
     * // Delete one Cotizacion
     * const Cotizacion = await prisma.cotizacion.delete({
     *   where: {
     *     // ... filter to delete one Cotizacion
     *   }
     * })
     * 
    **/
    delete<T extends cotizacionDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, cotizacionDeleteArgs<ExtArgs>>
    ): Prisma__cotizacionClient<$Result.GetResult<Prisma.$cotizacionPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Cotizacion.
     * @param {cotizacionUpdateArgs} args - Arguments to update one Cotizacion.
     * @example
     * // Update one Cotizacion
     * const cotizacion = await prisma.cotizacion.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends cotizacionUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, cotizacionUpdateArgs<ExtArgs>>
    ): Prisma__cotizacionClient<$Result.GetResult<Prisma.$cotizacionPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Cotizacions.
     * @param {cotizacionDeleteManyArgs} args - Arguments to filter Cotizacions to delete.
     * @example
     * // Delete a few Cotizacions
     * const { count } = await prisma.cotizacion.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends cotizacionDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, cotizacionDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Cotizacions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cotizacionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Cotizacions
     * const cotizacion = await prisma.cotizacion.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends cotizacionUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, cotizacionUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Cotizacion.
     * @param {cotizacionUpsertArgs} args - Arguments to update or create a Cotizacion.
     * @example
     * // Update or create a Cotizacion
     * const cotizacion = await prisma.cotizacion.upsert({
     *   create: {
     *     // ... data to create a Cotizacion
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Cotizacion we want to update
     *   }
     * })
    **/
    upsert<T extends cotizacionUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, cotizacionUpsertArgs<ExtArgs>>
    ): Prisma__cotizacionClient<$Result.GetResult<Prisma.$cotizacionPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Cotizacions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cotizacionCountArgs} args - Arguments to filter Cotizacions to count.
     * @example
     * // Count the number of Cotizacions
     * const count = await prisma.cotizacion.count({
     *   where: {
     *     // ... the filter for the Cotizacions we want to count
     *   }
     * })
    **/
    count<T extends cotizacionCountArgs>(
      args?: Subset<T, cotizacionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CotizacionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Cotizacion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CotizacionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CotizacionAggregateArgs>(args: Subset<T, CotizacionAggregateArgs>): Prisma.PrismaPromise<GetCotizacionAggregateType<T>>

    /**
     * Group by Cotizacion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cotizacionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends cotizacionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: cotizacionGroupByArgs['orderBy'] }
        : { orderBy?: cotizacionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, cotizacionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCotizacionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the cotizacion model
   */
  readonly fields: cotizacionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for cotizacion.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__cotizacionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    cliente<T extends cotizacion$clienteArgs<ExtArgs> = {}>(args?: Subset<T, cotizacion$clienteArgs<ExtArgs>>): Prisma__clienteClient<$Result.GetResult<Prisma.$clientePayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    usuario<T extends cotizacion$usuarioArgs<ExtArgs> = {}>(args?: Subset<T, cotizacion$usuarioArgs<ExtArgs>>): Prisma__usuarioClient<$Result.GetResult<Prisma.$usuarioPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    detcot<T extends cotizacion$detcotArgs<ExtArgs> = {}>(args?: Subset<T, cotizacion$detcotArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$detcotPayload<ExtArgs>, T, 'findMany'> | Null>;

    ordent<T extends cotizacion$ordentArgs<ExtArgs> = {}>(args?: Subset<T, cotizacion$ordentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ordentPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the cotizacion model
   */ 
  interface cotizacionFieldRefs {
    readonly idcot: FieldRef<"cotizacion", 'Int'>
    readonly idu: FieldRef<"cotizacion", 'Int'>
    readonly idcli: FieldRef<"cotizacion", 'Int'>
    readonly fecha: FieldRef<"cotizacion", 'DateTime'>
    readonly precio: FieldRef<"cotizacion", 'Float'>
    readonly descuento: FieldRef<"cotizacion", 'Float'>
    readonly preciofinal: FieldRef<"cotizacion", 'Float'>
    readonly tiempo: FieldRef<"cotizacion", 'Int'>
    readonly arte: FieldRef<"cotizacion", 'String'>
    readonly obs: FieldRef<"cotizacion", 'String'>
    readonly estado: FieldRef<"cotizacion", 'String'>
  }
    

  // Custom InputTypes

  /**
   * cotizacion findUnique
   */
  export type cotizacionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cotizacion
     */
    select?: cotizacionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: cotizacionInclude<ExtArgs> | null
    /**
     * Filter, which cotizacion to fetch.
     */
    where: cotizacionWhereUniqueInput
  }


  /**
   * cotizacion findUniqueOrThrow
   */
  export type cotizacionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cotizacion
     */
    select?: cotizacionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: cotizacionInclude<ExtArgs> | null
    /**
     * Filter, which cotizacion to fetch.
     */
    where: cotizacionWhereUniqueInput
  }


  /**
   * cotizacion findFirst
   */
  export type cotizacionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cotizacion
     */
    select?: cotizacionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: cotizacionInclude<ExtArgs> | null
    /**
     * Filter, which cotizacion to fetch.
     */
    where?: cotizacionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cotizacions to fetch.
     */
    orderBy?: cotizacionOrderByWithRelationInput | cotizacionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for cotizacions.
     */
    cursor?: cotizacionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` cotizacions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cotizacions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of cotizacions.
     */
    distinct?: CotizacionScalarFieldEnum | CotizacionScalarFieldEnum[]
  }


  /**
   * cotizacion findFirstOrThrow
   */
  export type cotizacionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cotizacion
     */
    select?: cotizacionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: cotizacionInclude<ExtArgs> | null
    /**
     * Filter, which cotizacion to fetch.
     */
    where?: cotizacionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cotizacions to fetch.
     */
    orderBy?: cotizacionOrderByWithRelationInput | cotizacionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for cotizacions.
     */
    cursor?: cotizacionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` cotizacions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cotizacions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of cotizacions.
     */
    distinct?: CotizacionScalarFieldEnum | CotizacionScalarFieldEnum[]
  }


  /**
   * cotizacion findMany
   */
  export type cotizacionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cotizacion
     */
    select?: cotizacionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: cotizacionInclude<ExtArgs> | null
    /**
     * Filter, which cotizacions to fetch.
     */
    where?: cotizacionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cotizacions to fetch.
     */
    orderBy?: cotizacionOrderByWithRelationInput | cotizacionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing cotizacions.
     */
    cursor?: cotizacionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` cotizacions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cotizacions.
     */
    skip?: number
    distinct?: CotizacionScalarFieldEnum | CotizacionScalarFieldEnum[]
  }


  /**
   * cotizacion create
   */
  export type cotizacionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cotizacion
     */
    select?: cotizacionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: cotizacionInclude<ExtArgs> | null
    /**
     * The data needed to create a cotizacion.
     */
    data?: XOR<cotizacionCreateInput, cotizacionUncheckedCreateInput>
  }


  /**
   * cotizacion createMany
   */
  export type cotizacionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many cotizacions.
     */
    data: cotizacionCreateManyInput | cotizacionCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * cotizacion update
   */
  export type cotizacionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cotizacion
     */
    select?: cotizacionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: cotizacionInclude<ExtArgs> | null
    /**
     * The data needed to update a cotizacion.
     */
    data: XOR<cotizacionUpdateInput, cotizacionUncheckedUpdateInput>
    /**
     * Choose, which cotizacion to update.
     */
    where: cotizacionWhereUniqueInput
  }


  /**
   * cotizacion updateMany
   */
  export type cotizacionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update cotizacions.
     */
    data: XOR<cotizacionUpdateManyMutationInput, cotizacionUncheckedUpdateManyInput>
    /**
     * Filter which cotizacions to update
     */
    where?: cotizacionWhereInput
  }


  /**
   * cotizacion upsert
   */
  export type cotizacionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cotizacion
     */
    select?: cotizacionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: cotizacionInclude<ExtArgs> | null
    /**
     * The filter to search for the cotizacion to update in case it exists.
     */
    where: cotizacionWhereUniqueInput
    /**
     * In case the cotizacion found by the `where` argument doesn't exist, create a new cotizacion with this data.
     */
    create: XOR<cotizacionCreateInput, cotizacionUncheckedCreateInput>
    /**
     * In case the cotizacion was found with the provided `where` argument, update it with this data.
     */
    update: XOR<cotizacionUpdateInput, cotizacionUncheckedUpdateInput>
  }


  /**
   * cotizacion delete
   */
  export type cotizacionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cotizacion
     */
    select?: cotizacionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: cotizacionInclude<ExtArgs> | null
    /**
     * Filter which cotizacion to delete.
     */
    where: cotizacionWhereUniqueInput
  }


  /**
   * cotizacion deleteMany
   */
  export type cotizacionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which cotizacions to delete
     */
    where?: cotizacionWhereInput
  }


  /**
   * cotizacion.cliente
   */
  export type cotizacion$clienteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cliente
     */
    select?: clienteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: clienteInclude<ExtArgs> | null
    where?: clienteWhereInput
  }


  /**
   * cotizacion.usuario
   */
  export type cotizacion$usuarioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usuario
     */
    select?: usuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: usuarioInclude<ExtArgs> | null
    where?: usuarioWhereInput
  }


  /**
   * cotizacion.detcot
   */
  export type cotizacion$detcotArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the detcot
     */
    select?: detcotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: detcotInclude<ExtArgs> | null
    where?: detcotWhereInput
    orderBy?: detcotOrderByWithRelationInput | detcotOrderByWithRelationInput[]
    cursor?: detcotWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DetcotScalarFieldEnum | DetcotScalarFieldEnum[]
  }


  /**
   * cotizacion.ordent
   */
  export type cotizacion$ordentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ordent
     */
    select?: ordentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ordentInclude<ExtArgs> | null
    where?: ordentWhereInput
    orderBy?: ordentOrderByWithRelationInput | ordentOrderByWithRelationInput[]
    cursor?: ordentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrdentScalarFieldEnum | OrdentScalarFieldEnum[]
  }


  /**
   * cotizacion without action
   */
  export type cotizacionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cotizacion
     */
    select?: cotizacionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: cotizacionInclude<ExtArgs> | null
  }



  /**
   * Model datos
   */

  export type AggregateDatos = {
    _count: DatosCountAggregateOutputType | null
    _avg: DatosAvgAggregateOutputType | null
    _sum: DatosSumAggregateOutputType | null
    _min: DatosMinAggregateOutputType | null
    _max: DatosMaxAggregateOutputType | null
  }

  export type DatosAvgAggregateOutputType = {
    idu: number | null
  }

  export type DatosSumAggregateOutputType = {
    idu: number | null
  }

  export type DatosMinAggregateOutputType = {
    idu: number | null
    login: string | null
    contrasenia: string | null
  }

  export type DatosMaxAggregateOutputType = {
    idu: number | null
    login: string | null
    contrasenia: string | null
  }

  export type DatosCountAggregateOutputType = {
    idu: number
    login: number
    contrasenia: number
    _all: number
  }


  export type DatosAvgAggregateInputType = {
    idu?: true
  }

  export type DatosSumAggregateInputType = {
    idu?: true
  }

  export type DatosMinAggregateInputType = {
    idu?: true
    login?: true
    contrasenia?: true
  }

  export type DatosMaxAggregateInputType = {
    idu?: true
    login?: true
    contrasenia?: true
  }

  export type DatosCountAggregateInputType = {
    idu?: true
    login?: true
    contrasenia?: true
    _all?: true
  }

  export type DatosAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which datos to aggregate.
     */
    where?: datosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of datos to fetch.
     */
    orderBy?: datosOrderByWithRelationInput | datosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: datosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` datos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` datos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned datos
    **/
    _count?: true | DatosCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DatosAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DatosSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DatosMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DatosMaxAggregateInputType
  }

  export type GetDatosAggregateType<T extends DatosAggregateArgs> = {
        [P in keyof T & keyof AggregateDatos]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDatos[P]>
      : GetScalarType<T[P], AggregateDatos[P]>
  }




  export type datosGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: datosWhereInput
    orderBy?: datosOrderByWithAggregationInput | datosOrderByWithAggregationInput[]
    by: DatosScalarFieldEnum[] | DatosScalarFieldEnum
    having?: datosScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DatosCountAggregateInputType | true
    _avg?: DatosAvgAggregateInputType
    _sum?: DatosSumAggregateInputType
    _min?: DatosMinAggregateInputType
    _max?: DatosMaxAggregateInputType
  }

  export type DatosGroupByOutputType = {
    idu: number
    login: string
    contrasenia: string
    _count: DatosCountAggregateOutputType | null
    _avg: DatosAvgAggregateOutputType | null
    _sum: DatosSumAggregateOutputType | null
    _min: DatosMinAggregateOutputType | null
    _max: DatosMaxAggregateOutputType | null
  }

  type GetDatosGroupByPayload<T extends datosGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DatosGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DatosGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DatosGroupByOutputType[P]>
            : GetScalarType<T[P], DatosGroupByOutputType[P]>
        }
      >
    >


  export type datosSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idu?: boolean
    login?: boolean
    contrasenia?: boolean
    usuario?: boolean | usuarioDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["datos"]>

  export type datosSelectScalar = {
    idu?: boolean
    login?: boolean
    contrasenia?: boolean
  }

  export type datosInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    usuario?: boolean | usuarioDefaultArgs<ExtArgs>
  }


  export type $datosPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "datos"
    objects: {
      usuario: Prisma.$usuarioPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      idu: number
      login: string
      contrasenia: string
    }, ExtArgs["result"]["datos"]>
    composites: {}
  }


  type datosGetPayload<S extends boolean | null | undefined | datosDefaultArgs> = $Result.GetResult<Prisma.$datosPayload, S>

  type datosCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<datosFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: DatosCountAggregateInputType | true
    }

  export interface datosDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['datos'], meta: { name: 'datos' } }
    /**
     * Find zero or one Datos that matches the filter.
     * @param {datosFindUniqueArgs} args - Arguments to find a Datos
     * @example
     * // Get one Datos
     * const datos = await prisma.datos.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends datosFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, datosFindUniqueArgs<ExtArgs>>
    ): Prisma__datosClient<$Result.GetResult<Prisma.$datosPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Datos that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {datosFindUniqueOrThrowArgs} args - Arguments to find a Datos
     * @example
     * // Get one Datos
     * const datos = await prisma.datos.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends datosFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, datosFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__datosClient<$Result.GetResult<Prisma.$datosPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Datos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {datosFindFirstArgs} args - Arguments to find a Datos
     * @example
     * // Get one Datos
     * const datos = await prisma.datos.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends datosFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, datosFindFirstArgs<ExtArgs>>
    ): Prisma__datosClient<$Result.GetResult<Prisma.$datosPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Datos that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {datosFindFirstOrThrowArgs} args - Arguments to find a Datos
     * @example
     * // Get one Datos
     * const datos = await prisma.datos.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends datosFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, datosFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__datosClient<$Result.GetResult<Prisma.$datosPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Datos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {datosFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Datos
     * const datos = await prisma.datos.findMany()
     * 
     * // Get first 10 Datos
     * const datos = await prisma.datos.findMany({ take: 10 })
     * 
     * // Only select the `idu`
     * const datosWithIduOnly = await prisma.datos.findMany({ select: { idu: true } })
     * 
    **/
    findMany<T extends datosFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, datosFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$datosPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Datos.
     * @param {datosCreateArgs} args - Arguments to create a Datos.
     * @example
     * // Create one Datos
     * const Datos = await prisma.datos.create({
     *   data: {
     *     // ... data to create a Datos
     *   }
     * })
     * 
    **/
    create<T extends datosCreateArgs<ExtArgs>>(
      args: SelectSubset<T, datosCreateArgs<ExtArgs>>
    ): Prisma__datosClient<$Result.GetResult<Prisma.$datosPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Datos.
     *     @param {datosCreateManyArgs} args - Arguments to create many Datos.
     *     @example
     *     // Create many Datos
     *     const datos = await prisma.datos.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends datosCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, datosCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Datos.
     * @param {datosDeleteArgs} args - Arguments to delete one Datos.
     * @example
     * // Delete one Datos
     * const Datos = await prisma.datos.delete({
     *   where: {
     *     // ... filter to delete one Datos
     *   }
     * })
     * 
    **/
    delete<T extends datosDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, datosDeleteArgs<ExtArgs>>
    ): Prisma__datosClient<$Result.GetResult<Prisma.$datosPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Datos.
     * @param {datosUpdateArgs} args - Arguments to update one Datos.
     * @example
     * // Update one Datos
     * const datos = await prisma.datos.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends datosUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, datosUpdateArgs<ExtArgs>>
    ): Prisma__datosClient<$Result.GetResult<Prisma.$datosPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Datos.
     * @param {datosDeleteManyArgs} args - Arguments to filter Datos to delete.
     * @example
     * // Delete a few Datos
     * const { count } = await prisma.datos.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends datosDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, datosDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Datos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {datosUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Datos
     * const datos = await prisma.datos.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends datosUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, datosUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Datos.
     * @param {datosUpsertArgs} args - Arguments to update or create a Datos.
     * @example
     * // Update or create a Datos
     * const datos = await prisma.datos.upsert({
     *   create: {
     *     // ... data to create a Datos
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Datos we want to update
     *   }
     * })
    **/
    upsert<T extends datosUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, datosUpsertArgs<ExtArgs>>
    ): Prisma__datosClient<$Result.GetResult<Prisma.$datosPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Datos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {datosCountArgs} args - Arguments to filter Datos to count.
     * @example
     * // Count the number of Datos
     * const count = await prisma.datos.count({
     *   where: {
     *     // ... the filter for the Datos we want to count
     *   }
     * })
    **/
    count<T extends datosCountArgs>(
      args?: Subset<T, datosCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DatosCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Datos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DatosAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DatosAggregateArgs>(args: Subset<T, DatosAggregateArgs>): Prisma.PrismaPromise<GetDatosAggregateType<T>>

    /**
     * Group by Datos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {datosGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends datosGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: datosGroupByArgs['orderBy'] }
        : { orderBy?: datosGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, datosGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDatosGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the datos model
   */
  readonly fields: datosFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for datos.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__datosClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    usuario<T extends usuarioDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usuarioDefaultArgs<ExtArgs>>): Prisma__usuarioClient<$Result.GetResult<Prisma.$usuarioPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the datos model
   */ 
  interface datosFieldRefs {
    readonly idu: FieldRef<"datos", 'Int'>
    readonly login: FieldRef<"datos", 'String'>
    readonly contrasenia: FieldRef<"datos", 'String'>
  }
    

  // Custom InputTypes

  /**
   * datos findUnique
   */
  export type datosFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the datos
     */
    select?: datosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: datosInclude<ExtArgs> | null
    /**
     * Filter, which datos to fetch.
     */
    where: datosWhereUniqueInput
  }


  /**
   * datos findUniqueOrThrow
   */
  export type datosFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the datos
     */
    select?: datosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: datosInclude<ExtArgs> | null
    /**
     * Filter, which datos to fetch.
     */
    where: datosWhereUniqueInput
  }


  /**
   * datos findFirst
   */
  export type datosFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the datos
     */
    select?: datosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: datosInclude<ExtArgs> | null
    /**
     * Filter, which datos to fetch.
     */
    where?: datosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of datos to fetch.
     */
    orderBy?: datosOrderByWithRelationInput | datosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for datos.
     */
    cursor?: datosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` datos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` datos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of datos.
     */
    distinct?: DatosScalarFieldEnum | DatosScalarFieldEnum[]
  }


  /**
   * datos findFirstOrThrow
   */
  export type datosFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the datos
     */
    select?: datosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: datosInclude<ExtArgs> | null
    /**
     * Filter, which datos to fetch.
     */
    where?: datosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of datos to fetch.
     */
    orderBy?: datosOrderByWithRelationInput | datosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for datos.
     */
    cursor?: datosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` datos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` datos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of datos.
     */
    distinct?: DatosScalarFieldEnum | DatosScalarFieldEnum[]
  }


  /**
   * datos findMany
   */
  export type datosFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the datos
     */
    select?: datosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: datosInclude<ExtArgs> | null
    /**
     * Filter, which datos to fetch.
     */
    where?: datosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of datos to fetch.
     */
    orderBy?: datosOrderByWithRelationInput | datosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing datos.
     */
    cursor?: datosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` datos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` datos.
     */
    skip?: number
    distinct?: DatosScalarFieldEnum | DatosScalarFieldEnum[]
  }


  /**
   * datos create
   */
  export type datosCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the datos
     */
    select?: datosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: datosInclude<ExtArgs> | null
    /**
     * The data needed to create a datos.
     */
    data: XOR<datosCreateInput, datosUncheckedCreateInput>
  }


  /**
   * datos createMany
   */
  export type datosCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many datos.
     */
    data: datosCreateManyInput | datosCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * datos update
   */
  export type datosUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the datos
     */
    select?: datosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: datosInclude<ExtArgs> | null
    /**
     * The data needed to update a datos.
     */
    data: XOR<datosUpdateInput, datosUncheckedUpdateInput>
    /**
     * Choose, which datos to update.
     */
    where: datosWhereUniqueInput
  }


  /**
   * datos updateMany
   */
  export type datosUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update datos.
     */
    data: XOR<datosUpdateManyMutationInput, datosUncheckedUpdateManyInput>
    /**
     * Filter which datos to update
     */
    where?: datosWhereInput
  }


  /**
   * datos upsert
   */
  export type datosUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the datos
     */
    select?: datosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: datosInclude<ExtArgs> | null
    /**
     * The filter to search for the datos to update in case it exists.
     */
    where: datosWhereUniqueInput
    /**
     * In case the datos found by the `where` argument doesn't exist, create a new datos with this data.
     */
    create: XOR<datosCreateInput, datosUncheckedCreateInput>
    /**
     * In case the datos was found with the provided `where` argument, update it with this data.
     */
    update: XOR<datosUpdateInput, datosUncheckedUpdateInput>
  }


  /**
   * datos delete
   */
  export type datosDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the datos
     */
    select?: datosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: datosInclude<ExtArgs> | null
    /**
     * Filter which datos to delete.
     */
    where: datosWhereUniqueInput
  }


  /**
   * datos deleteMany
   */
  export type datosDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which datos to delete
     */
    where?: datosWhereInput
  }


  /**
   * datos without action
   */
  export type datosDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the datos
     */
    select?: datosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: datosInclude<ExtArgs> | null
  }



  /**
   * Model detcot
   */

  export type AggregateDetcot = {
    _count: DetcotCountAggregateOutputType | null
    _avg: DetcotAvgAggregateOutputType | null
    _sum: DetcotSumAggregateOutputType | null
    _min: DetcotMinAggregateOutputType | null
    _max: DetcotMaxAggregateOutputType | null
  }

  export type DetcotAvgAggregateOutputType = {
    iddetcot: number | null
    idcot: number | null
    idpro: number | null
    cant: number | null
    punit: number | null
    stotal: number | null
  }

  export type DetcotSumAggregateOutputType = {
    iddetcot: number | null
    idcot: number | null
    idpro: number | null
    cant: number | null
    punit: number | null
    stotal: number | null
  }

  export type DetcotMinAggregateOutputType = {
    iddetcot: number | null
    idcot: number | null
    idpro: number | null
    cant: number | null
    punit: number | null
    stotal: number | null
    material: string | null
    gr: string | null
    tintas: string | null
    estado: boolean | null
  }

  export type DetcotMaxAggregateOutputType = {
    iddetcot: number | null
    idcot: number | null
    idpro: number | null
    cant: number | null
    punit: number | null
    stotal: number | null
    material: string | null
    gr: string | null
    tintas: string | null
    estado: boolean | null
  }

  export type DetcotCountAggregateOutputType = {
    iddetcot: number
    idcot: number
    idpro: number
    cant: number
    punit: number
    stotal: number
    material: number
    gr: number
    tintas: number
    estado: number
    _all: number
  }


  export type DetcotAvgAggregateInputType = {
    iddetcot?: true
    idcot?: true
    idpro?: true
    cant?: true
    punit?: true
    stotal?: true
  }

  export type DetcotSumAggregateInputType = {
    iddetcot?: true
    idcot?: true
    idpro?: true
    cant?: true
    punit?: true
    stotal?: true
  }

  export type DetcotMinAggregateInputType = {
    iddetcot?: true
    idcot?: true
    idpro?: true
    cant?: true
    punit?: true
    stotal?: true
    material?: true
    gr?: true
    tintas?: true
    estado?: true
  }

  export type DetcotMaxAggregateInputType = {
    iddetcot?: true
    idcot?: true
    idpro?: true
    cant?: true
    punit?: true
    stotal?: true
    material?: true
    gr?: true
    tintas?: true
    estado?: true
  }

  export type DetcotCountAggregateInputType = {
    iddetcot?: true
    idcot?: true
    idpro?: true
    cant?: true
    punit?: true
    stotal?: true
    material?: true
    gr?: true
    tintas?: true
    estado?: true
    _all?: true
  }

  export type DetcotAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which detcot to aggregate.
     */
    where?: detcotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of detcots to fetch.
     */
    orderBy?: detcotOrderByWithRelationInput | detcotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: detcotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` detcots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` detcots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned detcots
    **/
    _count?: true | DetcotCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DetcotAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DetcotSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DetcotMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DetcotMaxAggregateInputType
  }

  export type GetDetcotAggregateType<T extends DetcotAggregateArgs> = {
        [P in keyof T & keyof AggregateDetcot]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDetcot[P]>
      : GetScalarType<T[P], AggregateDetcot[P]>
  }




  export type detcotGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: detcotWhereInput
    orderBy?: detcotOrderByWithAggregationInput | detcotOrderByWithAggregationInput[]
    by: DetcotScalarFieldEnum[] | DetcotScalarFieldEnum
    having?: detcotScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DetcotCountAggregateInputType | true
    _avg?: DetcotAvgAggregateInputType
    _sum?: DetcotSumAggregateInputType
    _min?: DetcotMinAggregateInputType
    _max?: DetcotMaxAggregateInputType
  }

  export type DetcotGroupByOutputType = {
    iddetcot: number
    idcot: number | null
    idpro: number | null
    cant: number | null
    punit: number | null
    stotal: number | null
    material: string | null
    gr: string | null
    tintas: string | null
    estado: boolean | null
    _count: DetcotCountAggregateOutputType | null
    _avg: DetcotAvgAggregateOutputType | null
    _sum: DetcotSumAggregateOutputType | null
    _min: DetcotMinAggregateOutputType | null
    _max: DetcotMaxAggregateOutputType | null
  }

  type GetDetcotGroupByPayload<T extends detcotGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DetcotGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DetcotGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DetcotGroupByOutputType[P]>
            : GetScalarType<T[P], DetcotGroupByOutputType[P]>
        }
      >
    >


  export type detcotSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    iddetcot?: boolean
    idcot?: boolean
    idpro?: boolean
    cant?: boolean
    punit?: boolean
    stotal?: boolean
    material?: boolean
    gr?: boolean
    tintas?: boolean
    estado?: boolean
    cotizacion?: boolean | detcot$cotizacionArgs<ExtArgs>
    producto?: boolean | detcot$productoArgs<ExtArgs>
  }, ExtArgs["result"]["detcot"]>

  export type detcotSelectScalar = {
    iddetcot?: boolean
    idcot?: boolean
    idpro?: boolean
    cant?: boolean
    punit?: boolean
    stotal?: boolean
    material?: boolean
    gr?: boolean
    tintas?: boolean
    estado?: boolean
  }

  export type detcotInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cotizacion?: boolean | detcot$cotizacionArgs<ExtArgs>
    producto?: boolean | detcot$productoArgs<ExtArgs>
  }


  export type $detcotPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "detcot"
    objects: {
      cotizacion: Prisma.$cotizacionPayload<ExtArgs> | null
      producto: Prisma.$productoPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      iddetcot: number
      idcot: number | null
      idpro: number | null
      cant: number | null
      punit: number | null
      stotal: number | null
      material: string | null
      gr: string | null
      tintas: string | null
      estado: boolean | null
    }, ExtArgs["result"]["detcot"]>
    composites: {}
  }


  type detcotGetPayload<S extends boolean | null | undefined | detcotDefaultArgs> = $Result.GetResult<Prisma.$detcotPayload, S>

  type detcotCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<detcotFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: DetcotCountAggregateInputType | true
    }

  export interface detcotDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['detcot'], meta: { name: 'detcot' } }
    /**
     * Find zero or one Detcot that matches the filter.
     * @param {detcotFindUniqueArgs} args - Arguments to find a Detcot
     * @example
     * // Get one Detcot
     * const detcot = await prisma.detcot.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends detcotFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, detcotFindUniqueArgs<ExtArgs>>
    ): Prisma__detcotClient<$Result.GetResult<Prisma.$detcotPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Detcot that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {detcotFindUniqueOrThrowArgs} args - Arguments to find a Detcot
     * @example
     * // Get one Detcot
     * const detcot = await prisma.detcot.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends detcotFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, detcotFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__detcotClient<$Result.GetResult<Prisma.$detcotPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Detcot that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {detcotFindFirstArgs} args - Arguments to find a Detcot
     * @example
     * // Get one Detcot
     * const detcot = await prisma.detcot.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends detcotFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, detcotFindFirstArgs<ExtArgs>>
    ): Prisma__detcotClient<$Result.GetResult<Prisma.$detcotPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Detcot that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {detcotFindFirstOrThrowArgs} args - Arguments to find a Detcot
     * @example
     * // Get one Detcot
     * const detcot = await prisma.detcot.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends detcotFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, detcotFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__detcotClient<$Result.GetResult<Prisma.$detcotPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Detcots that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {detcotFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Detcots
     * const detcots = await prisma.detcot.findMany()
     * 
     * // Get first 10 Detcots
     * const detcots = await prisma.detcot.findMany({ take: 10 })
     * 
     * // Only select the `iddetcot`
     * const detcotWithIddetcotOnly = await prisma.detcot.findMany({ select: { iddetcot: true } })
     * 
    **/
    findMany<T extends detcotFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, detcotFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$detcotPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Detcot.
     * @param {detcotCreateArgs} args - Arguments to create a Detcot.
     * @example
     * // Create one Detcot
     * const Detcot = await prisma.detcot.create({
     *   data: {
     *     // ... data to create a Detcot
     *   }
     * })
     * 
    **/
    create<T extends detcotCreateArgs<ExtArgs>>(
      args: SelectSubset<T, detcotCreateArgs<ExtArgs>>
    ): Prisma__detcotClient<$Result.GetResult<Prisma.$detcotPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Detcots.
     *     @param {detcotCreateManyArgs} args - Arguments to create many Detcots.
     *     @example
     *     // Create many Detcots
     *     const detcot = await prisma.detcot.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends detcotCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, detcotCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Detcot.
     * @param {detcotDeleteArgs} args - Arguments to delete one Detcot.
     * @example
     * // Delete one Detcot
     * const Detcot = await prisma.detcot.delete({
     *   where: {
     *     // ... filter to delete one Detcot
     *   }
     * })
     * 
    **/
    delete<T extends detcotDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, detcotDeleteArgs<ExtArgs>>
    ): Prisma__detcotClient<$Result.GetResult<Prisma.$detcotPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Detcot.
     * @param {detcotUpdateArgs} args - Arguments to update one Detcot.
     * @example
     * // Update one Detcot
     * const detcot = await prisma.detcot.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends detcotUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, detcotUpdateArgs<ExtArgs>>
    ): Prisma__detcotClient<$Result.GetResult<Prisma.$detcotPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Detcots.
     * @param {detcotDeleteManyArgs} args - Arguments to filter Detcots to delete.
     * @example
     * // Delete a few Detcots
     * const { count } = await prisma.detcot.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends detcotDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, detcotDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Detcots.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {detcotUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Detcots
     * const detcot = await prisma.detcot.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends detcotUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, detcotUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Detcot.
     * @param {detcotUpsertArgs} args - Arguments to update or create a Detcot.
     * @example
     * // Update or create a Detcot
     * const detcot = await prisma.detcot.upsert({
     *   create: {
     *     // ... data to create a Detcot
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Detcot we want to update
     *   }
     * })
    **/
    upsert<T extends detcotUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, detcotUpsertArgs<ExtArgs>>
    ): Prisma__detcotClient<$Result.GetResult<Prisma.$detcotPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Detcots.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {detcotCountArgs} args - Arguments to filter Detcots to count.
     * @example
     * // Count the number of Detcots
     * const count = await prisma.detcot.count({
     *   where: {
     *     // ... the filter for the Detcots we want to count
     *   }
     * })
    **/
    count<T extends detcotCountArgs>(
      args?: Subset<T, detcotCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DetcotCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Detcot.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DetcotAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DetcotAggregateArgs>(args: Subset<T, DetcotAggregateArgs>): Prisma.PrismaPromise<GetDetcotAggregateType<T>>

    /**
     * Group by Detcot.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {detcotGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends detcotGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: detcotGroupByArgs['orderBy'] }
        : { orderBy?: detcotGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, detcotGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDetcotGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the detcot model
   */
  readonly fields: detcotFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for detcot.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__detcotClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    cotizacion<T extends detcot$cotizacionArgs<ExtArgs> = {}>(args?: Subset<T, detcot$cotizacionArgs<ExtArgs>>): Prisma__cotizacionClient<$Result.GetResult<Prisma.$cotizacionPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    producto<T extends detcot$productoArgs<ExtArgs> = {}>(args?: Subset<T, detcot$productoArgs<ExtArgs>>): Prisma__productoClient<$Result.GetResult<Prisma.$productoPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the detcot model
   */ 
  interface detcotFieldRefs {
    readonly iddetcot: FieldRef<"detcot", 'Int'>
    readonly idcot: FieldRef<"detcot", 'Int'>
    readonly idpro: FieldRef<"detcot", 'Int'>
    readonly cant: FieldRef<"detcot", 'Int'>
    readonly punit: FieldRef<"detcot", 'Float'>
    readonly stotal: FieldRef<"detcot", 'Float'>
    readonly material: FieldRef<"detcot", 'String'>
    readonly gr: FieldRef<"detcot", 'String'>
    readonly tintas: FieldRef<"detcot", 'String'>
    readonly estado: FieldRef<"detcot", 'Boolean'>
  }
    

  // Custom InputTypes

  /**
   * detcot findUnique
   */
  export type detcotFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the detcot
     */
    select?: detcotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: detcotInclude<ExtArgs> | null
    /**
     * Filter, which detcot to fetch.
     */
    where: detcotWhereUniqueInput
  }


  /**
   * detcot findUniqueOrThrow
   */
  export type detcotFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the detcot
     */
    select?: detcotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: detcotInclude<ExtArgs> | null
    /**
     * Filter, which detcot to fetch.
     */
    where: detcotWhereUniqueInput
  }


  /**
   * detcot findFirst
   */
  export type detcotFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the detcot
     */
    select?: detcotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: detcotInclude<ExtArgs> | null
    /**
     * Filter, which detcot to fetch.
     */
    where?: detcotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of detcots to fetch.
     */
    orderBy?: detcotOrderByWithRelationInput | detcotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for detcots.
     */
    cursor?: detcotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` detcots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` detcots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of detcots.
     */
    distinct?: DetcotScalarFieldEnum | DetcotScalarFieldEnum[]
  }


  /**
   * detcot findFirstOrThrow
   */
  export type detcotFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the detcot
     */
    select?: detcotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: detcotInclude<ExtArgs> | null
    /**
     * Filter, which detcot to fetch.
     */
    where?: detcotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of detcots to fetch.
     */
    orderBy?: detcotOrderByWithRelationInput | detcotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for detcots.
     */
    cursor?: detcotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` detcots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` detcots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of detcots.
     */
    distinct?: DetcotScalarFieldEnum | DetcotScalarFieldEnum[]
  }


  /**
   * detcot findMany
   */
  export type detcotFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the detcot
     */
    select?: detcotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: detcotInclude<ExtArgs> | null
    /**
     * Filter, which detcots to fetch.
     */
    where?: detcotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of detcots to fetch.
     */
    orderBy?: detcotOrderByWithRelationInput | detcotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing detcots.
     */
    cursor?: detcotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` detcots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` detcots.
     */
    skip?: number
    distinct?: DetcotScalarFieldEnum | DetcotScalarFieldEnum[]
  }


  /**
   * detcot create
   */
  export type detcotCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the detcot
     */
    select?: detcotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: detcotInclude<ExtArgs> | null
    /**
     * The data needed to create a detcot.
     */
    data?: XOR<detcotCreateInput, detcotUncheckedCreateInput>
  }


  /**
   * detcot createMany
   */
  export type detcotCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many detcots.
     */
    data: detcotCreateManyInput | detcotCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * detcot update
   */
  export type detcotUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the detcot
     */
    select?: detcotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: detcotInclude<ExtArgs> | null
    /**
     * The data needed to update a detcot.
     */
    data: XOR<detcotUpdateInput, detcotUncheckedUpdateInput>
    /**
     * Choose, which detcot to update.
     */
    where: detcotWhereUniqueInput
  }


  /**
   * detcot updateMany
   */
  export type detcotUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update detcots.
     */
    data: XOR<detcotUpdateManyMutationInput, detcotUncheckedUpdateManyInput>
    /**
     * Filter which detcots to update
     */
    where?: detcotWhereInput
  }


  /**
   * detcot upsert
   */
  export type detcotUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the detcot
     */
    select?: detcotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: detcotInclude<ExtArgs> | null
    /**
     * The filter to search for the detcot to update in case it exists.
     */
    where: detcotWhereUniqueInput
    /**
     * In case the detcot found by the `where` argument doesn't exist, create a new detcot with this data.
     */
    create: XOR<detcotCreateInput, detcotUncheckedCreateInput>
    /**
     * In case the detcot was found with the provided `where` argument, update it with this data.
     */
    update: XOR<detcotUpdateInput, detcotUncheckedUpdateInput>
  }


  /**
   * detcot delete
   */
  export type detcotDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the detcot
     */
    select?: detcotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: detcotInclude<ExtArgs> | null
    /**
     * Filter which detcot to delete.
     */
    where: detcotWhereUniqueInput
  }


  /**
   * detcot deleteMany
   */
  export type detcotDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which detcots to delete
     */
    where?: detcotWhereInput
  }


  /**
   * detcot.cotizacion
   */
  export type detcot$cotizacionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cotizacion
     */
    select?: cotizacionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: cotizacionInclude<ExtArgs> | null
    where?: cotizacionWhereInput
  }


  /**
   * detcot.producto
   */
  export type detcot$productoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the producto
     */
    select?: productoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: productoInclude<ExtArgs> | null
    where?: productoWhereInput
  }


  /**
   * detcot without action
   */
  export type detcotDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the detcot
     */
    select?: detcotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: detcotInclude<ExtArgs> | null
  }



  /**
   * Model detot
   */

  export type AggregateDetot = {
    _count: DetotCountAggregateOutputType | null
    _avg: DetotAvgAggregateOutputType | null
    _sum: DetotSumAggregateOutputType | null
    _min: DetotMinAggregateOutputType | null
    _max: DetotMaxAggregateOutputType | null
  }

  export type DetotAvgAggregateOutputType = {
    iddetot: number | null
    idot: number | null
    idpro: number | null
    cant: number | null
    punit: number | null
    stotal: number | null
  }

  export type DetotSumAggregateOutputType = {
    iddetot: number | null
    idot: number | null
    idpro: number | null
    cant: number | null
    punit: number | null
    stotal: number | null
  }

  export type DetotMinAggregateOutputType = {
    iddetot: number | null
    idot: number | null
    idpro: number | null
    cant: number | null
    punit: number | null
    stotal: number | null
    material: string | null
    gr: string | null
    tintas: string | null
    estado: boolean | null
  }

  export type DetotMaxAggregateOutputType = {
    iddetot: number | null
    idot: number | null
    idpro: number | null
    cant: number | null
    punit: number | null
    stotal: number | null
    material: string | null
    gr: string | null
    tintas: string | null
    estado: boolean | null
  }

  export type DetotCountAggregateOutputType = {
    iddetot: number
    idot: number
    idpro: number
    cant: number
    punit: number
    stotal: number
    material: number
    gr: number
    tintas: number
    estado: number
    _all: number
  }


  export type DetotAvgAggregateInputType = {
    iddetot?: true
    idot?: true
    idpro?: true
    cant?: true
    punit?: true
    stotal?: true
  }

  export type DetotSumAggregateInputType = {
    iddetot?: true
    idot?: true
    idpro?: true
    cant?: true
    punit?: true
    stotal?: true
  }

  export type DetotMinAggregateInputType = {
    iddetot?: true
    idot?: true
    idpro?: true
    cant?: true
    punit?: true
    stotal?: true
    material?: true
    gr?: true
    tintas?: true
    estado?: true
  }

  export type DetotMaxAggregateInputType = {
    iddetot?: true
    idot?: true
    idpro?: true
    cant?: true
    punit?: true
    stotal?: true
    material?: true
    gr?: true
    tintas?: true
    estado?: true
  }

  export type DetotCountAggregateInputType = {
    iddetot?: true
    idot?: true
    idpro?: true
    cant?: true
    punit?: true
    stotal?: true
    material?: true
    gr?: true
    tintas?: true
    estado?: true
    _all?: true
  }

  export type DetotAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which detot to aggregate.
     */
    where?: detotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of detots to fetch.
     */
    orderBy?: detotOrderByWithRelationInput | detotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: detotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` detots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` detots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned detots
    **/
    _count?: true | DetotCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DetotAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DetotSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DetotMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DetotMaxAggregateInputType
  }

  export type GetDetotAggregateType<T extends DetotAggregateArgs> = {
        [P in keyof T & keyof AggregateDetot]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDetot[P]>
      : GetScalarType<T[P], AggregateDetot[P]>
  }




  export type detotGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: detotWhereInput
    orderBy?: detotOrderByWithAggregationInput | detotOrderByWithAggregationInput[]
    by: DetotScalarFieldEnum[] | DetotScalarFieldEnum
    having?: detotScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DetotCountAggregateInputType | true
    _avg?: DetotAvgAggregateInputType
    _sum?: DetotSumAggregateInputType
    _min?: DetotMinAggregateInputType
    _max?: DetotMaxAggregateInputType
  }

  export type DetotGroupByOutputType = {
    iddetot: number
    idot: number | null
    idpro: number | null
    cant: number | null
    punit: number | null
    stotal: number | null
    material: string | null
    gr: string | null
    tintas: string | null
    estado: boolean | null
    _count: DetotCountAggregateOutputType | null
    _avg: DetotAvgAggregateOutputType | null
    _sum: DetotSumAggregateOutputType | null
    _min: DetotMinAggregateOutputType | null
    _max: DetotMaxAggregateOutputType | null
  }

  type GetDetotGroupByPayload<T extends detotGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DetotGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DetotGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DetotGroupByOutputType[P]>
            : GetScalarType<T[P], DetotGroupByOutputType[P]>
        }
      >
    >


  export type detotSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    iddetot?: boolean
    idot?: boolean
    idpro?: boolean
    cant?: boolean
    punit?: boolean
    stotal?: boolean
    material?: boolean
    gr?: boolean
    tintas?: boolean
    estado?: boolean
    ordent?: boolean | detot$ordentArgs<ExtArgs>
    producto?: boolean | detot$productoArgs<ExtArgs>
  }, ExtArgs["result"]["detot"]>

  export type detotSelectScalar = {
    iddetot?: boolean
    idot?: boolean
    idpro?: boolean
    cant?: boolean
    punit?: boolean
    stotal?: boolean
    material?: boolean
    gr?: boolean
    tintas?: boolean
    estado?: boolean
  }

  export type detotInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ordent?: boolean | detot$ordentArgs<ExtArgs>
    producto?: boolean | detot$productoArgs<ExtArgs>
  }


  export type $detotPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "detot"
    objects: {
      ordent: Prisma.$ordentPayload<ExtArgs> | null
      producto: Prisma.$productoPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      iddetot: number
      idot: number | null
      idpro: number | null
      cant: number | null
      punit: number | null
      stotal: number | null
      material: string | null
      gr: string | null
      tintas: string | null
      estado: boolean | null
    }, ExtArgs["result"]["detot"]>
    composites: {}
  }


  type detotGetPayload<S extends boolean | null | undefined | detotDefaultArgs> = $Result.GetResult<Prisma.$detotPayload, S>

  type detotCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<detotFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: DetotCountAggregateInputType | true
    }

  export interface detotDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['detot'], meta: { name: 'detot' } }
    /**
     * Find zero or one Detot that matches the filter.
     * @param {detotFindUniqueArgs} args - Arguments to find a Detot
     * @example
     * // Get one Detot
     * const detot = await prisma.detot.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends detotFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, detotFindUniqueArgs<ExtArgs>>
    ): Prisma__detotClient<$Result.GetResult<Prisma.$detotPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Detot that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {detotFindUniqueOrThrowArgs} args - Arguments to find a Detot
     * @example
     * // Get one Detot
     * const detot = await prisma.detot.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends detotFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, detotFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__detotClient<$Result.GetResult<Prisma.$detotPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Detot that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {detotFindFirstArgs} args - Arguments to find a Detot
     * @example
     * // Get one Detot
     * const detot = await prisma.detot.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends detotFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, detotFindFirstArgs<ExtArgs>>
    ): Prisma__detotClient<$Result.GetResult<Prisma.$detotPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Detot that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {detotFindFirstOrThrowArgs} args - Arguments to find a Detot
     * @example
     * // Get one Detot
     * const detot = await prisma.detot.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends detotFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, detotFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__detotClient<$Result.GetResult<Prisma.$detotPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Detots that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {detotFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Detots
     * const detots = await prisma.detot.findMany()
     * 
     * // Get first 10 Detots
     * const detots = await prisma.detot.findMany({ take: 10 })
     * 
     * // Only select the `iddetot`
     * const detotWithIddetotOnly = await prisma.detot.findMany({ select: { iddetot: true } })
     * 
    **/
    findMany<T extends detotFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, detotFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$detotPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Detot.
     * @param {detotCreateArgs} args - Arguments to create a Detot.
     * @example
     * // Create one Detot
     * const Detot = await prisma.detot.create({
     *   data: {
     *     // ... data to create a Detot
     *   }
     * })
     * 
    **/
    create<T extends detotCreateArgs<ExtArgs>>(
      args: SelectSubset<T, detotCreateArgs<ExtArgs>>
    ): Prisma__detotClient<$Result.GetResult<Prisma.$detotPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Detots.
     *     @param {detotCreateManyArgs} args - Arguments to create many Detots.
     *     @example
     *     // Create many Detots
     *     const detot = await prisma.detot.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends detotCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, detotCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Detot.
     * @param {detotDeleteArgs} args - Arguments to delete one Detot.
     * @example
     * // Delete one Detot
     * const Detot = await prisma.detot.delete({
     *   where: {
     *     // ... filter to delete one Detot
     *   }
     * })
     * 
    **/
    delete<T extends detotDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, detotDeleteArgs<ExtArgs>>
    ): Prisma__detotClient<$Result.GetResult<Prisma.$detotPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Detot.
     * @param {detotUpdateArgs} args - Arguments to update one Detot.
     * @example
     * // Update one Detot
     * const detot = await prisma.detot.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends detotUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, detotUpdateArgs<ExtArgs>>
    ): Prisma__detotClient<$Result.GetResult<Prisma.$detotPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Detots.
     * @param {detotDeleteManyArgs} args - Arguments to filter Detots to delete.
     * @example
     * // Delete a few Detots
     * const { count } = await prisma.detot.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends detotDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, detotDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Detots.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {detotUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Detots
     * const detot = await prisma.detot.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends detotUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, detotUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Detot.
     * @param {detotUpsertArgs} args - Arguments to update or create a Detot.
     * @example
     * // Update or create a Detot
     * const detot = await prisma.detot.upsert({
     *   create: {
     *     // ... data to create a Detot
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Detot we want to update
     *   }
     * })
    **/
    upsert<T extends detotUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, detotUpsertArgs<ExtArgs>>
    ): Prisma__detotClient<$Result.GetResult<Prisma.$detotPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Detots.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {detotCountArgs} args - Arguments to filter Detots to count.
     * @example
     * // Count the number of Detots
     * const count = await prisma.detot.count({
     *   where: {
     *     // ... the filter for the Detots we want to count
     *   }
     * })
    **/
    count<T extends detotCountArgs>(
      args?: Subset<T, detotCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DetotCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Detot.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DetotAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DetotAggregateArgs>(args: Subset<T, DetotAggregateArgs>): Prisma.PrismaPromise<GetDetotAggregateType<T>>

    /**
     * Group by Detot.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {detotGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends detotGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: detotGroupByArgs['orderBy'] }
        : { orderBy?: detotGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, detotGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDetotGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the detot model
   */
  readonly fields: detotFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for detot.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__detotClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    ordent<T extends detot$ordentArgs<ExtArgs> = {}>(args?: Subset<T, detot$ordentArgs<ExtArgs>>): Prisma__ordentClient<$Result.GetResult<Prisma.$ordentPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    producto<T extends detot$productoArgs<ExtArgs> = {}>(args?: Subset<T, detot$productoArgs<ExtArgs>>): Prisma__productoClient<$Result.GetResult<Prisma.$productoPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the detot model
   */ 
  interface detotFieldRefs {
    readonly iddetot: FieldRef<"detot", 'Int'>
    readonly idot: FieldRef<"detot", 'Int'>
    readonly idpro: FieldRef<"detot", 'Int'>
    readonly cant: FieldRef<"detot", 'Int'>
    readonly punit: FieldRef<"detot", 'Float'>
    readonly stotal: FieldRef<"detot", 'Float'>
    readonly material: FieldRef<"detot", 'String'>
    readonly gr: FieldRef<"detot", 'String'>
    readonly tintas: FieldRef<"detot", 'String'>
    readonly estado: FieldRef<"detot", 'Boolean'>
  }
    

  // Custom InputTypes

  /**
   * detot findUnique
   */
  export type detotFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the detot
     */
    select?: detotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: detotInclude<ExtArgs> | null
    /**
     * Filter, which detot to fetch.
     */
    where: detotWhereUniqueInput
  }


  /**
   * detot findUniqueOrThrow
   */
  export type detotFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the detot
     */
    select?: detotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: detotInclude<ExtArgs> | null
    /**
     * Filter, which detot to fetch.
     */
    where: detotWhereUniqueInput
  }


  /**
   * detot findFirst
   */
  export type detotFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the detot
     */
    select?: detotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: detotInclude<ExtArgs> | null
    /**
     * Filter, which detot to fetch.
     */
    where?: detotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of detots to fetch.
     */
    orderBy?: detotOrderByWithRelationInput | detotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for detots.
     */
    cursor?: detotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` detots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` detots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of detots.
     */
    distinct?: DetotScalarFieldEnum | DetotScalarFieldEnum[]
  }


  /**
   * detot findFirstOrThrow
   */
  export type detotFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the detot
     */
    select?: detotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: detotInclude<ExtArgs> | null
    /**
     * Filter, which detot to fetch.
     */
    where?: detotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of detots to fetch.
     */
    orderBy?: detotOrderByWithRelationInput | detotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for detots.
     */
    cursor?: detotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` detots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` detots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of detots.
     */
    distinct?: DetotScalarFieldEnum | DetotScalarFieldEnum[]
  }


  /**
   * detot findMany
   */
  export type detotFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the detot
     */
    select?: detotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: detotInclude<ExtArgs> | null
    /**
     * Filter, which detots to fetch.
     */
    where?: detotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of detots to fetch.
     */
    orderBy?: detotOrderByWithRelationInput | detotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing detots.
     */
    cursor?: detotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` detots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` detots.
     */
    skip?: number
    distinct?: DetotScalarFieldEnum | DetotScalarFieldEnum[]
  }


  /**
   * detot create
   */
  export type detotCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the detot
     */
    select?: detotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: detotInclude<ExtArgs> | null
    /**
     * The data needed to create a detot.
     */
    data?: XOR<detotCreateInput, detotUncheckedCreateInput>
  }


  /**
   * detot createMany
   */
  export type detotCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many detots.
     */
    data: detotCreateManyInput | detotCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * detot update
   */
  export type detotUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the detot
     */
    select?: detotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: detotInclude<ExtArgs> | null
    /**
     * The data needed to update a detot.
     */
    data: XOR<detotUpdateInput, detotUncheckedUpdateInput>
    /**
     * Choose, which detot to update.
     */
    where: detotWhereUniqueInput
  }


  /**
   * detot updateMany
   */
  export type detotUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update detots.
     */
    data: XOR<detotUpdateManyMutationInput, detotUncheckedUpdateManyInput>
    /**
     * Filter which detots to update
     */
    where?: detotWhereInput
  }


  /**
   * detot upsert
   */
  export type detotUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the detot
     */
    select?: detotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: detotInclude<ExtArgs> | null
    /**
     * The filter to search for the detot to update in case it exists.
     */
    where: detotWhereUniqueInput
    /**
     * In case the detot found by the `where` argument doesn't exist, create a new detot with this data.
     */
    create: XOR<detotCreateInput, detotUncheckedCreateInput>
    /**
     * In case the detot was found with the provided `where` argument, update it with this data.
     */
    update: XOR<detotUpdateInput, detotUncheckedUpdateInput>
  }


  /**
   * detot delete
   */
  export type detotDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the detot
     */
    select?: detotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: detotInclude<ExtArgs> | null
    /**
     * Filter which detot to delete.
     */
    where: detotWhereUniqueInput
  }


  /**
   * detot deleteMany
   */
  export type detotDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which detots to delete
     */
    where?: detotWhereInput
  }


  /**
   * detot.ordent
   */
  export type detot$ordentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ordent
     */
    select?: ordentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ordentInclude<ExtArgs> | null
    where?: ordentWhereInput
  }


  /**
   * detot.producto
   */
  export type detot$productoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the producto
     */
    select?: productoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: productoInclude<ExtArgs> | null
    where?: productoWhereInput
  }


  /**
   * detot without action
   */
  export type detotDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the detot
     */
    select?: detotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: detotInclude<ExtArgs> | null
  }



  /**
   * Model empresa
   */

  export type AggregateEmpresa = {
    _count: EmpresaCountAggregateOutputType | null
    _avg: EmpresaAvgAggregateOutputType | null
    _sum: EmpresaSumAggregateOutputType | null
    _min: EmpresaMinAggregateOutputType | null
    _max: EmpresaMaxAggregateOutputType | null
  }

  export type EmpresaAvgAggregateOutputType = {
    idem: number | null
    idpe: number | null
  }

  export type EmpresaSumAggregateOutputType = {
    idem: number | null
    idpe: number | null
  }

  export type EmpresaMinAggregateOutputType = {
    idem: number | null
    nom: string | null
    dir: string | null
    des: string | null
    dep: string | null
    logo: Buffer | null
    idpe: number | null
    nit: string | null
    auto: string | null
    base64: string | null
  }

  export type EmpresaMaxAggregateOutputType = {
    idem: number | null
    nom: string | null
    dir: string | null
    des: string | null
    dep: string | null
    logo: Buffer | null
    idpe: number | null
    nit: string | null
    auto: string | null
    base64: string | null
  }

  export type EmpresaCountAggregateOutputType = {
    idem: number
    nom: number
    dir: number
    des: number
    dep: number
    logo: number
    idpe: number
    nit: number
    auto: number
    base64: number
    _all: number
  }


  export type EmpresaAvgAggregateInputType = {
    idem?: true
    idpe?: true
  }

  export type EmpresaSumAggregateInputType = {
    idem?: true
    idpe?: true
  }

  export type EmpresaMinAggregateInputType = {
    idem?: true
    nom?: true
    dir?: true
    des?: true
    dep?: true
    logo?: true
    idpe?: true
    nit?: true
    auto?: true
    base64?: true
  }

  export type EmpresaMaxAggregateInputType = {
    idem?: true
    nom?: true
    dir?: true
    des?: true
    dep?: true
    logo?: true
    idpe?: true
    nit?: true
    auto?: true
    base64?: true
  }

  export type EmpresaCountAggregateInputType = {
    idem?: true
    nom?: true
    dir?: true
    des?: true
    dep?: true
    logo?: true
    idpe?: true
    nit?: true
    auto?: true
    base64?: true
    _all?: true
  }

  export type EmpresaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which empresa to aggregate.
     */
    where?: empresaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of empresas to fetch.
     */
    orderBy?: empresaOrderByWithRelationInput | empresaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: empresaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` empresas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` empresas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned empresas
    **/
    _count?: true | EmpresaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EmpresaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EmpresaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmpresaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmpresaMaxAggregateInputType
  }

  export type GetEmpresaAggregateType<T extends EmpresaAggregateArgs> = {
        [P in keyof T & keyof AggregateEmpresa]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmpresa[P]>
      : GetScalarType<T[P], AggregateEmpresa[P]>
  }




  export type empresaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: empresaWhereInput
    orderBy?: empresaOrderByWithAggregationInput | empresaOrderByWithAggregationInput[]
    by: EmpresaScalarFieldEnum[] | EmpresaScalarFieldEnum
    having?: empresaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmpresaCountAggregateInputType | true
    _avg?: EmpresaAvgAggregateInputType
    _sum?: EmpresaSumAggregateInputType
    _min?: EmpresaMinAggregateInputType
    _max?: EmpresaMaxAggregateInputType
  }

  export type EmpresaGroupByOutputType = {
    idem: number
    nom: string | null
    dir: string | null
    des: string | null
    dep: string | null
    logo: Buffer | null
    idpe: number | null
    nit: string | null
    auto: string | null
    base64: string | null
    _count: EmpresaCountAggregateOutputType | null
    _avg: EmpresaAvgAggregateOutputType | null
    _sum: EmpresaSumAggregateOutputType | null
    _min: EmpresaMinAggregateOutputType | null
    _max: EmpresaMaxAggregateOutputType | null
  }

  type GetEmpresaGroupByPayload<T extends empresaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmpresaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmpresaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmpresaGroupByOutputType[P]>
            : GetScalarType<T[P], EmpresaGroupByOutputType[P]>
        }
      >
    >


  export type empresaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idem?: boolean
    nom?: boolean
    dir?: boolean
    des?: boolean
    dep?: boolean
    logo?: boolean
    idpe?: boolean
    nit?: boolean
    auto?: boolean
    base64?: boolean
    persona?: boolean | empresa$personaArgs<ExtArgs>
    leyenda?: boolean | empresa$leyendaArgs<ExtArgs>
    usuario?: boolean | empresa$usuarioArgs<ExtArgs>
    _count?: boolean | EmpresaCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["empresa"]>

  export type empresaSelectScalar = {
    idem?: boolean
    nom?: boolean
    dir?: boolean
    des?: boolean
    dep?: boolean
    logo?: boolean
    idpe?: boolean
    nit?: boolean
    auto?: boolean
    base64?: boolean
  }

  export type empresaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    persona?: boolean | empresa$personaArgs<ExtArgs>
    leyenda?: boolean | empresa$leyendaArgs<ExtArgs>
    usuario?: boolean | empresa$usuarioArgs<ExtArgs>
    _count?: boolean | EmpresaCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $empresaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "empresa"
    objects: {
      persona: Prisma.$personaPayload<ExtArgs> | null
      leyenda: Prisma.$leyendaPayload<ExtArgs>[]
      usuario: Prisma.$usuarioPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      idem: number
      nom: string | null
      dir: string | null
      des: string | null
      dep: string | null
      logo: Buffer | null
      idpe: number | null
      nit: string | null
      auto: string | null
      base64: string | null
    }, ExtArgs["result"]["empresa"]>
    composites: {}
  }


  type empresaGetPayload<S extends boolean | null | undefined | empresaDefaultArgs> = $Result.GetResult<Prisma.$empresaPayload, S>

  type empresaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<empresaFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: EmpresaCountAggregateInputType | true
    }

  export interface empresaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['empresa'], meta: { name: 'empresa' } }
    /**
     * Find zero or one Empresa that matches the filter.
     * @param {empresaFindUniqueArgs} args - Arguments to find a Empresa
     * @example
     * // Get one Empresa
     * const empresa = await prisma.empresa.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends empresaFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, empresaFindUniqueArgs<ExtArgs>>
    ): Prisma__empresaClient<$Result.GetResult<Prisma.$empresaPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Empresa that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {empresaFindUniqueOrThrowArgs} args - Arguments to find a Empresa
     * @example
     * // Get one Empresa
     * const empresa = await prisma.empresa.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends empresaFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, empresaFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__empresaClient<$Result.GetResult<Prisma.$empresaPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Empresa that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {empresaFindFirstArgs} args - Arguments to find a Empresa
     * @example
     * // Get one Empresa
     * const empresa = await prisma.empresa.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends empresaFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, empresaFindFirstArgs<ExtArgs>>
    ): Prisma__empresaClient<$Result.GetResult<Prisma.$empresaPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Empresa that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {empresaFindFirstOrThrowArgs} args - Arguments to find a Empresa
     * @example
     * // Get one Empresa
     * const empresa = await prisma.empresa.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends empresaFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, empresaFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__empresaClient<$Result.GetResult<Prisma.$empresaPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Empresas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {empresaFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Empresas
     * const empresas = await prisma.empresa.findMany()
     * 
     * // Get first 10 Empresas
     * const empresas = await prisma.empresa.findMany({ take: 10 })
     * 
     * // Only select the `idem`
     * const empresaWithIdemOnly = await prisma.empresa.findMany({ select: { idem: true } })
     * 
    **/
    findMany<T extends empresaFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, empresaFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$empresaPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Empresa.
     * @param {empresaCreateArgs} args - Arguments to create a Empresa.
     * @example
     * // Create one Empresa
     * const Empresa = await prisma.empresa.create({
     *   data: {
     *     // ... data to create a Empresa
     *   }
     * })
     * 
    **/
    create<T extends empresaCreateArgs<ExtArgs>>(
      args: SelectSubset<T, empresaCreateArgs<ExtArgs>>
    ): Prisma__empresaClient<$Result.GetResult<Prisma.$empresaPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Empresas.
     *     @param {empresaCreateManyArgs} args - Arguments to create many Empresas.
     *     @example
     *     // Create many Empresas
     *     const empresa = await prisma.empresa.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends empresaCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, empresaCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Empresa.
     * @param {empresaDeleteArgs} args - Arguments to delete one Empresa.
     * @example
     * // Delete one Empresa
     * const Empresa = await prisma.empresa.delete({
     *   where: {
     *     // ... filter to delete one Empresa
     *   }
     * })
     * 
    **/
    delete<T extends empresaDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, empresaDeleteArgs<ExtArgs>>
    ): Prisma__empresaClient<$Result.GetResult<Prisma.$empresaPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Empresa.
     * @param {empresaUpdateArgs} args - Arguments to update one Empresa.
     * @example
     * // Update one Empresa
     * const empresa = await prisma.empresa.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends empresaUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, empresaUpdateArgs<ExtArgs>>
    ): Prisma__empresaClient<$Result.GetResult<Prisma.$empresaPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Empresas.
     * @param {empresaDeleteManyArgs} args - Arguments to filter Empresas to delete.
     * @example
     * // Delete a few Empresas
     * const { count } = await prisma.empresa.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends empresaDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, empresaDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Empresas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {empresaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Empresas
     * const empresa = await prisma.empresa.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends empresaUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, empresaUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Empresa.
     * @param {empresaUpsertArgs} args - Arguments to update or create a Empresa.
     * @example
     * // Update or create a Empresa
     * const empresa = await prisma.empresa.upsert({
     *   create: {
     *     // ... data to create a Empresa
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Empresa we want to update
     *   }
     * })
    **/
    upsert<T extends empresaUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, empresaUpsertArgs<ExtArgs>>
    ): Prisma__empresaClient<$Result.GetResult<Prisma.$empresaPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Empresas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {empresaCountArgs} args - Arguments to filter Empresas to count.
     * @example
     * // Count the number of Empresas
     * const count = await prisma.empresa.count({
     *   where: {
     *     // ... the filter for the Empresas we want to count
     *   }
     * })
    **/
    count<T extends empresaCountArgs>(
      args?: Subset<T, empresaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmpresaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Empresa.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmpresaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmpresaAggregateArgs>(args: Subset<T, EmpresaAggregateArgs>): Prisma.PrismaPromise<GetEmpresaAggregateType<T>>

    /**
     * Group by Empresa.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {empresaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends empresaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: empresaGroupByArgs['orderBy'] }
        : { orderBy?: empresaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, empresaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmpresaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the empresa model
   */
  readonly fields: empresaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for empresa.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__empresaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    persona<T extends empresa$personaArgs<ExtArgs> = {}>(args?: Subset<T, empresa$personaArgs<ExtArgs>>): Prisma__personaClient<$Result.GetResult<Prisma.$personaPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    leyenda<T extends empresa$leyendaArgs<ExtArgs> = {}>(args?: Subset<T, empresa$leyendaArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$leyendaPayload<ExtArgs>, T, 'findMany'> | Null>;

    usuario<T extends empresa$usuarioArgs<ExtArgs> = {}>(args?: Subset<T, empresa$usuarioArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$usuarioPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the empresa model
   */ 
  interface empresaFieldRefs {
    readonly idem: FieldRef<"empresa", 'Int'>
    readonly nom: FieldRef<"empresa", 'String'>
    readonly dir: FieldRef<"empresa", 'String'>
    readonly des: FieldRef<"empresa", 'String'>
    readonly dep: FieldRef<"empresa", 'String'>
    readonly logo: FieldRef<"empresa", 'Bytes'>
    readonly idpe: FieldRef<"empresa", 'Int'>
    readonly nit: FieldRef<"empresa", 'String'>
    readonly auto: FieldRef<"empresa", 'String'>
    readonly base64: FieldRef<"empresa", 'String'>
  }
    

  // Custom InputTypes

  /**
   * empresa findUnique
   */
  export type empresaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the empresa
     */
    select?: empresaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: empresaInclude<ExtArgs> | null
    /**
     * Filter, which empresa to fetch.
     */
    where: empresaWhereUniqueInput
  }


  /**
   * empresa findUniqueOrThrow
   */
  export type empresaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the empresa
     */
    select?: empresaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: empresaInclude<ExtArgs> | null
    /**
     * Filter, which empresa to fetch.
     */
    where: empresaWhereUniqueInput
  }


  /**
   * empresa findFirst
   */
  export type empresaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the empresa
     */
    select?: empresaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: empresaInclude<ExtArgs> | null
    /**
     * Filter, which empresa to fetch.
     */
    where?: empresaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of empresas to fetch.
     */
    orderBy?: empresaOrderByWithRelationInput | empresaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for empresas.
     */
    cursor?: empresaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` empresas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` empresas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of empresas.
     */
    distinct?: EmpresaScalarFieldEnum | EmpresaScalarFieldEnum[]
  }


  /**
   * empresa findFirstOrThrow
   */
  export type empresaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the empresa
     */
    select?: empresaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: empresaInclude<ExtArgs> | null
    /**
     * Filter, which empresa to fetch.
     */
    where?: empresaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of empresas to fetch.
     */
    orderBy?: empresaOrderByWithRelationInput | empresaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for empresas.
     */
    cursor?: empresaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` empresas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` empresas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of empresas.
     */
    distinct?: EmpresaScalarFieldEnum | EmpresaScalarFieldEnum[]
  }


  /**
   * empresa findMany
   */
  export type empresaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the empresa
     */
    select?: empresaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: empresaInclude<ExtArgs> | null
    /**
     * Filter, which empresas to fetch.
     */
    where?: empresaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of empresas to fetch.
     */
    orderBy?: empresaOrderByWithRelationInput | empresaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing empresas.
     */
    cursor?: empresaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` empresas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` empresas.
     */
    skip?: number
    distinct?: EmpresaScalarFieldEnum | EmpresaScalarFieldEnum[]
  }


  /**
   * empresa create
   */
  export type empresaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the empresa
     */
    select?: empresaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: empresaInclude<ExtArgs> | null
    /**
     * The data needed to create a empresa.
     */
    data?: XOR<empresaCreateInput, empresaUncheckedCreateInput>
  }


  /**
   * empresa createMany
   */
  export type empresaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many empresas.
     */
    data: empresaCreateManyInput | empresaCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * empresa update
   */
  export type empresaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the empresa
     */
    select?: empresaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: empresaInclude<ExtArgs> | null
    /**
     * The data needed to update a empresa.
     */
    data: XOR<empresaUpdateInput, empresaUncheckedUpdateInput>
    /**
     * Choose, which empresa to update.
     */
    where: empresaWhereUniqueInput
  }


  /**
   * empresa updateMany
   */
  export type empresaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update empresas.
     */
    data: XOR<empresaUpdateManyMutationInput, empresaUncheckedUpdateManyInput>
    /**
     * Filter which empresas to update
     */
    where?: empresaWhereInput
  }


  /**
   * empresa upsert
   */
  export type empresaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the empresa
     */
    select?: empresaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: empresaInclude<ExtArgs> | null
    /**
     * The filter to search for the empresa to update in case it exists.
     */
    where: empresaWhereUniqueInput
    /**
     * In case the empresa found by the `where` argument doesn't exist, create a new empresa with this data.
     */
    create: XOR<empresaCreateInput, empresaUncheckedCreateInput>
    /**
     * In case the empresa was found with the provided `where` argument, update it with this data.
     */
    update: XOR<empresaUpdateInput, empresaUncheckedUpdateInput>
  }


  /**
   * empresa delete
   */
  export type empresaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the empresa
     */
    select?: empresaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: empresaInclude<ExtArgs> | null
    /**
     * Filter which empresa to delete.
     */
    where: empresaWhereUniqueInput
  }


  /**
   * empresa deleteMany
   */
  export type empresaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which empresas to delete
     */
    where?: empresaWhereInput
  }


  /**
   * empresa.persona
   */
  export type empresa$personaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the persona
     */
    select?: personaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: personaInclude<ExtArgs> | null
    where?: personaWhereInput
  }


  /**
   * empresa.leyenda
   */
  export type empresa$leyendaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the leyenda
     */
    select?: leyendaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: leyendaInclude<ExtArgs> | null
    where?: leyendaWhereInput
    orderBy?: leyendaOrderByWithRelationInput | leyendaOrderByWithRelationInput[]
    cursor?: leyendaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LeyendaScalarFieldEnum | LeyendaScalarFieldEnum[]
  }


  /**
   * empresa.usuario
   */
  export type empresa$usuarioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usuario
     */
    select?: usuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: usuarioInclude<ExtArgs> | null
    where?: usuarioWhereInput
    orderBy?: usuarioOrderByWithRelationInput | usuarioOrderByWithRelationInput[]
    cursor?: usuarioWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UsuarioScalarFieldEnum | UsuarioScalarFieldEnum[]
  }


  /**
   * empresa without action
   */
  export type empresaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the empresa
     */
    select?: empresaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: empresaInclude<ExtArgs> | null
  }



  /**
   * Model eventos
   */

  export type AggregateEventos = {
    _count: EventosCountAggregateOutputType | null
    _avg: EventosAvgAggregateOutputType | null
    _sum: EventosSumAggregateOutputType | null
    _min: EventosMinAggregateOutputType | null
    _max: EventosMaxAggregateOutputType | null
  }

  export type EventosAvgAggregateOutputType = {
    idev: number | null
  }

  export type EventosSumAggregateOutputType = {
    idev: number | null
  }

  export type EventosMinAggregateOutputType = {
    idev: number | null
    fechainicio: Date | null
    fechafin: Date | null
    tipo: string | null
    evento: string | null
    adicional: string | null
    adicional1: string | null
    estado: string | null
  }

  export type EventosMaxAggregateOutputType = {
    idev: number | null
    fechainicio: Date | null
    fechafin: Date | null
    tipo: string | null
    evento: string | null
    adicional: string | null
    adicional1: string | null
    estado: string | null
  }

  export type EventosCountAggregateOutputType = {
    idev: number
    fechainicio: number
    fechafin: number
    tipo: number
    evento: number
    adicional: number
    adicional1: number
    estado: number
    _all: number
  }


  export type EventosAvgAggregateInputType = {
    idev?: true
  }

  export type EventosSumAggregateInputType = {
    idev?: true
  }

  export type EventosMinAggregateInputType = {
    idev?: true
    fechainicio?: true
    fechafin?: true
    tipo?: true
    evento?: true
    adicional?: true
    adicional1?: true
    estado?: true
  }

  export type EventosMaxAggregateInputType = {
    idev?: true
    fechainicio?: true
    fechafin?: true
    tipo?: true
    evento?: true
    adicional?: true
    adicional1?: true
    estado?: true
  }

  export type EventosCountAggregateInputType = {
    idev?: true
    fechainicio?: true
    fechafin?: true
    tipo?: true
    evento?: true
    adicional?: true
    adicional1?: true
    estado?: true
    _all?: true
  }

  export type EventosAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which eventos to aggregate.
     */
    where?: eventosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of eventos to fetch.
     */
    orderBy?: eventosOrderByWithRelationInput | eventosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: eventosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` eventos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` eventos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned eventos
    **/
    _count?: true | EventosCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EventosAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EventosSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EventosMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EventosMaxAggregateInputType
  }

  export type GetEventosAggregateType<T extends EventosAggregateArgs> = {
        [P in keyof T & keyof AggregateEventos]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEventos[P]>
      : GetScalarType<T[P], AggregateEventos[P]>
  }




  export type eventosGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: eventosWhereInput
    orderBy?: eventosOrderByWithAggregationInput | eventosOrderByWithAggregationInput[]
    by: EventosScalarFieldEnum[] | EventosScalarFieldEnum
    having?: eventosScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EventosCountAggregateInputType | true
    _avg?: EventosAvgAggregateInputType
    _sum?: EventosSumAggregateInputType
    _min?: EventosMinAggregateInputType
    _max?: EventosMaxAggregateInputType
  }

  export type EventosGroupByOutputType = {
    idev: number
    fechainicio: Date | null
    fechafin: Date | null
    tipo: string | null
    evento: string | null
    adicional: string | null
    adicional1: string | null
    estado: string | null
    _count: EventosCountAggregateOutputType | null
    _avg: EventosAvgAggregateOutputType | null
    _sum: EventosSumAggregateOutputType | null
    _min: EventosMinAggregateOutputType | null
    _max: EventosMaxAggregateOutputType | null
  }

  type GetEventosGroupByPayload<T extends eventosGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EventosGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EventosGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EventosGroupByOutputType[P]>
            : GetScalarType<T[P], EventosGroupByOutputType[P]>
        }
      >
    >


  export type eventosSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idev?: boolean
    fechainicio?: boolean
    fechafin?: boolean
    tipo?: boolean
    evento?: boolean
    adicional?: boolean
    adicional1?: boolean
    estado?: boolean
  }, ExtArgs["result"]["eventos"]>

  export type eventosSelectScalar = {
    idev?: boolean
    fechainicio?: boolean
    fechafin?: boolean
    tipo?: boolean
    evento?: boolean
    adicional?: boolean
    adicional1?: boolean
    estado?: boolean
  }


  export type $eventosPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "eventos"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      idev: number
      fechainicio: Date | null
      fechafin: Date | null
      tipo: string | null
      evento: string | null
      adicional: string | null
      adicional1: string | null
      estado: string | null
    }, ExtArgs["result"]["eventos"]>
    composites: {}
  }


  type eventosGetPayload<S extends boolean | null | undefined | eventosDefaultArgs> = $Result.GetResult<Prisma.$eventosPayload, S>

  type eventosCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<eventosFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: EventosCountAggregateInputType | true
    }

  export interface eventosDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['eventos'], meta: { name: 'eventos' } }
    /**
     * Find zero or one Eventos that matches the filter.
     * @param {eventosFindUniqueArgs} args - Arguments to find a Eventos
     * @example
     * // Get one Eventos
     * const eventos = await prisma.eventos.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends eventosFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, eventosFindUniqueArgs<ExtArgs>>
    ): Prisma__eventosClient<$Result.GetResult<Prisma.$eventosPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Eventos that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {eventosFindUniqueOrThrowArgs} args - Arguments to find a Eventos
     * @example
     * // Get one Eventos
     * const eventos = await prisma.eventos.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends eventosFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, eventosFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__eventosClient<$Result.GetResult<Prisma.$eventosPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Eventos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {eventosFindFirstArgs} args - Arguments to find a Eventos
     * @example
     * // Get one Eventos
     * const eventos = await prisma.eventos.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends eventosFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, eventosFindFirstArgs<ExtArgs>>
    ): Prisma__eventosClient<$Result.GetResult<Prisma.$eventosPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Eventos that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {eventosFindFirstOrThrowArgs} args - Arguments to find a Eventos
     * @example
     * // Get one Eventos
     * const eventos = await prisma.eventos.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends eventosFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, eventosFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__eventosClient<$Result.GetResult<Prisma.$eventosPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Eventos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {eventosFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Eventos
     * const eventos = await prisma.eventos.findMany()
     * 
     * // Get first 10 Eventos
     * const eventos = await prisma.eventos.findMany({ take: 10 })
     * 
     * // Only select the `idev`
     * const eventosWithIdevOnly = await prisma.eventos.findMany({ select: { idev: true } })
     * 
    **/
    findMany<T extends eventosFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, eventosFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$eventosPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Eventos.
     * @param {eventosCreateArgs} args - Arguments to create a Eventos.
     * @example
     * // Create one Eventos
     * const Eventos = await prisma.eventos.create({
     *   data: {
     *     // ... data to create a Eventos
     *   }
     * })
     * 
    **/
    create<T extends eventosCreateArgs<ExtArgs>>(
      args: SelectSubset<T, eventosCreateArgs<ExtArgs>>
    ): Prisma__eventosClient<$Result.GetResult<Prisma.$eventosPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Eventos.
     *     @param {eventosCreateManyArgs} args - Arguments to create many Eventos.
     *     @example
     *     // Create many Eventos
     *     const eventos = await prisma.eventos.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends eventosCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, eventosCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Eventos.
     * @param {eventosDeleteArgs} args - Arguments to delete one Eventos.
     * @example
     * // Delete one Eventos
     * const Eventos = await prisma.eventos.delete({
     *   where: {
     *     // ... filter to delete one Eventos
     *   }
     * })
     * 
    **/
    delete<T extends eventosDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, eventosDeleteArgs<ExtArgs>>
    ): Prisma__eventosClient<$Result.GetResult<Prisma.$eventosPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Eventos.
     * @param {eventosUpdateArgs} args - Arguments to update one Eventos.
     * @example
     * // Update one Eventos
     * const eventos = await prisma.eventos.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends eventosUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, eventosUpdateArgs<ExtArgs>>
    ): Prisma__eventosClient<$Result.GetResult<Prisma.$eventosPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Eventos.
     * @param {eventosDeleteManyArgs} args - Arguments to filter Eventos to delete.
     * @example
     * // Delete a few Eventos
     * const { count } = await prisma.eventos.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends eventosDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, eventosDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Eventos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {eventosUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Eventos
     * const eventos = await prisma.eventos.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends eventosUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, eventosUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Eventos.
     * @param {eventosUpsertArgs} args - Arguments to update or create a Eventos.
     * @example
     * // Update or create a Eventos
     * const eventos = await prisma.eventos.upsert({
     *   create: {
     *     // ... data to create a Eventos
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Eventos we want to update
     *   }
     * })
    **/
    upsert<T extends eventosUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, eventosUpsertArgs<ExtArgs>>
    ): Prisma__eventosClient<$Result.GetResult<Prisma.$eventosPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Eventos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {eventosCountArgs} args - Arguments to filter Eventos to count.
     * @example
     * // Count the number of Eventos
     * const count = await prisma.eventos.count({
     *   where: {
     *     // ... the filter for the Eventos we want to count
     *   }
     * })
    **/
    count<T extends eventosCountArgs>(
      args?: Subset<T, eventosCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EventosCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Eventos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventosAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EventosAggregateArgs>(args: Subset<T, EventosAggregateArgs>): Prisma.PrismaPromise<GetEventosAggregateType<T>>

    /**
     * Group by Eventos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {eventosGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends eventosGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: eventosGroupByArgs['orderBy'] }
        : { orderBy?: eventosGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, eventosGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEventosGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the eventos model
   */
  readonly fields: eventosFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for eventos.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__eventosClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the eventos model
   */ 
  interface eventosFieldRefs {
    readonly idev: FieldRef<"eventos", 'Int'>
    readonly fechainicio: FieldRef<"eventos", 'DateTime'>
    readonly fechafin: FieldRef<"eventos", 'DateTime'>
    readonly tipo: FieldRef<"eventos", 'String'>
    readonly evento: FieldRef<"eventos", 'String'>
    readonly adicional: FieldRef<"eventos", 'String'>
    readonly adicional1: FieldRef<"eventos", 'String'>
    readonly estado: FieldRef<"eventos", 'String'>
  }
    

  // Custom InputTypes

  /**
   * eventos findUnique
   */
  export type eventosFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the eventos
     */
    select?: eventosSelect<ExtArgs> | null
    /**
     * Filter, which eventos to fetch.
     */
    where: eventosWhereUniqueInput
  }


  /**
   * eventos findUniqueOrThrow
   */
  export type eventosFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the eventos
     */
    select?: eventosSelect<ExtArgs> | null
    /**
     * Filter, which eventos to fetch.
     */
    where: eventosWhereUniqueInput
  }


  /**
   * eventos findFirst
   */
  export type eventosFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the eventos
     */
    select?: eventosSelect<ExtArgs> | null
    /**
     * Filter, which eventos to fetch.
     */
    where?: eventosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of eventos to fetch.
     */
    orderBy?: eventosOrderByWithRelationInput | eventosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for eventos.
     */
    cursor?: eventosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` eventos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` eventos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of eventos.
     */
    distinct?: EventosScalarFieldEnum | EventosScalarFieldEnum[]
  }


  /**
   * eventos findFirstOrThrow
   */
  export type eventosFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the eventos
     */
    select?: eventosSelect<ExtArgs> | null
    /**
     * Filter, which eventos to fetch.
     */
    where?: eventosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of eventos to fetch.
     */
    orderBy?: eventosOrderByWithRelationInput | eventosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for eventos.
     */
    cursor?: eventosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` eventos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` eventos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of eventos.
     */
    distinct?: EventosScalarFieldEnum | EventosScalarFieldEnum[]
  }


  /**
   * eventos findMany
   */
  export type eventosFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the eventos
     */
    select?: eventosSelect<ExtArgs> | null
    /**
     * Filter, which eventos to fetch.
     */
    where?: eventosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of eventos to fetch.
     */
    orderBy?: eventosOrderByWithRelationInput | eventosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing eventos.
     */
    cursor?: eventosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` eventos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` eventos.
     */
    skip?: number
    distinct?: EventosScalarFieldEnum | EventosScalarFieldEnum[]
  }


  /**
   * eventos create
   */
  export type eventosCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the eventos
     */
    select?: eventosSelect<ExtArgs> | null
    /**
     * The data needed to create a eventos.
     */
    data?: XOR<eventosCreateInput, eventosUncheckedCreateInput>
  }


  /**
   * eventos createMany
   */
  export type eventosCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many eventos.
     */
    data: eventosCreateManyInput | eventosCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * eventos update
   */
  export type eventosUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the eventos
     */
    select?: eventosSelect<ExtArgs> | null
    /**
     * The data needed to update a eventos.
     */
    data: XOR<eventosUpdateInput, eventosUncheckedUpdateInput>
    /**
     * Choose, which eventos to update.
     */
    where: eventosWhereUniqueInput
  }


  /**
   * eventos updateMany
   */
  export type eventosUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update eventos.
     */
    data: XOR<eventosUpdateManyMutationInput, eventosUncheckedUpdateManyInput>
    /**
     * Filter which eventos to update
     */
    where?: eventosWhereInput
  }


  /**
   * eventos upsert
   */
  export type eventosUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the eventos
     */
    select?: eventosSelect<ExtArgs> | null
    /**
     * The filter to search for the eventos to update in case it exists.
     */
    where: eventosWhereUniqueInput
    /**
     * In case the eventos found by the `where` argument doesn't exist, create a new eventos with this data.
     */
    create: XOR<eventosCreateInput, eventosUncheckedCreateInput>
    /**
     * In case the eventos was found with the provided `where` argument, update it with this data.
     */
    update: XOR<eventosUpdateInput, eventosUncheckedUpdateInput>
  }


  /**
   * eventos delete
   */
  export type eventosDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the eventos
     */
    select?: eventosSelect<ExtArgs> | null
    /**
     * Filter which eventos to delete.
     */
    where: eventosWhereUniqueInput
  }


  /**
   * eventos deleteMany
   */
  export type eventosDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which eventos to delete
     */
    where?: eventosWhereInput
  }


  /**
   * eventos without action
   */
  export type eventosDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the eventos
     */
    select?: eventosSelect<ExtArgs> | null
  }



  /**
   * Model factura
   */

  export type AggregateFactura = {
    _count: FacturaCountAggregateOutputType | null
    _avg: FacturaAvgAggregateOutputType | null
    _sum: FacturaSumAggregateOutputType | null
    _min: FacturaMinAggregateOutputType | null
    _max: FacturaMaxAggregateOutputType | null
  }

  export type FacturaAvgAggregateOutputType = {
    idfac: number | null
    idot: number | null
    idu: number | null
    monto: number | null
  }

  export type FacturaSumAggregateOutputType = {
    idfac: number | null
    idot: number | null
    idu: number | null
    monto: number | null
  }

  export type FacturaMinAggregateOutputType = {
    idfac: number | null
    idot: number | null
    idu: number | null
    monto: number | null
    fecha: Date | null
    aux: string | null
    aux1: string | null
  }

  export type FacturaMaxAggregateOutputType = {
    idfac: number | null
    idot: number | null
    idu: number | null
    monto: number | null
    fecha: Date | null
    aux: string | null
    aux1: string | null
  }

  export type FacturaCountAggregateOutputType = {
    idfac: number
    idot: number
    idu: number
    monto: number
    fecha: number
    aux: number
    aux1: number
    _all: number
  }


  export type FacturaAvgAggregateInputType = {
    idfac?: true
    idot?: true
    idu?: true
    monto?: true
  }

  export type FacturaSumAggregateInputType = {
    idfac?: true
    idot?: true
    idu?: true
    monto?: true
  }

  export type FacturaMinAggregateInputType = {
    idfac?: true
    idot?: true
    idu?: true
    monto?: true
    fecha?: true
    aux?: true
    aux1?: true
  }

  export type FacturaMaxAggregateInputType = {
    idfac?: true
    idot?: true
    idu?: true
    monto?: true
    fecha?: true
    aux?: true
    aux1?: true
  }

  export type FacturaCountAggregateInputType = {
    idfac?: true
    idot?: true
    idu?: true
    monto?: true
    fecha?: true
    aux?: true
    aux1?: true
    _all?: true
  }

  export type FacturaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which factura to aggregate.
     */
    where?: facturaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of facturas to fetch.
     */
    orderBy?: facturaOrderByWithRelationInput | facturaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: facturaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` facturas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` facturas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned facturas
    **/
    _count?: true | FacturaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FacturaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FacturaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FacturaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FacturaMaxAggregateInputType
  }

  export type GetFacturaAggregateType<T extends FacturaAggregateArgs> = {
        [P in keyof T & keyof AggregateFactura]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFactura[P]>
      : GetScalarType<T[P], AggregateFactura[P]>
  }




  export type facturaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: facturaWhereInput
    orderBy?: facturaOrderByWithAggregationInput | facturaOrderByWithAggregationInput[]
    by: FacturaScalarFieldEnum[] | FacturaScalarFieldEnum
    having?: facturaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FacturaCountAggregateInputType | true
    _avg?: FacturaAvgAggregateInputType
    _sum?: FacturaSumAggregateInputType
    _min?: FacturaMinAggregateInputType
    _max?: FacturaMaxAggregateInputType
  }

  export type FacturaGroupByOutputType = {
    idfac: number
    idot: number | null
    idu: number | null
    monto: number | null
    fecha: Date | null
    aux: string | null
    aux1: string | null
    _count: FacturaCountAggregateOutputType | null
    _avg: FacturaAvgAggregateOutputType | null
    _sum: FacturaSumAggregateOutputType | null
    _min: FacturaMinAggregateOutputType | null
    _max: FacturaMaxAggregateOutputType | null
  }

  type GetFacturaGroupByPayload<T extends facturaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FacturaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FacturaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FacturaGroupByOutputType[P]>
            : GetScalarType<T[P], FacturaGroupByOutputType[P]>
        }
      >
    >


  export type facturaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idfac?: boolean
    idot?: boolean
    idu?: boolean
    monto?: boolean
    fecha?: boolean
    aux?: boolean
    aux1?: boolean
    ordent?: boolean | factura$ordentArgs<ExtArgs>
    usuario?: boolean | factura$usuarioArgs<ExtArgs>
  }, ExtArgs["result"]["factura"]>

  export type facturaSelectScalar = {
    idfac?: boolean
    idot?: boolean
    idu?: boolean
    monto?: boolean
    fecha?: boolean
    aux?: boolean
    aux1?: boolean
  }

  export type facturaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ordent?: boolean | factura$ordentArgs<ExtArgs>
    usuario?: boolean | factura$usuarioArgs<ExtArgs>
  }


  export type $facturaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "factura"
    objects: {
      ordent: Prisma.$ordentPayload<ExtArgs> | null
      usuario: Prisma.$usuarioPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      idfac: number
      idot: number | null
      idu: number | null
      monto: number | null
      fecha: Date | null
      aux: string | null
      aux1: string | null
    }, ExtArgs["result"]["factura"]>
    composites: {}
  }


  type facturaGetPayload<S extends boolean | null | undefined | facturaDefaultArgs> = $Result.GetResult<Prisma.$facturaPayload, S>

  type facturaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<facturaFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: FacturaCountAggregateInputType | true
    }

  export interface facturaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['factura'], meta: { name: 'factura' } }
    /**
     * Find zero or one Factura that matches the filter.
     * @param {facturaFindUniqueArgs} args - Arguments to find a Factura
     * @example
     * // Get one Factura
     * const factura = await prisma.factura.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends facturaFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, facturaFindUniqueArgs<ExtArgs>>
    ): Prisma__facturaClient<$Result.GetResult<Prisma.$facturaPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Factura that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {facturaFindUniqueOrThrowArgs} args - Arguments to find a Factura
     * @example
     * // Get one Factura
     * const factura = await prisma.factura.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends facturaFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, facturaFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__facturaClient<$Result.GetResult<Prisma.$facturaPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Factura that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {facturaFindFirstArgs} args - Arguments to find a Factura
     * @example
     * // Get one Factura
     * const factura = await prisma.factura.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends facturaFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, facturaFindFirstArgs<ExtArgs>>
    ): Prisma__facturaClient<$Result.GetResult<Prisma.$facturaPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Factura that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {facturaFindFirstOrThrowArgs} args - Arguments to find a Factura
     * @example
     * // Get one Factura
     * const factura = await prisma.factura.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends facturaFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, facturaFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__facturaClient<$Result.GetResult<Prisma.$facturaPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Facturas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {facturaFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Facturas
     * const facturas = await prisma.factura.findMany()
     * 
     * // Get first 10 Facturas
     * const facturas = await prisma.factura.findMany({ take: 10 })
     * 
     * // Only select the `idfac`
     * const facturaWithIdfacOnly = await prisma.factura.findMany({ select: { idfac: true } })
     * 
    **/
    findMany<T extends facturaFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, facturaFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$facturaPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Factura.
     * @param {facturaCreateArgs} args - Arguments to create a Factura.
     * @example
     * // Create one Factura
     * const Factura = await prisma.factura.create({
     *   data: {
     *     // ... data to create a Factura
     *   }
     * })
     * 
    **/
    create<T extends facturaCreateArgs<ExtArgs>>(
      args: SelectSubset<T, facturaCreateArgs<ExtArgs>>
    ): Prisma__facturaClient<$Result.GetResult<Prisma.$facturaPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Facturas.
     *     @param {facturaCreateManyArgs} args - Arguments to create many Facturas.
     *     @example
     *     // Create many Facturas
     *     const factura = await prisma.factura.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends facturaCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, facturaCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Factura.
     * @param {facturaDeleteArgs} args - Arguments to delete one Factura.
     * @example
     * // Delete one Factura
     * const Factura = await prisma.factura.delete({
     *   where: {
     *     // ... filter to delete one Factura
     *   }
     * })
     * 
    **/
    delete<T extends facturaDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, facturaDeleteArgs<ExtArgs>>
    ): Prisma__facturaClient<$Result.GetResult<Prisma.$facturaPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Factura.
     * @param {facturaUpdateArgs} args - Arguments to update one Factura.
     * @example
     * // Update one Factura
     * const factura = await prisma.factura.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends facturaUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, facturaUpdateArgs<ExtArgs>>
    ): Prisma__facturaClient<$Result.GetResult<Prisma.$facturaPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Facturas.
     * @param {facturaDeleteManyArgs} args - Arguments to filter Facturas to delete.
     * @example
     * // Delete a few Facturas
     * const { count } = await prisma.factura.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends facturaDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, facturaDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Facturas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {facturaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Facturas
     * const factura = await prisma.factura.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends facturaUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, facturaUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Factura.
     * @param {facturaUpsertArgs} args - Arguments to update or create a Factura.
     * @example
     * // Update or create a Factura
     * const factura = await prisma.factura.upsert({
     *   create: {
     *     // ... data to create a Factura
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Factura we want to update
     *   }
     * })
    **/
    upsert<T extends facturaUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, facturaUpsertArgs<ExtArgs>>
    ): Prisma__facturaClient<$Result.GetResult<Prisma.$facturaPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Facturas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {facturaCountArgs} args - Arguments to filter Facturas to count.
     * @example
     * // Count the number of Facturas
     * const count = await prisma.factura.count({
     *   where: {
     *     // ... the filter for the Facturas we want to count
     *   }
     * })
    **/
    count<T extends facturaCountArgs>(
      args?: Subset<T, facturaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FacturaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Factura.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacturaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FacturaAggregateArgs>(args: Subset<T, FacturaAggregateArgs>): Prisma.PrismaPromise<GetFacturaAggregateType<T>>

    /**
     * Group by Factura.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {facturaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends facturaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: facturaGroupByArgs['orderBy'] }
        : { orderBy?: facturaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, facturaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFacturaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the factura model
   */
  readonly fields: facturaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for factura.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__facturaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    ordent<T extends factura$ordentArgs<ExtArgs> = {}>(args?: Subset<T, factura$ordentArgs<ExtArgs>>): Prisma__ordentClient<$Result.GetResult<Prisma.$ordentPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    usuario<T extends factura$usuarioArgs<ExtArgs> = {}>(args?: Subset<T, factura$usuarioArgs<ExtArgs>>): Prisma__usuarioClient<$Result.GetResult<Prisma.$usuarioPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the factura model
   */ 
  interface facturaFieldRefs {
    readonly idfac: FieldRef<"factura", 'Int'>
    readonly idot: FieldRef<"factura", 'Int'>
    readonly idu: FieldRef<"factura", 'Int'>
    readonly monto: FieldRef<"factura", 'Float'>
    readonly fecha: FieldRef<"factura", 'DateTime'>
    readonly aux: FieldRef<"factura", 'String'>
    readonly aux1: FieldRef<"factura", 'String'>
  }
    

  // Custom InputTypes

  /**
   * factura findUnique
   */
  export type facturaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the factura
     */
    select?: facturaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: facturaInclude<ExtArgs> | null
    /**
     * Filter, which factura to fetch.
     */
    where: facturaWhereUniqueInput
  }


  /**
   * factura findUniqueOrThrow
   */
  export type facturaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the factura
     */
    select?: facturaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: facturaInclude<ExtArgs> | null
    /**
     * Filter, which factura to fetch.
     */
    where: facturaWhereUniqueInput
  }


  /**
   * factura findFirst
   */
  export type facturaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the factura
     */
    select?: facturaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: facturaInclude<ExtArgs> | null
    /**
     * Filter, which factura to fetch.
     */
    where?: facturaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of facturas to fetch.
     */
    orderBy?: facturaOrderByWithRelationInput | facturaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for facturas.
     */
    cursor?: facturaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` facturas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` facturas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of facturas.
     */
    distinct?: FacturaScalarFieldEnum | FacturaScalarFieldEnum[]
  }


  /**
   * factura findFirstOrThrow
   */
  export type facturaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the factura
     */
    select?: facturaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: facturaInclude<ExtArgs> | null
    /**
     * Filter, which factura to fetch.
     */
    where?: facturaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of facturas to fetch.
     */
    orderBy?: facturaOrderByWithRelationInput | facturaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for facturas.
     */
    cursor?: facturaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` facturas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` facturas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of facturas.
     */
    distinct?: FacturaScalarFieldEnum | FacturaScalarFieldEnum[]
  }


  /**
   * factura findMany
   */
  export type facturaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the factura
     */
    select?: facturaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: facturaInclude<ExtArgs> | null
    /**
     * Filter, which facturas to fetch.
     */
    where?: facturaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of facturas to fetch.
     */
    orderBy?: facturaOrderByWithRelationInput | facturaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing facturas.
     */
    cursor?: facturaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` facturas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` facturas.
     */
    skip?: number
    distinct?: FacturaScalarFieldEnum | FacturaScalarFieldEnum[]
  }


  /**
   * factura create
   */
  export type facturaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the factura
     */
    select?: facturaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: facturaInclude<ExtArgs> | null
    /**
     * The data needed to create a factura.
     */
    data?: XOR<facturaCreateInput, facturaUncheckedCreateInput>
  }


  /**
   * factura createMany
   */
  export type facturaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many facturas.
     */
    data: facturaCreateManyInput | facturaCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * factura update
   */
  export type facturaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the factura
     */
    select?: facturaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: facturaInclude<ExtArgs> | null
    /**
     * The data needed to update a factura.
     */
    data: XOR<facturaUpdateInput, facturaUncheckedUpdateInput>
    /**
     * Choose, which factura to update.
     */
    where: facturaWhereUniqueInput
  }


  /**
   * factura updateMany
   */
  export type facturaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update facturas.
     */
    data: XOR<facturaUpdateManyMutationInput, facturaUncheckedUpdateManyInput>
    /**
     * Filter which facturas to update
     */
    where?: facturaWhereInput
  }


  /**
   * factura upsert
   */
  export type facturaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the factura
     */
    select?: facturaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: facturaInclude<ExtArgs> | null
    /**
     * The filter to search for the factura to update in case it exists.
     */
    where: facturaWhereUniqueInput
    /**
     * In case the factura found by the `where` argument doesn't exist, create a new factura with this data.
     */
    create: XOR<facturaCreateInput, facturaUncheckedCreateInput>
    /**
     * In case the factura was found with the provided `where` argument, update it with this data.
     */
    update: XOR<facturaUpdateInput, facturaUncheckedUpdateInput>
  }


  /**
   * factura delete
   */
  export type facturaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the factura
     */
    select?: facturaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: facturaInclude<ExtArgs> | null
    /**
     * Filter which factura to delete.
     */
    where: facturaWhereUniqueInput
  }


  /**
   * factura deleteMany
   */
  export type facturaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which facturas to delete
     */
    where?: facturaWhereInput
  }


  /**
   * factura.ordent
   */
  export type factura$ordentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ordent
     */
    select?: ordentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ordentInclude<ExtArgs> | null
    where?: ordentWhereInput
  }


  /**
   * factura.usuario
   */
  export type factura$usuarioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usuario
     */
    select?: usuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: usuarioInclude<ExtArgs> | null
    where?: usuarioWhereInput
  }


  /**
   * factura without action
   */
  export type facturaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the factura
     */
    select?: facturaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: facturaInclude<ExtArgs> | null
  }



  /**
   * Model inventario
   */

  export type AggregateInventario = {
    _count: InventarioCountAggregateOutputType | null
    _avg: InventarioAvgAggregateOutputType | null
    _sum: InventarioSumAggregateOutputType | null
    _min: InventarioMinAggregateOutputType | null
    _max: InventarioMaxAggregateOutputType | null
  }

  export type InventarioAvgAggregateOutputType = {
    idin: number | null
    idprov: number | null
    precio: number | null
    gr: number | null
    cant: number | null
  }

  export type InventarioSumAggregateOutputType = {
    idin: number | null
    idprov: number | null
    precio: number | null
    gr: number | null
    cant: number | null
  }

  export type InventarioMinAggregateOutputType = {
    idin: number | null
    idprov: number | null
    codigo: string | null
    nom: string | null
    precio: number | null
    gr: number | null
    tam: string | null
    des: string | null
    cant: number | null
    estado: boolean | null
  }

  export type InventarioMaxAggregateOutputType = {
    idin: number | null
    idprov: number | null
    codigo: string | null
    nom: string | null
    precio: number | null
    gr: number | null
    tam: string | null
    des: string | null
    cant: number | null
    estado: boolean | null
  }

  export type InventarioCountAggregateOutputType = {
    idin: number
    idprov: number
    codigo: number
    nom: number
    precio: number
    gr: number
    tam: number
    des: number
    cant: number
    estado: number
    _all: number
  }


  export type InventarioAvgAggregateInputType = {
    idin?: true
    idprov?: true
    precio?: true
    gr?: true
    cant?: true
  }

  export type InventarioSumAggregateInputType = {
    idin?: true
    idprov?: true
    precio?: true
    gr?: true
    cant?: true
  }

  export type InventarioMinAggregateInputType = {
    idin?: true
    idprov?: true
    codigo?: true
    nom?: true
    precio?: true
    gr?: true
    tam?: true
    des?: true
    cant?: true
    estado?: true
  }

  export type InventarioMaxAggregateInputType = {
    idin?: true
    idprov?: true
    codigo?: true
    nom?: true
    precio?: true
    gr?: true
    tam?: true
    des?: true
    cant?: true
    estado?: true
  }

  export type InventarioCountAggregateInputType = {
    idin?: true
    idprov?: true
    codigo?: true
    nom?: true
    precio?: true
    gr?: true
    tam?: true
    des?: true
    cant?: true
    estado?: true
    _all?: true
  }

  export type InventarioAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which inventario to aggregate.
     */
    where?: inventarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inventarios to fetch.
     */
    orderBy?: inventarioOrderByWithRelationInput | inventarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: inventarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inventarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inventarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned inventarios
    **/
    _count?: true | InventarioCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InventarioAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InventarioSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InventarioMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InventarioMaxAggregateInputType
  }

  export type GetInventarioAggregateType<T extends InventarioAggregateArgs> = {
        [P in keyof T & keyof AggregateInventario]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInventario[P]>
      : GetScalarType<T[P], AggregateInventario[P]>
  }




  export type inventarioGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: inventarioWhereInput
    orderBy?: inventarioOrderByWithAggregationInput | inventarioOrderByWithAggregationInput[]
    by: InventarioScalarFieldEnum[] | InventarioScalarFieldEnum
    having?: inventarioScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InventarioCountAggregateInputType | true
    _avg?: InventarioAvgAggregateInputType
    _sum?: InventarioSumAggregateInputType
    _min?: InventarioMinAggregateInputType
    _max?: InventarioMaxAggregateInputType
  }

  export type InventarioGroupByOutputType = {
    idin: number
    idprov: number | null
    codigo: string | null
    nom: string | null
    precio: number | null
    gr: number | null
    tam: string | null
    des: string | null
    cant: number | null
    estado: boolean | null
    _count: InventarioCountAggregateOutputType | null
    _avg: InventarioAvgAggregateOutputType | null
    _sum: InventarioSumAggregateOutputType | null
    _min: InventarioMinAggregateOutputType | null
    _max: InventarioMaxAggregateOutputType | null
  }

  type GetInventarioGroupByPayload<T extends inventarioGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InventarioGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InventarioGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InventarioGroupByOutputType[P]>
            : GetScalarType<T[P], InventarioGroupByOutputType[P]>
        }
      >
    >


  export type inventarioSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idin?: boolean
    idprov?: boolean
    codigo?: boolean
    nom?: boolean
    precio?: boolean
    gr?: boolean
    tam?: boolean
    des?: boolean
    cant?: boolean
    estado?: boolean
    proveedor?: boolean | inventario$proveedorArgs<ExtArgs>
  }, ExtArgs["result"]["inventario"]>

  export type inventarioSelectScalar = {
    idin?: boolean
    idprov?: boolean
    codigo?: boolean
    nom?: boolean
    precio?: boolean
    gr?: boolean
    tam?: boolean
    des?: boolean
    cant?: boolean
    estado?: boolean
  }

  export type inventarioInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    proveedor?: boolean | inventario$proveedorArgs<ExtArgs>
  }


  export type $inventarioPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "inventario"
    objects: {
      proveedor: Prisma.$proveedorPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      idin: number
      idprov: number | null
      codigo: string | null
      nom: string | null
      precio: number | null
      gr: number | null
      tam: string | null
      des: string | null
      cant: number | null
      estado: boolean | null
    }, ExtArgs["result"]["inventario"]>
    composites: {}
  }


  type inventarioGetPayload<S extends boolean | null | undefined | inventarioDefaultArgs> = $Result.GetResult<Prisma.$inventarioPayload, S>

  type inventarioCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<inventarioFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: InventarioCountAggregateInputType | true
    }

  export interface inventarioDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['inventario'], meta: { name: 'inventario' } }
    /**
     * Find zero or one Inventario that matches the filter.
     * @param {inventarioFindUniqueArgs} args - Arguments to find a Inventario
     * @example
     * // Get one Inventario
     * const inventario = await prisma.inventario.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends inventarioFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, inventarioFindUniqueArgs<ExtArgs>>
    ): Prisma__inventarioClient<$Result.GetResult<Prisma.$inventarioPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Inventario that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {inventarioFindUniqueOrThrowArgs} args - Arguments to find a Inventario
     * @example
     * // Get one Inventario
     * const inventario = await prisma.inventario.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends inventarioFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, inventarioFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__inventarioClient<$Result.GetResult<Prisma.$inventarioPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Inventario that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inventarioFindFirstArgs} args - Arguments to find a Inventario
     * @example
     * // Get one Inventario
     * const inventario = await prisma.inventario.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends inventarioFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, inventarioFindFirstArgs<ExtArgs>>
    ): Prisma__inventarioClient<$Result.GetResult<Prisma.$inventarioPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Inventario that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inventarioFindFirstOrThrowArgs} args - Arguments to find a Inventario
     * @example
     * // Get one Inventario
     * const inventario = await prisma.inventario.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends inventarioFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, inventarioFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__inventarioClient<$Result.GetResult<Prisma.$inventarioPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Inventarios that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inventarioFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Inventarios
     * const inventarios = await prisma.inventario.findMany()
     * 
     * // Get first 10 Inventarios
     * const inventarios = await prisma.inventario.findMany({ take: 10 })
     * 
     * // Only select the `idin`
     * const inventarioWithIdinOnly = await prisma.inventario.findMany({ select: { idin: true } })
     * 
    **/
    findMany<T extends inventarioFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, inventarioFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$inventarioPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Inventario.
     * @param {inventarioCreateArgs} args - Arguments to create a Inventario.
     * @example
     * // Create one Inventario
     * const Inventario = await prisma.inventario.create({
     *   data: {
     *     // ... data to create a Inventario
     *   }
     * })
     * 
    **/
    create<T extends inventarioCreateArgs<ExtArgs>>(
      args: SelectSubset<T, inventarioCreateArgs<ExtArgs>>
    ): Prisma__inventarioClient<$Result.GetResult<Prisma.$inventarioPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Inventarios.
     *     @param {inventarioCreateManyArgs} args - Arguments to create many Inventarios.
     *     @example
     *     // Create many Inventarios
     *     const inventario = await prisma.inventario.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends inventarioCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, inventarioCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Inventario.
     * @param {inventarioDeleteArgs} args - Arguments to delete one Inventario.
     * @example
     * // Delete one Inventario
     * const Inventario = await prisma.inventario.delete({
     *   where: {
     *     // ... filter to delete one Inventario
     *   }
     * })
     * 
    **/
    delete<T extends inventarioDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, inventarioDeleteArgs<ExtArgs>>
    ): Prisma__inventarioClient<$Result.GetResult<Prisma.$inventarioPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Inventario.
     * @param {inventarioUpdateArgs} args - Arguments to update one Inventario.
     * @example
     * // Update one Inventario
     * const inventario = await prisma.inventario.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends inventarioUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, inventarioUpdateArgs<ExtArgs>>
    ): Prisma__inventarioClient<$Result.GetResult<Prisma.$inventarioPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Inventarios.
     * @param {inventarioDeleteManyArgs} args - Arguments to filter Inventarios to delete.
     * @example
     * // Delete a few Inventarios
     * const { count } = await prisma.inventario.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends inventarioDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, inventarioDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Inventarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inventarioUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Inventarios
     * const inventario = await prisma.inventario.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends inventarioUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, inventarioUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Inventario.
     * @param {inventarioUpsertArgs} args - Arguments to update or create a Inventario.
     * @example
     * // Update or create a Inventario
     * const inventario = await prisma.inventario.upsert({
     *   create: {
     *     // ... data to create a Inventario
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Inventario we want to update
     *   }
     * })
    **/
    upsert<T extends inventarioUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, inventarioUpsertArgs<ExtArgs>>
    ): Prisma__inventarioClient<$Result.GetResult<Prisma.$inventarioPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Inventarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inventarioCountArgs} args - Arguments to filter Inventarios to count.
     * @example
     * // Count the number of Inventarios
     * const count = await prisma.inventario.count({
     *   where: {
     *     // ... the filter for the Inventarios we want to count
     *   }
     * })
    **/
    count<T extends inventarioCountArgs>(
      args?: Subset<T, inventarioCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InventarioCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Inventario.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventarioAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InventarioAggregateArgs>(args: Subset<T, InventarioAggregateArgs>): Prisma.PrismaPromise<GetInventarioAggregateType<T>>

    /**
     * Group by Inventario.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inventarioGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends inventarioGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: inventarioGroupByArgs['orderBy'] }
        : { orderBy?: inventarioGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, inventarioGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInventarioGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the inventario model
   */
  readonly fields: inventarioFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for inventario.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__inventarioClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    proveedor<T extends inventario$proveedorArgs<ExtArgs> = {}>(args?: Subset<T, inventario$proveedorArgs<ExtArgs>>): Prisma__proveedorClient<$Result.GetResult<Prisma.$proveedorPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the inventario model
   */ 
  interface inventarioFieldRefs {
    readonly idin: FieldRef<"inventario", 'Int'>
    readonly idprov: FieldRef<"inventario", 'Int'>
    readonly codigo: FieldRef<"inventario", 'String'>
    readonly nom: FieldRef<"inventario", 'String'>
    readonly precio: FieldRef<"inventario", 'Float'>
    readonly gr: FieldRef<"inventario", 'Float'>
    readonly tam: FieldRef<"inventario", 'String'>
    readonly des: FieldRef<"inventario", 'String'>
    readonly cant: FieldRef<"inventario", 'Int'>
    readonly estado: FieldRef<"inventario", 'Boolean'>
  }
    

  // Custom InputTypes

  /**
   * inventario findUnique
   */
  export type inventarioFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inventario
     */
    select?: inventarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: inventarioInclude<ExtArgs> | null
    /**
     * Filter, which inventario to fetch.
     */
    where: inventarioWhereUniqueInput
  }


  /**
   * inventario findUniqueOrThrow
   */
  export type inventarioFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inventario
     */
    select?: inventarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: inventarioInclude<ExtArgs> | null
    /**
     * Filter, which inventario to fetch.
     */
    where: inventarioWhereUniqueInput
  }


  /**
   * inventario findFirst
   */
  export type inventarioFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inventario
     */
    select?: inventarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: inventarioInclude<ExtArgs> | null
    /**
     * Filter, which inventario to fetch.
     */
    where?: inventarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inventarios to fetch.
     */
    orderBy?: inventarioOrderByWithRelationInput | inventarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for inventarios.
     */
    cursor?: inventarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inventarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inventarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of inventarios.
     */
    distinct?: InventarioScalarFieldEnum | InventarioScalarFieldEnum[]
  }


  /**
   * inventario findFirstOrThrow
   */
  export type inventarioFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inventario
     */
    select?: inventarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: inventarioInclude<ExtArgs> | null
    /**
     * Filter, which inventario to fetch.
     */
    where?: inventarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inventarios to fetch.
     */
    orderBy?: inventarioOrderByWithRelationInput | inventarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for inventarios.
     */
    cursor?: inventarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inventarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inventarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of inventarios.
     */
    distinct?: InventarioScalarFieldEnum | InventarioScalarFieldEnum[]
  }


  /**
   * inventario findMany
   */
  export type inventarioFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inventario
     */
    select?: inventarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: inventarioInclude<ExtArgs> | null
    /**
     * Filter, which inventarios to fetch.
     */
    where?: inventarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inventarios to fetch.
     */
    orderBy?: inventarioOrderByWithRelationInput | inventarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing inventarios.
     */
    cursor?: inventarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inventarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inventarios.
     */
    skip?: number
    distinct?: InventarioScalarFieldEnum | InventarioScalarFieldEnum[]
  }


  /**
   * inventario create
   */
  export type inventarioCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inventario
     */
    select?: inventarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: inventarioInclude<ExtArgs> | null
    /**
     * The data needed to create a inventario.
     */
    data?: XOR<inventarioCreateInput, inventarioUncheckedCreateInput>
  }


  /**
   * inventario createMany
   */
  export type inventarioCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many inventarios.
     */
    data: inventarioCreateManyInput | inventarioCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * inventario update
   */
  export type inventarioUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inventario
     */
    select?: inventarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: inventarioInclude<ExtArgs> | null
    /**
     * The data needed to update a inventario.
     */
    data: XOR<inventarioUpdateInput, inventarioUncheckedUpdateInput>
    /**
     * Choose, which inventario to update.
     */
    where: inventarioWhereUniqueInput
  }


  /**
   * inventario updateMany
   */
  export type inventarioUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update inventarios.
     */
    data: XOR<inventarioUpdateManyMutationInput, inventarioUncheckedUpdateManyInput>
    /**
     * Filter which inventarios to update
     */
    where?: inventarioWhereInput
  }


  /**
   * inventario upsert
   */
  export type inventarioUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inventario
     */
    select?: inventarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: inventarioInclude<ExtArgs> | null
    /**
     * The filter to search for the inventario to update in case it exists.
     */
    where: inventarioWhereUniqueInput
    /**
     * In case the inventario found by the `where` argument doesn't exist, create a new inventario with this data.
     */
    create: XOR<inventarioCreateInput, inventarioUncheckedCreateInput>
    /**
     * In case the inventario was found with the provided `where` argument, update it with this data.
     */
    update: XOR<inventarioUpdateInput, inventarioUncheckedUpdateInput>
  }


  /**
   * inventario delete
   */
  export type inventarioDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inventario
     */
    select?: inventarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: inventarioInclude<ExtArgs> | null
    /**
     * Filter which inventario to delete.
     */
    where: inventarioWhereUniqueInput
  }


  /**
   * inventario deleteMany
   */
  export type inventarioDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which inventarios to delete
     */
    where?: inventarioWhereInput
  }


  /**
   * inventario.proveedor
   */
  export type inventario$proveedorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the proveedor
     */
    select?: proveedorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: proveedorInclude<ExtArgs> | null
    where?: proveedorWhereInput
  }


  /**
   * inventario without action
   */
  export type inventarioDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inventario
     */
    select?: inventarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: inventarioInclude<ExtArgs> | null
  }



  /**
   * Model leyenda
   */

  export type AggregateLeyenda = {
    _count: LeyendaCountAggregateOutputType | null
    _avg: LeyendaAvgAggregateOutputType | null
    _sum: LeyendaSumAggregateOutputType | null
    _min: LeyendaMinAggregateOutputType | null
    _max: LeyendaMaxAggregateOutputType | null
  }

  export type LeyendaAvgAggregateOutputType = {
    idle: number | null
    orden: number | null
    idem: number | null
  }

  export type LeyendaSumAggregateOutputType = {
    idle: number | null
    orden: number | null
    idem: number | null
  }

  export type LeyendaMinAggregateOutputType = {
    idle: number | null
    des: string | null
    orden: number | null
    idem: number | null
  }

  export type LeyendaMaxAggregateOutputType = {
    idle: number | null
    des: string | null
    orden: number | null
    idem: number | null
  }

  export type LeyendaCountAggregateOutputType = {
    idle: number
    des: number
    orden: number
    idem: number
    _all: number
  }


  export type LeyendaAvgAggregateInputType = {
    idle?: true
    orden?: true
    idem?: true
  }

  export type LeyendaSumAggregateInputType = {
    idle?: true
    orden?: true
    idem?: true
  }

  export type LeyendaMinAggregateInputType = {
    idle?: true
    des?: true
    orden?: true
    idem?: true
  }

  export type LeyendaMaxAggregateInputType = {
    idle?: true
    des?: true
    orden?: true
    idem?: true
  }

  export type LeyendaCountAggregateInputType = {
    idle?: true
    des?: true
    orden?: true
    idem?: true
    _all?: true
  }

  export type LeyendaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which leyenda to aggregate.
     */
    where?: leyendaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of leyendas to fetch.
     */
    orderBy?: leyendaOrderByWithRelationInput | leyendaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: leyendaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` leyendas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` leyendas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned leyendas
    **/
    _count?: true | LeyendaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LeyendaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LeyendaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LeyendaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LeyendaMaxAggregateInputType
  }

  export type GetLeyendaAggregateType<T extends LeyendaAggregateArgs> = {
        [P in keyof T & keyof AggregateLeyenda]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLeyenda[P]>
      : GetScalarType<T[P], AggregateLeyenda[P]>
  }




  export type leyendaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: leyendaWhereInput
    orderBy?: leyendaOrderByWithAggregationInput | leyendaOrderByWithAggregationInput[]
    by: LeyendaScalarFieldEnum[] | LeyendaScalarFieldEnum
    having?: leyendaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LeyendaCountAggregateInputType | true
    _avg?: LeyendaAvgAggregateInputType
    _sum?: LeyendaSumAggregateInputType
    _min?: LeyendaMinAggregateInputType
    _max?: LeyendaMaxAggregateInputType
  }

  export type LeyendaGroupByOutputType = {
    idle: number
    des: string | null
    orden: number | null
    idem: number | null
    _count: LeyendaCountAggregateOutputType | null
    _avg: LeyendaAvgAggregateOutputType | null
    _sum: LeyendaSumAggregateOutputType | null
    _min: LeyendaMinAggregateOutputType | null
    _max: LeyendaMaxAggregateOutputType | null
  }

  type GetLeyendaGroupByPayload<T extends leyendaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LeyendaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LeyendaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LeyendaGroupByOutputType[P]>
            : GetScalarType<T[P], LeyendaGroupByOutputType[P]>
        }
      >
    >


  export type leyendaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idle?: boolean
    des?: boolean
    orden?: boolean
    idem?: boolean
    empresa?: boolean | leyenda$empresaArgs<ExtArgs>
  }, ExtArgs["result"]["leyenda"]>

  export type leyendaSelectScalar = {
    idle?: boolean
    des?: boolean
    orden?: boolean
    idem?: boolean
  }

  export type leyendaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    empresa?: boolean | leyenda$empresaArgs<ExtArgs>
  }


  export type $leyendaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "leyenda"
    objects: {
      empresa: Prisma.$empresaPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      idle: number
      des: string | null
      orden: number | null
      idem: number | null
    }, ExtArgs["result"]["leyenda"]>
    composites: {}
  }


  type leyendaGetPayload<S extends boolean | null | undefined | leyendaDefaultArgs> = $Result.GetResult<Prisma.$leyendaPayload, S>

  type leyendaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<leyendaFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: LeyendaCountAggregateInputType | true
    }

  export interface leyendaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['leyenda'], meta: { name: 'leyenda' } }
    /**
     * Find zero or one Leyenda that matches the filter.
     * @param {leyendaFindUniqueArgs} args - Arguments to find a Leyenda
     * @example
     * // Get one Leyenda
     * const leyenda = await prisma.leyenda.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends leyendaFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, leyendaFindUniqueArgs<ExtArgs>>
    ): Prisma__leyendaClient<$Result.GetResult<Prisma.$leyendaPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Leyenda that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {leyendaFindUniqueOrThrowArgs} args - Arguments to find a Leyenda
     * @example
     * // Get one Leyenda
     * const leyenda = await prisma.leyenda.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends leyendaFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, leyendaFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__leyendaClient<$Result.GetResult<Prisma.$leyendaPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Leyenda that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {leyendaFindFirstArgs} args - Arguments to find a Leyenda
     * @example
     * // Get one Leyenda
     * const leyenda = await prisma.leyenda.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends leyendaFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, leyendaFindFirstArgs<ExtArgs>>
    ): Prisma__leyendaClient<$Result.GetResult<Prisma.$leyendaPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Leyenda that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {leyendaFindFirstOrThrowArgs} args - Arguments to find a Leyenda
     * @example
     * // Get one Leyenda
     * const leyenda = await prisma.leyenda.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends leyendaFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, leyendaFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__leyendaClient<$Result.GetResult<Prisma.$leyendaPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Leyendas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {leyendaFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Leyendas
     * const leyendas = await prisma.leyenda.findMany()
     * 
     * // Get first 10 Leyendas
     * const leyendas = await prisma.leyenda.findMany({ take: 10 })
     * 
     * // Only select the `idle`
     * const leyendaWithIdleOnly = await prisma.leyenda.findMany({ select: { idle: true } })
     * 
    **/
    findMany<T extends leyendaFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, leyendaFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$leyendaPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Leyenda.
     * @param {leyendaCreateArgs} args - Arguments to create a Leyenda.
     * @example
     * // Create one Leyenda
     * const Leyenda = await prisma.leyenda.create({
     *   data: {
     *     // ... data to create a Leyenda
     *   }
     * })
     * 
    **/
    create<T extends leyendaCreateArgs<ExtArgs>>(
      args: SelectSubset<T, leyendaCreateArgs<ExtArgs>>
    ): Prisma__leyendaClient<$Result.GetResult<Prisma.$leyendaPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Leyendas.
     *     @param {leyendaCreateManyArgs} args - Arguments to create many Leyendas.
     *     @example
     *     // Create many Leyendas
     *     const leyenda = await prisma.leyenda.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends leyendaCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, leyendaCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Leyenda.
     * @param {leyendaDeleteArgs} args - Arguments to delete one Leyenda.
     * @example
     * // Delete one Leyenda
     * const Leyenda = await prisma.leyenda.delete({
     *   where: {
     *     // ... filter to delete one Leyenda
     *   }
     * })
     * 
    **/
    delete<T extends leyendaDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, leyendaDeleteArgs<ExtArgs>>
    ): Prisma__leyendaClient<$Result.GetResult<Prisma.$leyendaPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Leyenda.
     * @param {leyendaUpdateArgs} args - Arguments to update one Leyenda.
     * @example
     * // Update one Leyenda
     * const leyenda = await prisma.leyenda.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends leyendaUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, leyendaUpdateArgs<ExtArgs>>
    ): Prisma__leyendaClient<$Result.GetResult<Prisma.$leyendaPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Leyendas.
     * @param {leyendaDeleteManyArgs} args - Arguments to filter Leyendas to delete.
     * @example
     * // Delete a few Leyendas
     * const { count } = await prisma.leyenda.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends leyendaDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, leyendaDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Leyendas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {leyendaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Leyendas
     * const leyenda = await prisma.leyenda.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends leyendaUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, leyendaUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Leyenda.
     * @param {leyendaUpsertArgs} args - Arguments to update or create a Leyenda.
     * @example
     * // Update or create a Leyenda
     * const leyenda = await prisma.leyenda.upsert({
     *   create: {
     *     // ... data to create a Leyenda
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Leyenda we want to update
     *   }
     * })
    **/
    upsert<T extends leyendaUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, leyendaUpsertArgs<ExtArgs>>
    ): Prisma__leyendaClient<$Result.GetResult<Prisma.$leyendaPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Leyendas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {leyendaCountArgs} args - Arguments to filter Leyendas to count.
     * @example
     * // Count the number of Leyendas
     * const count = await prisma.leyenda.count({
     *   where: {
     *     // ... the filter for the Leyendas we want to count
     *   }
     * })
    **/
    count<T extends leyendaCountArgs>(
      args?: Subset<T, leyendaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LeyendaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Leyenda.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeyendaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LeyendaAggregateArgs>(args: Subset<T, LeyendaAggregateArgs>): Prisma.PrismaPromise<GetLeyendaAggregateType<T>>

    /**
     * Group by Leyenda.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {leyendaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends leyendaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: leyendaGroupByArgs['orderBy'] }
        : { orderBy?: leyendaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, leyendaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLeyendaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the leyenda model
   */
  readonly fields: leyendaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for leyenda.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__leyendaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    empresa<T extends leyenda$empresaArgs<ExtArgs> = {}>(args?: Subset<T, leyenda$empresaArgs<ExtArgs>>): Prisma__empresaClient<$Result.GetResult<Prisma.$empresaPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the leyenda model
   */ 
  interface leyendaFieldRefs {
    readonly idle: FieldRef<"leyenda", 'Int'>
    readonly des: FieldRef<"leyenda", 'String'>
    readonly orden: FieldRef<"leyenda", 'Int'>
    readonly idem: FieldRef<"leyenda", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * leyenda findUnique
   */
  export type leyendaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the leyenda
     */
    select?: leyendaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: leyendaInclude<ExtArgs> | null
    /**
     * Filter, which leyenda to fetch.
     */
    where: leyendaWhereUniqueInput
  }


  /**
   * leyenda findUniqueOrThrow
   */
  export type leyendaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the leyenda
     */
    select?: leyendaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: leyendaInclude<ExtArgs> | null
    /**
     * Filter, which leyenda to fetch.
     */
    where: leyendaWhereUniqueInput
  }


  /**
   * leyenda findFirst
   */
  export type leyendaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the leyenda
     */
    select?: leyendaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: leyendaInclude<ExtArgs> | null
    /**
     * Filter, which leyenda to fetch.
     */
    where?: leyendaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of leyendas to fetch.
     */
    orderBy?: leyendaOrderByWithRelationInput | leyendaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for leyendas.
     */
    cursor?: leyendaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` leyendas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` leyendas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of leyendas.
     */
    distinct?: LeyendaScalarFieldEnum | LeyendaScalarFieldEnum[]
  }


  /**
   * leyenda findFirstOrThrow
   */
  export type leyendaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the leyenda
     */
    select?: leyendaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: leyendaInclude<ExtArgs> | null
    /**
     * Filter, which leyenda to fetch.
     */
    where?: leyendaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of leyendas to fetch.
     */
    orderBy?: leyendaOrderByWithRelationInput | leyendaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for leyendas.
     */
    cursor?: leyendaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` leyendas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` leyendas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of leyendas.
     */
    distinct?: LeyendaScalarFieldEnum | LeyendaScalarFieldEnum[]
  }


  /**
   * leyenda findMany
   */
  export type leyendaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the leyenda
     */
    select?: leyendaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: leyendaInclude<ExtArgs> | null
    /**
     * Filter, which leyendas to fetch.
     */
    where?: leyendaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of leyendas to fetch.
     */
    orderBy?: leyendaOrderByWithRelationInput | leyendaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing leyendas.
     */
    cursor?: leyendaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` leyendas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` leyendas.
     */
    skip?: number
    distinct?: LeyendaScalarFieldEnum | LeyendaScalarFieldEnum[]
  }


  /**
   * leyenda create
   */
  export type leyendaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the leyenda
     */
    select?: leyendaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: leyendaInclude<ExtArgs> | null
    /**
     * The data needed to create a leyenda.
     */
    data?: XOR<leyendaCreateInput, leyendaUncheckedCreateInput>
  }


  /**
   * leyenda createMany
   */
  export type leyendaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many leyendas.
     */
    data: leyendaCreateManyInput | leyendaCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * leyenda update
   */
  export type leyendaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the leyenda
     */
    select?: leyendaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: leyendaInclude<ExtArgs> | null
    /**
     * The data needed to update a leyenda.
     */
    data: XOR<leyendaUpdateInput, leyendaUncheckedUpdateInput>
    /**
     * Choose, which leyenda to update.
     */
    where: leyendaWhereUniqueInput
  }


  /**
   * leyenda updateMany
   */
  export type leyendaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update leyendas.
     */
    data: XOR<leyendaUpdateManyMutationInput, leyendaUncheckedUpdateManyInput>
    /**
     * Filter which leyendas to update
     */
    where?: leyendaWhereInput
  }


  /**
   * leyenda upsert
   */
  export type leyendaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the leyenda
     */
    select?: leyendaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: leyendaInclude<ExtArgs> | null
    /**
     * The filter to search for the leyenda to update in case it exists.
     */
    where: leyendaWhereUniqueInput
    /**
     * In case the leyenda found by the `where` argument doesn't exist, create a new leyenda with this data.
     */
    create: XOR<leyendaCreateInput, leyendaUncheckedCreateInput>
    /**
     * In case the leyenda was found with the provided `where` argument, update it with this data.
     */
    update: XOR<leyendaUpdateInput, leyendaUncheckedUpdateInput>
  }


  /**
   * leyenda delete
   */
  export type leyendaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the leyenda
     */
    select?: leyendaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: leyendaInclude<ExtArgs> | null
    /**
     * Filter which leyenda to delete.
     */
    where: leyendaWhereUniqueInput
  }


  /**
   * leyenda deleteMany
   */
  export type leyendaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which leyendas to delete
     */
    where?: leyendaWhereInput
  }


  /**
   * leyenda.empresa
   */
  export type leyenda$empresaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the empresa
     */
    select?: empresaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: empresaInclude<ExtArgs> | null
    where?: empresaWhereInput
  }


  /**
   * leyenda without action
   */
  export type leyendaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the leyenda
     */
    select?: leyendaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: leyendaInclude<ExtArgs> | null
  }



  /**
   * Model marca
   */

  export type AggregateMarca = {
    _count: MarcaCountAggregateOutputType | null
    _avg: MarcaAvgAggregateOutputType | null
    _sum: MarcaSumAggregateOutputType | null
    _min: MarcaMinAggregateOutputType | null
    _max: MarcaMaxAggregateOutputType | null
  }

  export type MarcaAvgAggregateOutputType = {
    idmar: number | null
  }

  export type MarcaSumAggregateOutputType = {
    idmar: number | null
  }

  export type MarcaMinAggregateOutputType = {
    idmar: number | null
    nom: string | null
    des: string | null
    estado: boolean | null
  }

  export type MarcaMaxAggregateOutputType = {
    idmar: number | null
    nom: string | null
    des: string | null
    estado: boolean | null
  }

  export type MarcaCountAggregateOutputType = {
    idmar: number
    nom: number
    des: number
    estado: number
    _all: number
  }


  export type MarcaAvgAggregateInputType = {
    idmar?: true
  }

  export type MarcaSumAggregateInputType = {
    idmar?: true
  }

  export type MarcaMinAggregateInputType = {
    idmar?: true
    nom?: true
    des?: true
    estado?: true
  }

  export type MarcaMaxAggregateInputType = {
    idmar?: true
    nom?: true
    des?: true
    estado?: true
  }

  export type MarcaCountAggregateInputType = {
    idmar?: true
    nom?: true
    des?: true
    estado?: true
    _all?: true
  }

  export type MarcaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which marca to aggregate.
     */
    where?: marcaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of marcas to fetch.
     */
    orderBy?: marcaOrderByWithRelationInput | marcaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: marcaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` marcas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` marcas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned marcas
    **/
    _count?: true | MarcaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MarcaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MarcaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MarcaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MarcaMaxAggregateInputType
  }

  export type GetMarcaAggregateType<T extends MarcaAggregateArgs> = {
        [P in keyof T & keyof AggregateMarca]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMarca[P]>
      : GetScalarType<T[P], AggregateMarca[P]>
  }




  export type marcaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: marcaWhereInput
    orderBy?: marcaOrderByWithAggregationInput | marcaOrderByWithAggregationInput[]
    by: MarcaScalarFieldEnum[] | MarcaScalarFieldEnum
    having?: marcaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MarcaCountAggregateInputType | true
    _avg?: MarcaAvgAggregateInputType
    _sum?: MarcaSumAggregateInputType
    _min?: MarcaMinAggregateInputType
    _max?: MarcaMaxAggregateInputType
  }

  export type MarcaGroupByOutputType = {
    idmar: number
    nom: string | null
    des: string | null
    estado: boolean | null
    _count: MarcaCountAggregateOutputType | null
    _avg: MarcaAvgAggregateOutputType | null
    _sum: MarcaSumAggregateOutputType | null
    _min: MarcaMinAggregateOutputType | null
    _max: MarcaMaxAggregateOutputType | null
  }

  type GetMarcaGroupByPayload<T extends marcaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MarcaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MarcaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MarcaGroupByOutputType[P]>
            : GetScalarType<T[P], MarcaGroupByOutputType[P]>
        }
      >
    >


  export type marcaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idmar?: boolean
    nom?: boolean
    des?: boolean
    estado?: boolean
    color?: boolean | marca$colorArgs<ExtArgs>
    producto?: boolean | marca$productoArgs<ExtArgs>
    terminado?: boolean | marca$terminadoArgs<ExtArgs>
    _count?: boolean | MarcaCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["marca"]>

  export type marcaSelectScalar = {
    idmar?: boolean
    nom?: boolean
    des?: boolean
    estado?: boolean
  }

  export type marcaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    color?: boolean | marca$colorArgs<ExtArgs>
    producto?: boolean | marca$productoArgs<ExtArgs>
    terminado?: boolean | marca$terminadoArgs<ExtArgs>
    _count?: boolean | MarcaCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $marcaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "marca"
    objects: {
      color: Prisma.$colorPayload<ExtArgs>[]
      producto: Prisma.$productoPayload<ExtArgs>[]
      terminado: Prisma.$terminadoPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      idmar: number
      nom: string | null
      des: string | null
      estado: boolean | null
    }, ExtArgs["result"]["marca"]>
    composites: {}
  }


  type marcaGetPayload<S extends boolean | null | undefined | marcaDefaultArgs> = $Result.GetResult<Prisma.$marcaPayload, S>

  type marcaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<marcaFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: MarcaCountAggregateInputType | true
    }

  export interface marcaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['marca'], meta: { name: 'marca' } }
    /**
     * Find zero or one Marca that matches the filter.
     * @param {marcaFindUniqueArgs} args - Arguments to find a Marca
     * @example
     * // Get one Marca
     * const marca = await prisma.marca.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends marcaFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, marcaFindUniqueArgs<ExtArgs>>
    ): Prisma__marcaClient<$Result.GetResult<Prisma.$marcaPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Marca that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {marcaFindUniqueOrThrowArgs} args - Arguments to find a Marca
     * @example
     * // Get one Marca
     * const marca = await prisma.marca.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends marcaFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, marcaFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__marcaClient<$Result.GetResult<Prisma.$marcaPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Marca that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {marcaFindFirstArgs} args - Arguments to find a Marca
     * @example
     * // Get one Marca
     * const marca = await prisma.marca.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends marcaFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, marcaFindFirstArgs<ExtArgs>>
    ): Prisma__marcaClient<$Result.GetResult<Prisma.$marcaPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Marca that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {marcaFindFirstOrThrowArgs} args - Arguments to find a Marca
     * @example
     * // Get one Marca
     * const marca = await prisma.marca.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends marcaFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, marcaFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__marcaClient<$Result.GetResult<Prisma.$marcaPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Marcas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {marcaFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Marcas
     * const marcas = await prisma.marca.findMany()
     * 
     * // Get first 10 Marcas
     * const marcas = await prisma.marca.findMany({ take: 10 })
     * 
     * // Only select the `idmar`
     * const marcaWithIdmarOnly = await prisma.marca.findMany({ select: { idmar: true } })
     * 
    **/
    findMany<T extends marcaFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, marcaFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$marcaPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Marca.
     * @param {marcaCreateArgs} args - Arguments to create a Marca.
     * @example
     * // Create one Marca
     * const Marca = await prisma.marca.create({
     *   data: {
     *     // ... data to create a Marca
     *   }
     * })
     * 
    **/
    create<T extends marcaCreateArgs<ExtArgs>>(
      args: SelectSubset<T, marcaCreateArgs<ExtArgs>>
    ): Prisma__marcaClient<$Result.GetResult<Prisma.$marcaPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Marcas.
     *     @param {marcaCreateManyArgs} args - Arguments to create many Marcas.
     *     @example
     *     // Create many Marcas
     *     const marca = await prisma.marca.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends marcaCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, marcaCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Marca.
     * @param {marcaDeleteArgs} args - Arguments to delete one Marca.
     * @example
     * // Delete one Marca
     * const Marca = await prisma.marca.delete({
     *   where: {
     *     // ... filter to delete one Marca
     *   }
     * })
     * 
    **/
    delete<T extends marcaDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, marcaDeleteArgs<ExtArgs>>
    ): Prisma__marcaClient<$Result.GetResult<Prisma.$marcaPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Marca.
     * @param {marcaUpdateArgs} args - Arguments to update one Marca.
     * @example
     * // Update one Marca
     * const marca = await prisma.marca.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends marcaUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, marcaUpdateArgs<ExtArgs>>
    ): Prisma__marcaClient<$Result.GetResult<Prisma.$marcaPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Marcas.
     * @param {marcaDeleteManyArgs} args - Arguments to filter Marcas to delete.
     * @example
     * // Delete a few Marcas
     * const { count } = await prisma.marca.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends marcaDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, marcaDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Marcas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {marcaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Marcas
     * const marca = await prisma.marca.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends marcaUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, marcaUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Marca.
     * @param {marcaUpsertArgs} args - Arguments to update or create a Marca.
     * @example
     * // Update or create a Marca
     * const marca = await prisma.marca.upsert({
     *   create: {
     *     // ... data to create a Marca
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Marca we want to update
     *   }
     * })
    **/
    upsert<T extends marcaUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, marcaUpsertArgs<ExtArgs>>
    ): Prisma__marcaClient<$Result.GetResult<Prisma.$marcaPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Marcas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {marcaCountArgs} args - Arguments to filter Marcas to count.
     * @example
     * // Count the number of Marcas
     * const count = await prisma.marca.count({
     *   where: {
     *     // ... the filter for the Marcas we want to count
     *   }
     * })
    **/
    count<T extends marcaCountArgs>(
      args?: Subset<T, marcaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MarcaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Marca.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarcaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MarcaAggregateArgs>(args: Subset<T, MarcaAggregateArgs>): Prisma.PrismaPromise<GetMarcaAggregateType<T>>

    /**
     * Group by Marca.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {marcaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends marcaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: marcaGroupByArgs['orderBy'] }
        : { orderBy?: marcaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, marcaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMarcaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the marca model
   */
  readonly fields: marcaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for marca.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__marcaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    color<T extends marca$colorArgs<ExtArgs> = {}>(args?: Subset<T, marca$colorArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$colorPayload<ExtArgs>, T, 'findMany'> | Null>;

    producto<T extends marca$productoArgs<ExtArgs> = {}>(args?: Subset<T, marca$productoArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$productoPayload<ExtArgs>, T, 'findMany'> | Null>;

    terminado<T extends marca$terminadoArgs<ExtArgs> = {}>(args?: Subset<T, marca$terminadoArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$terminadoPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the marca model
   */ 
  interface marcaFieldRefs {
    readonly idmar: FieldRef<"marca", 'Int'>
    readonly nom: FieldRef<"marca", 'String'>
    readonly des: FieldRef<"marca", 'String'>
    readonly estado: FieldRef<"marca", 'Boolean'>
  }
    

  // Custom InputTypes

  /**
   * marca findUnique
   */
  export type marcaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the marca
     */
    select?: marcaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: marcaInclude<ExtArgs> | null
    /**
     * Filter, which marca to fetch.
     */
    where: marcaWhereUniqueInput
  }


  /**
   * marca findUniqueOrThrow
   */
  export type marcaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the marca
     */
    select?: marcaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: marcaInclude<ExtArgs> | null
    /**
     * Filter, which marca to fetch.
     */
    where: marcaWhereUniqueInput
  }


  /**
   * marca findFirst
   */
  export type marcaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the marca
     */
    select?: marcaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: marcaInclude<ExtArgs> | null
    /**
     * Filter, which marca to fetch.
     */
    where?: marcaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of marcas to fetch.
     */
    orderBy?: marcaOrderByWithRelationInput | marcaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for marcas.
     */
    cursor?: marcaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` marcas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` marcas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of marcas.
     */
    distinct?: MarcaScalarFieldEnum | MarcaScalarFieldEnum[]
  }


  /**
   * marca findFirstOrThrow
   */
  export type marcaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the marca
     */
    select?: marcaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: marcaInclude<ExtArgs> | null
    /**
     * Filter, which marca to fetch.
     */
    where?: marcaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of marcas to fetch.
     */
    orderBy?: marcaOrderByWithRelationInput | marcaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for marcas.
     */
    cursor?: marcaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` marcas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` marcas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of marcas.
     */
    distinct?: MarcaScalarFieldEnum | MarcaScalarFieldEnum[]
  }


  /**
   * marca findMany
   */
  export type marcaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the marca
     */
    select?: marcaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: marcaInclude<ExtArgs> | null
    /**
     * Filter, which marcas to fetch.
     */
    where?: marcaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of marcas to fetch.
     */
    orderBy?: marcaOrderByWithRelationInput | marcaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing marcas.
     */
    cursor?: marcaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` marcas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` marcas.
     */
    skip?: number
    distinct?: MarcaScalarFieldEnum | MarcaScalarFieldEnum[]
  }


  /**
   * marca create
   */
  export type marcaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the marca
     */
    select?: marcaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: marcaInclude<ExtArgs> | null
    /**
     * The data needed to create a marca.
     */
    data?: XOR<marcaCreateInput, marcaUncheckedCreateInput>
  }


  /**
   * marca createMany
   */
  export type marcaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many marcas.
     */
    data: marcaCreateManyInput | marcaCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * marca update
   */
  export type marcaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the marca
     */
    select?: marcaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: marcaInclude<ExtArgs> | null
    /**
     * The data needed to update a marca.
     */
    data: XOR<marcaUpdateInput, marcaUncheckedUpdateInput>
    /**
     * Choose, which marca to update.
     */
    where: marcaWhereUniqueInput
  }


  /**
   * marca updateMany
   */
  export type marcaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update marcas.
     */
    data: XOR<marcaUpdateManyMutationInput, marcaUncheckedUpdateManyInput>
    /**
     * Filter which marcas to update
     */
    where?: marcaWhereInput
  }


  /**
   * marca upsert
   */
  export type marcaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the marca
     */
    select?: marcaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: marcaInclude<ExtArgs> | null
    /**
     * The filter to search for the marca to update in case it exists.
     */
    where: marcaWhereUniqueInput
    /**
     * In case the marca found by the `where` argument doesn't exist, create a new marca with this data.
     */
    create: XOR<marcaCreateInput, marcaUncheckedCreateInput>
    /**
     * In case the marca was found with the provided `where` argument, update it with this data.
     */
    update: XOR<marcaUpdateInput, marcaUncheckedUpdateInput>
  }


  /**
   * marca delete
   */
  export type marcaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the marca
     */
    select?: marcaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: marcaInclude<ExtArgs> | null
    /**
     * Filter which marca to delete.
     */
    where: marcaWhereUniqueInput
  }


  /**
   * marca deleteMany
   */
  export type marcaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which marcas to delete
     */
    where?: marcaWhereInput
  }


  /**
   * marca.color
   */
  export type marca$colorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the color
     */
    select?: colorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: colorInclude<ExtArgs> | null
    where?: colorWhereInput
    orderBy?: colorOrderByWithRelationInput | colorOrderByWithRelationInput[]
    cursor?: colorWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ColorScalarFieldEnum | ColorScalarFieldEnum[]
  }


  /**
   * marca.producto
   */
  export type marca$productoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the producto
     */
    select?: productoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: productoInclude<ExtArgs> | null
    where?: productoWhereInput
    orderBy?: productoOrderByWithRelationInput | productoOrderByWithRelationInput[]
    cursor?: productoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductoScalarFieldEnum | ProductoScalarFieldEnum[]
  }


  /**
   * marca.terminado
   */
  export type marca$terminadoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the terminado
     */
    select?: terminadoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: terminadoInclude<ExtArgs> | null
    where?: terminadoWhereInput
    orderBy?: terminadoOrderByWithRelationInput | terminadoOrderByWithRelationInput[]
    cursor?: terminadoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TerminadoScalarFieldEnum | TerminadoScalarFieldEnum[]
  }


  /**
   * marca without action
   */
  export type marcaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the marca
     */
    select?: marcaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: marcaInclude<ExtArgs> | null
  }



  /**
   * Model menu
   */

  export type AggregateMenu = {
    _count: MenuCountAggregateOutputType | null
    _avg: MenuAvgAggregateOutputType | null
    _sum: MenuSumAggregateOutputType | null
    _min: MenuMinAggregateOutputType | null
    _max: MenuMaxAggregateOutputType | null
  }

  export type MenuAvgAggregateOutputType = {
    idm: number | null
  }

  export type MenuSumAggregateOutputType = {
    idm: number | null
  }

  export type MenuMinAggregateOutputType = {
    idm: number | null
    nom: string | null
    url: string | null
    estado: boolean | null
  }

  export type MenuMaxAggregateOutputType = {
    idm: number | null
    nom: string | null
    url: string | null
    estado: boolean | null
  }

  export type MenuCountAggregateOutputType = {
    idm: number
    nom: number
    url: number
    estado: number
    _all: number
  }


  export type MenuAvgAggregateInputType = {
    idm?: true
  }

  export type MenuSumAggregateInputType = {
    idm?: true
  }

  export type MenuMinAggregateInputType = {
    idm?: true
    nom?: true
    url?: true
    estado?: true
  }

  export type MenuMaxAggregateInputType = {
    idm?: true
    nom?: true
    url?: true
    estado?: true
  }

  export type MenuCountAggregateInputType = {
    idm?: true
    nom?: true
    url?: true
    estado?: true
    _all?: true
  }

  export type MenuAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which menu to aggregate.
     */
    where?: menuWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of menus to fetch.
     */
    orderBy?: menuOrderByWithRelationInput | menuOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: menuWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` menus from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` menus.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned menus
    **/
    _count?: true | MenuCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MenuAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MenuSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MenuMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MenuMaxAggregateInputType
  }

  export type GetMenuAggregateType<T extends MenuAggregateArgs> = {
        [P in keyof T & keyof AggregateMenu]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMenu[P]>
      : GetScalarType<T[P], AggregateMenu[P]>
  }




  export type menuGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: menuWhereInput
    orderBy?: menuOrderByWithAggregationInput | menuOrderByWithAggregationInput[]
    by: MenuScalarFieldEnum[] | MenuScalarFieldEnum
    having?: menuScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MenuCountAggregateInputType | true
    _avg?: MenuAvgAggregateInputType
    _sum?: MenuSumAggregateInputType
    _min?: MenuMinAggregateInputType
    _max?: MenuMaxAggregateInputType
  }

  export type MenuGroupByOutputType = {
    idm: number
    nom: string
    url: string
    estado: boolean | null
    _count: MenuCountAggregateOutputType | null
    _avg: MenuAvgAggregateOutputType | null
    _sum: MenuSumAggregateOutputType | null
    _min: MenuMinAggregateOutputType | null
    _max: MenuMaxAggregateOutputType | null
  }

  type GetMenuGroupByPayload<T extends menuGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MenuGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MenuGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MenuGroupByOutputType[P]>
            : GetScalarType<T[P], MenuGroupByOutputType[P]>
        }
      >
    >


  export type menuSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idm?: boolean
    nom?: boolean
    url?: boolean
    estado?: boolean
    rolmenu?: boolean | menu$rolmenuArgs<ExtArgs>
    _count?: boolean | MenuCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["menu"]>

  export type menuSelectScalar = {
    idm?: boolean
    nom?: boolean
    url?: boolean
    estado?: boolean
  }

  export type menuInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    rolmenu?: boolean | menu$rolmenuArgs<ExtArgs>
    _count?: boolean | MenuCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $menuPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "menu"
    objects: {
      rolmenu: Prisma.$rolmenuPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      idm: number
      nom: string
      url: string
      estado: boolean | null
    }, ExtArgs["result"]["menu"]>
    composites: {}
  }


  type menuGetPayload<S extends boolean | null | undefined | menuDefaultArgs> = $Result.GetResult<Prisma.$menuPayload, S>

  type menuCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<menuFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: MenuCountAggregateInputType | true
    }

  export interface menuDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['menu'], meta: { name: 'menu' } }
    /**
     * Find zero or one Menu that matches the filter.
     * @param {menuFindUniqueArgs} args - Arguments to find a Menu
     * @example
     * // Get one Menu
     * const menu = await prisma.menu.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends menuFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, menuFindUniqueArgs<ExtArgs>>
    ): Prisma__menuClient<$Result.GetResult<Prisma.$menuPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Menu that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {menuFindUniqueOrThrowArgs} args - Arguments to find a Menu
     * @example
     * // Get one Menu
     * const menu = await prisma.menu.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends menuFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, menuFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__menuClient<$Result.GetResult<Prisma.$menuPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Menu that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {menuFindFirstArgs} args - Arguments to find a Menu
     * @example
     * // Get one Menu
     * const menu = await prisma.menu.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends menuFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, menuFindFirstArgs<ExtArgs>>
    ): Prisma__menuClient<$Result.GetResult<Prisma.$menuPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Menu that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {menuFindFirstOrThrowArgs} args - Arguments to find a Menu
     * @example
     * // Get one Menu
     * const menu = await prisma.menu.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends menuFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, menuFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__menuClient<$Result.GetResult<Prisma.$menuPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Menus that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {menuFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Menus
     * const menus = await prisma.menu.findMany()
     * 
     * // Get first 10 Menus
     * const menus = await prisma.menu.findMany({ take: 10 })
     * 
     * // Only select the `idm`
     * const menuWithIdmOnly = await prisma.menu.findMany({ select: { idm: true } })
     * 
    **/
    findMany<T extends menuFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, menuFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$menuPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Menu.
     * @param {menuCreateArgs} args - Arguments to create a Menu.
     * @example
     * // Create one Menu
     * const Menu = await prisma.menu.create({
     *   data: {
     *     // ... data to create a Menu
     *   }
     * })
     * 
    **/
    create<T extends menuCreateArgs<ExtArgs>>(
      args: SelectSubset<T, menuCreateArgs<ExtArgs>>
    ): Prisma__menuClient<$Result.GetResult<Prisma.$menuPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Menus.
     *     @param {menuCreateManyArgs} args - Arguments to create many Menus.
     *     @example
     *     // Create many Menus
     *     const menu = await prisma.menu.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends menuCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, menuCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Menu.
     * @param {menuDeleteArgs} args - Arguments to delete one Menu.
     * @example
     * // Delete one Menu
     * const Menu = await prisma.menu.delete({
     *   where: {
     *     // ... filter to delete one Menu
     *   }
     * })
     * 
    **/
    delete<T extends menuDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, menuDeleteArgs<ExtArgs>>
    ): Prisma__menuClient<$Result.GetResult<Prisma.$menuPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Menu.
     * @param {menuUpdateArgs} args - Arguments to update one Menu.
     * @example
     * // Update one Menu
     * const menu = await prisma.menu.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends menuUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, menuUpdateArgs<ExtArgs>>
    ): Prisma__menuClient<$Result.GetResult<Prisma.$menuPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Menus.
     * @param {menuDeleteManyArgs} args - Arguments to filter Menus to delete.
     * @example
     * // Delete a few Menus
     * const { count } = await prisma.menu.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends menuDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, menuDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Menus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {menuUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Menus
     * const menu = await prisma.menu.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends menuUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, menuUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Menu.
     * @param {menuUpsertArgs} args - Arguments to update or create a Menu.
     * @example
     * // Update or create a Menu
     * const menu = await prisma.menu.upsert({
     *   create: {
     *     // ... data to create a Menu
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Menu we want to update
     *   }
     * })
    **/
    upsert<T extends menuUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, menuUpsertArgs<ExtArgs>>
    ): Prisma__menuClient<$Result.GetResult<Prisma.$menuPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Menus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {menuCountArgs} args - Arguments to filter Menus to count.
     * @example
     * // Count the number of Menus
     * const count = await prisma.menu.count({
     *   where: {
     *     // ... the filter for the Menus we want to count
     *   }
     * })
    **/
    count<T extends menuCountArgs>(
      args?: Subset<T, menuCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MenuCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Menu.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenuAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MenuAggregateArgs>(args: Subset<T, MenuAggregateArgs>): Prisma.PrismaPromise<GetMenuAggregateType<T>>

    /**
     * Group by Menu.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {menuGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends menuGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: menuGroupByArgs['orderBy'] }
        : { orderBy?: menuGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, menuGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMenuGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the menu model
   */
  readonly fields: menuFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for menu.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__menuClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    rolmenu<T extends menu$rolmenuArgs<ExtArgs> = {}>(args?: Subset<T, menu$rolmenuArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$rolmenuPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the menu model
   */ 
  interface menuFieldRefs {
    readonly idm: FieldRef<"menu", 'Int'>
    readonly nom: FieldRef<"menu", 'String'>
    readonly url: FieldRef<"menu", 'String'>
    readonly estado: FieldRef<"menu", 'Boolean'>
  }
    

  // Custom InputTypes

  /**
   * menu findUnique
   */
  export type menuFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the menu
     */
    select?: menuSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: menuInclude<ExtArgs> | null
    /**
     * Filter, which menu to fetch.
     */
    where: menuWhereUniqueInput
  }


  /**
   * menu findUniqueOrThrow
   */
  export type menuFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the menu
     */
    select?: menuSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: menuInclude<ExtArgs> | null
    /**
     * Filter, which menu to fetch.
     */
    where: menuWhereUniqueInput
  }


  /**
   * menu findFirst
   */
  export type menuFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the menu
     */
    select?: menuSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: menuInclude<ExtArgs> | null
    /**
     * Filter, which menu to fetch.
     */
    where?: menuWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of menus to fetch.
     */
    orderBy?: menuOrderByWithRelationInput | menuOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for menus.
     */
    cursor?: menuWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` menus from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` menus.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of menus.
     */
    distinct?: MenuScalarFieldEnum | MenuScalarFieldEnum[]
  }


  /**
   * menu findFirstOrThrow
   */
  export type menuFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the menu
     */
    select?: menuSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: menuInclude<ExtArgs> | null
    /**
     * Filter, which menu to fetch.
     */
    where?: menuWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of menus to fetch.
     */
    orderBy?: menuOrderByWithRelationInput | menuOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for menus.
     */
    cursor?: menuWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` menus from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` menus.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of menus.
     */
    distinct?: MenuScalarFieldEnum | MenuScalarFieldEnum[]
  }


  /**
   * menu findMany
   */
  export type menuFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the menu
     */
    select?: menuSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: menuInclude<ExtArgs> | null
    /**
     * Filter, which menus to fetch.
     */
    where?: menuWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of menus to fetch.
     */
    orderBy?: menuOrderByWithRelationInput | menuOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing menus.
     */
    cursor?: menuWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` menus from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` menus.
     */
    skip?: number
    distinct?: MenuScalarFieldEnum | MenuScalarFieldEnum[]
  }


  /**
   * menu create
   */
  export type menuCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the menu
     */
    select?: menuSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: menuInclude<ExtArgs> | null
    /**
     * The data needed to create a menu.
     */
    data: XOR<menuCreateInput, menuUncheckedCreateInput>
  }


  /**
   * menu createMany
   */
  export type menuCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many menus.
     */
    data: menuCreateManyInput | menuCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * menu update
   */
  export type menuUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the menu
     */
    select?: menuSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: menuInclude<ExtArgs> | null
    /**
     * The data needed to update a menu.
     */
    data: XOR<menuUpdateInput, menuUncheckedUpdateInput>
    /**
     * Choose, which menu to update.
     */
    where: menuWhereUniqueInput
  }


  /**
   * menu updateMany
   */
  export type menuUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update menus.
     */
    data: XOR<menuUpdateManyMutationInput, menuUncheckedUpdateManyInput>
    /**
     * Filter which menus to update
     */
    where?: menuWhereInput
  }


  /**
   * menu upsert
   */
  export type menuUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the menu
     */
    select?: menuSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: menuInclude<ExtArgs> | null
    /**
     * The filter to search for the menu to update in case it exists.
     */
    where: menuWhereUniqueInput
    /**
     * In case the menu found by the `where` argument doesn't exist, create a new menu with this data.
     */
    create: XOR<menuCreateInput, menuUncheckedCreateInput>
    /**
     * In case the menu was found with the provided `where` argument, update it with this data.
     */
    update: XOR<menuUpdateInput, menuUncheckedUpdateInput>
  }


  /**
   * menu delete
   */
  export type menuDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the menu
     */
    select?: menuSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: menuInclude<ExtArgs> | null
    /**
     * Filter which menu to delete.
     */
    where: menuWhereUniqueInput
  }


  /**
   * menu deleteMany
   */
  export type menuDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which menus to delete
     */
    where?: menuWhereInput
  }


  /**
   * menu.rolmenu
   */
  export type menu$rolmenuArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rolmenu
     */
    select?: rolmenuSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: rolmenuInclude<ExtArgs> | null
    where?: rolmenuWhereInput
    orderBy?: rolmenuOrderByWithRelationInput | rolmenuOrderByWithRelationInput[]
    cursor?: rolmenuWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RolmenuScalarFieldEnum | RolmenuScalarFieldEnum[]
  }


  /**
   * menu without action
   */
  export type menuDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the menu
     */
    select?: menuSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: menuInclude<ExtArgs> | null
  }



  /**
   * Model ordent
   */

  export type AggregateOrdent = {
    _count: OrdentCountAggregateOutputType | null
    _avg: OrdentAvgAggregateOutputType | null
    _sum: OrdentSumAggregateOutputType | null
    _min: OrdentMinAggregateOutputType | null
    _max: OrdentMaxAggregateOutputType | null
  }

  export type OrdentAvgAggregateOutputType = {
    idot: number | null
    idu: number | null
    idcli: number | null
    idcot: number | null
    precio: number | null
    descuento: number | null
    preciofinal: number | null
    tiempo: number | null
  }

  export type OrdentSumAggregateOutputType = {
    idot: number | null
    idu: number | null
    idcli: number | null
    idcot: number | null
    precio: number | null
    descuento: number | null
    preciofinal: number | null
    tiempo: number | null
  }

  export type OrdentMinAggregateOutputType = {
    idot: number | null
    idu: number | null
    idcli: number | null
    idcot: number | null
    fecha: Date | null
    precio: number | null
    descuento: number | null
    preciofinal: number | null
    tiempo: number | null
    arte: string | null
    obs: string | null
    estado: string | null
    factura: string | null
  }

  export type OrdentMaxAggregateOutputType = {
    idot: number | null
    idu: number | null
    idcli: number | null
    idcot: number | null
    fecha: Date | null
    precio: number | null
    descuento: number | null
    preciofinal: number | null
    tiempo: number | null
    arte: string | null
    obs: string | null
    estado: string | null
    factura: string | null
  }

  export type OrdentCountAggregateOutputType = {
    idot: number
    idu: number
    idcli: number
    idcot: number
    fecha: number
    precio: number
    descuento: number
    preciofinal: number
    tiempo: number
    arte: number
    obs: number
    estado: number
    factura: number
    _all: number
  }


  export type OrdentAvgAggregateInputType = {
    idot?: true
    idu?: true
    idcli?: true
    idcot?: true
    precio?: true
    descuento?: true
    preciofinal?: true
    tiempo?: true
  }

  export type OrdentSumAggregateInputType = {
    idot?: true
    idu?: true
    idcli?: true
    idcot?: true
    precio?: true
    descuento?: true
    preciofinal?: true
    tiempo?: true
  }

  export type OrdentMinAggregateInputType = {
    idot?: true
    idu?: true
    idcli?: true
    idcot?: true
    fecha?: true
    precio?: true
    descuento?: true
    preciofinal?: true
    tiempo?: true
    arte?: true
    obs?: true
    estado?: true
    factura?: true
  }

  export type OrdentMaxAggregateInputType = {
    idot?: true
    idu?: true
    idcli?: true
    idcot?: true
    fecha?: true
    precio?: true
    descuento?: true
    preciofinal?: true
    tiempo?: true
    arte?: true
    obs?: true
    estado?: true
    factura?: true
  }

  export type OrdentCountAggregateInputType = {
    idot?: true
    idu?: true
    idcli?: true
    idcot?: true
    fecha?: true
    precio?: true
    descuento?: true
    preciofinal?: true
    tiempo?: true
    arte?: true
    obs?: true
    estado?: true
    factura?: true
    _all?: true
  }

  export type OrdentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ordent to aggregate.
     */
    where?: ordentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ordents to fetch.
     */
    orderBy?: ordentOrderByWithRelationInput | ordentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ordentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ordents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ordents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ordents
    **/
    _count?: true | OrdentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OrdentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OrdentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrdentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrdentMaxAggregateInputType
  }

  export type GetOrdentAggregateType<T extends OrdentAggregateArgs> = {
        [P in keyof T & keyof AggregateOrdent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrdent[P]>
      : GetScalarType<T[P], AggregateOrdent[P]>
  }




  export type ordentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ordentWhereInput
    orderBy?: ordentOrderByWithAggregationInput | ordentOrderByWithAggregationInput[]
    by: OrdentScalarFieldEnum[] | OrdentScalarFieldEnum
    having?: ordentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrdentCountAggregateInputType | true
    _avg?: OrdentAvgAggregateInputType
    _sum?: OrdentSumAggregateInputType
    _min?: OrdentMinAggregateInputType
    _max?: OrdentMaxAggregateInputType
  }

  export type OrdentGroupByOutputType = {
    idot: number
    idu: number | null
    idcli: number | null
    idcot: number | null
    fecha: Date | null
    precio: number | null
    descuento: number | null
    preciofinal: number | null
    tiempo: number | null
    arte: string | null
    obs: string | null
    estado: string | null
    factura: string | null
    _count: OrdentCountAggregateOutputType | null
    _avg: OrdentAvgAggregateOutputType | null
    _sum: OrdentSumAggregateOutputType | null
    _min: OrdentMinAggregateOutputType | null
    _max: OrdentMaxAggregateOutputType | null
  }

  type GetOrdentGroupByPayload<T extends ordentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrdentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrdentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrdentGroupByOutputType[P]>
            : GetScalarType<T[P], OrdentGroupByOutputType[P]>
        }
      >
    >


  export type ordentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idot?: boolean
    idu?: boolean
    idcli?: boolean
    idcot?: boolean
    fecha?: boolean
    precio?: boolean
    descuento?: boolean
    preciofinal?: boolean
    tiempo?: boolean
    arte?: boolean
    obs?: boolean
    estado?: boolean
    factura?: boolean
    arte1?: boolean | ordent$arte1Args<ExtArgs>
    detot?: boolean | ordent$detotArgs<ExtArgs>
    factura1?: boolean | ordent$factura1Args<ExtArgs>
    cliente?: boolean | ordent$clienteArgs<ExtArgs>
    cotizacion?: boolean | ordent$cotizacionArgs<ExtArgs>
    usuario?: boolean | ordent$usuarioArgs<ExtArgs>
    pago?: boolean | ordent$pagoArgs<ExtArgs>
    _count?: boolean | OrdentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ordent"]>

  export type ordentSelectScalar = {
    idot?: boolean
    idu?: boolean
    idcli?: boolean
    idcot?: boolean
    fecha?: boolean
    precio?: boolean
    descuento?: boolean
    preciofinal?: boolean
    tiempo?: boolean
    arte?: boolean
    obs?: boolean
    estado?: boolean
    factura?: boolean
  }

  export type ordentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    arte1?: boolean | ordent$arte1Args<ExtArgs>
    detot?: boolean | ordent$detotArgs<ExtArgs>
    factura1?: boolean | ordent$factura1Args<ExtArgs>
    cliente?: boolean | ordent$clienteArgs<ExtArgs>
    cotizacion?: boolean | ordent$cotizacionArgs<ExtArgs>
    usuario?: boolean | ordent$usuarioArgs<ExtArgs>
    pago?: boolean | ordent$pagoArgs<ExtArgs>
    _count?: boolean | OrdentCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $ordentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ordent"
    objects: {
      arte1: Prisma.$artePayload<ExtArgs>[]
      detot: Prisma.$detotPayload<ExtArgs>[]
      factura1: Prisma.$facturaPayload<ExtArgs>[]
      cliente: Prisma.$clientePayload<ExtArgs> | null
      cotizacion: Prisma.$cotizacionPayload<ExtArgs> | null
      usuario: Prisma.$usuarioPayload<ExtArgs> | null
      pago: Prisma.$pagoPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      idot: number
      idu: number | null
      idcli: number | null
      idcot: number | null
      fecha: Date | null
      precio: number | null
      descuento: number | null
      preciofinal: number | null
      tiempo: number | null
      arte: string | null
      obs: string | null
      estado: string | null
      factura: string | null
    }, ExtArgs["result"]["ordent"]>
    composites: {}
  }


  type ordentGetPayload<S extends boolean | null | undefined | ordentDefaultArgs> = $Result.GetResult<Prisma.$ordentPayload, S>

  type ordentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ordentFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: OrdentCountAggregateInputType | true
    }

  export interface ordentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ordent'], meta: { name: 'ordent' } }
    /**
     * Find zero or one Ordent that matches the filter.
     * @param {ordentFindUniqueArgs} args - Arguments to find a Ordent
     * @example
     * // Get one Ordent
     * const ordent = await prisma.ordent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ordentFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ordentFindUniqueArgs<ExtArgs>>
    ): Prisma__ordentClient<$Result.GetResult<Prisma.$ordentPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Ordent that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ordentFindUniqueOrThrowArgs} args - Arguments to find a Ordent
     * @example
     * // Get one Ordent
     * const ordent = await prisma.ordent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ordentFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ordentFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ordentClient<$Result.GetResult<Prisma.$ordentPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Ordent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ordentFindFirstArgs} args - Arguments to find a Ordent
     * @example
     * // Get one Ordent
     * const ordent = await prisma.ordent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ordentFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ordentFindFirstArgs<ExtArgs>>
    ): Prisma__ordentClient<$Result.GetResult<Prisma.$ordentPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Ordent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ordentFindFirstOrThrowArgs} args - Arguments to find a Ordent
     * @example
     * // Get one Ordent
     * const ordent = await prisma.ordent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ordentFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ordentFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ordentClient<$Result.GetResult<Prisma.$ordentPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Ordents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ordentFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Ordents
     * const ordents = await prisma.ordent.findMany()
     * 
     * // Get first 10 Ordents
     * const ordents = await prisma.ordent.findMany({ take: 10 })
     * 
     * // Only select the `idot`
     * const ordentWithIdotOnly = await prisma.ordent.findMany({ select: { idot: true } })
     * 
    **/
    findMany<T extends ordentFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ordentFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ordentPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Ordent.
     * @param {ordentCreateArgs} args - Arguments to create a Ordent.
     * @example
     * // Create one Ordent
     * const Ordent = await prisma.ordent.create({
     *   data: {
     *     // ... data to create a Ordent
     *   }
     * })
     * 
    **/
    create<T extends ordentCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ordentCreateArgs<ExtArgs>>
    ): Prisma__ordentClient<$Result.GetResult<Prisma.$ordentPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Ordents.
     *     @param {ordentCreateManyArgs} args - Arguments to create many Ordents.
     *     @example
     *     // Create many Ordents
     *     const ordent = await prisma.ordent.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ordentCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ordentCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Ordent.
     * @param {ordentDeleteArgs} args - Arguments to delete one Ordent.
     * @example
     * // Delete one Ordent
     * const Ordent = await prisma.ordent.delete({
     *   where: {
     *     // ... filter to delete one Ordent
     *   }
     * })
     * 
    **/
    delete<T extends ordentDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ordentDeleteArgs<ExtArgs>>
    ): Prisma__ordentClient<$Result.GetResult<Prisma.$ordentPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Ordent.
     * @param {ordentUpdateArgs} args - Arguments to update one Ordent.
     * @example
     * // Update one Ordent
     * const ordent = await prisma.ordent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ordentUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ordentUpdateArgs<ExtArgs>>
    ): Prisma__ordentClient<$Result.GetResult<Prisma.$ordentPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Ordents.
     * @param {ordentDeleteManyArgs} args - Arguments to filter Ordents to delete.
     * @example
     * // Delete a few Ordents
     * const { count } = await prisma.ordent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ordentDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ordentDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ordents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ordentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Ordents
     * const ordent = await prisma.ordent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ordentUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ordentUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Ordent.
     * @param {ordentUpsertArgs} args - Arguments to update or create a Ordent.
     * @example
     * // Update or create a Ordent
     * const ordent = await prisma.ordent.upsert({
     *   create: {
     *     // ... data to create a Ordent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Ordent we want to update
     *   }
     * })
    **/
    upsert<T extends ordentUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ordentUpsertArgs<ExtArgs>>
    ): Prisma__ordentClient<$Result.GetResult<Prisma.$ordentPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Ordents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ordentCountArgs} args - Arguments to filter Ordents to count.
     * @example
     * // Count the number of Ordents
     * const count = await prisma.ordent.count({
     *   where: {
     *     // ... the filter for the Ordents we want to count
     *   }
     * })
    **/
    count<T extends ordentCountArgs>(
      args?: Subset<T, ordentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrdentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Ordent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrdentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrdentAggregateArgs>(args: Subset<T, OrdentAggregateArgs>): Prisma.PrismaPromise<GetOrdentAggregateType<T>>

    /**
     * Group by Ordent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ordentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ordentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ordentGroupByArgs['orderBy'] }
        : { orderBy?: ordentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ordentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrdentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ordent model
   */
  readonly fields: ordentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ordent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ordentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    arte1<T extends ordent$arte1Args<ExtArgs> = {}>(args?: Subset<T, ordent$arte1Args<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$artePayload<ExtArgs>, T, 'findMany'> | Null>;

    detot<T extends ordent$detotArgs<ExtArgs> = {}>(args?: Subset<T, ordent$detotArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$detotPayload<ExtArgs>, T, 'findMany'> | Null>;

    factura1<T extends ordent$factura1Args<ExtArgs> = {}>(args?: Subset<T, ordent$factura1Args<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$facturaPayload<ExtArgs>, T, 'findMany'> | Null>;

    cliente<T extends ordent$clienteArgs<ExtArgs> = {}>(args?: Subset<T, ordent$clienteArgs<ExtArgs>>): Prisma__clienteClient<$Result.GetResult<Prisma.$clientePayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    cotizacion<T extends ordent$cotizacionArgs<ExtArgs> = {}>(args?: Subset<T, ordent$cotizacionArgs<ExtArgs>>): Prisma__cotizacionClient<$Result.GetResult<Prisma.$cotizacionPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    usuario<T extends ordent$usuarioArgs<ExtArgs> = {}>(args?: Subset<T, ordent$usuarioArgs<ExtArgs>>): Prisma__usuarioClient<$Result.GetResult<Prisma.$usuarioPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    pago<T extends ordent$pagoArgs<ExtArgs> = {}>(args?: Subset<T, ordent$pagoArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$pagoPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the ordent model
   */ 
  interface ordentFieldRefs {
    readonly idot: FieldRef<"ordent", 'Int'>
    readonly idu: FieldRef<"ordent", 'Int'>
    readonly idcli: FieldRef<"ordent", 'Int'>
    readonly idcot: FieldRef<"ordent", 'Int'>
    readonly fecha: FieldRef<"ordent", 'DateTime'>
    readonly precio: FieldRef<"ordent", 'Float'>
    readonly descuento: FieldRef<"ordent", 'Float'>
    readonly preciofinal: FieldRef<"ordent", 'Float'>
    readonly tiempo: FieldRef<"ordent", 'Int'>
    readonly arte: FieldRef<"ordent", 'String'>
    readonly obs: FieldRef<"ordent", 'String'>
    readonly estado: FieldRef<"ordent", 'String'>
    readonly factura: FieldRef<"ordent", 'String'>
  }
    

  // Custom InputTypes

  /**
   * ordent findUnique
   */
  export type ordentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ordent
     */
    select?: ordentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ordentInclude<ExtArgs> | null
    /**
     * Filter, which ordent to fetch.
     */
    where: ordentWhereUniqueInput
  }


  /**
   * ordent findUniqueOrThrow
   */
  export type ordentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ordent
     */
    select?: ordentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ordentInclude<ExtArgs> | null
    /**
     * Filter, which ordent to fetch.
     */
    where: ordentWhereUniqueInput
  }


  /**
   * ordent findFirst
   */
  export type ordentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ordent
     */
    select?: ordentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ordentInclude<ExtArgs> | null
    /**
     * Filter, which ordent to fetch.
     */
    where?: ordentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ordents to fetch.
     */
    orderBy?: ordentOrderByWithRelationInput | ordentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ordents.
     */
    cursor?: ordentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ordents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ordents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ordents.
     */
    distinct?: OrdentScalarFieldEnum | OrdentScalarFieldEnum[]
  }


  /**
   * ordent findFirstOrThrow
   */
  export type ordentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ordent
     */
    select?: ordentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ordentInclude<ExtArgs> | null
    /**
     * Filter, which ordent to fetch.
     */
    where?: ordentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ordents to fetch.
     */
    orderBy?: ordentOrderByWithRelationInput | ordentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ordents.
     */
    cursor?: ordentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ordents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ordents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ordents.
     */
    distinct?: OrdentScalarFieldEnum | OrdentScalarFieldEnum[]
  }


  /**
   * ordent findMany
   */
  export type ordentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ordent
     */
    select?: ordentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ordentInclude<ExtArgs> | null
    /**
     * Filter, which ordents to fetch.
     */
    where?: ordentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ordents to fetch.
     */
    orderBy?: ordentOrderByWithRelationInput | ordentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ordents.
     */
    cursor?: ordentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ordents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ordents.
     */
    skip?: number
    distinct?: OrdentScalarFieldEnum | OrdentScalarFieldEnum[]
  }


  /**
   * ordent create
   */
  export type ordentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ordent
     */
    select?: ordentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ordentInclude<ExtArgs> | null
    /**
     * The data needed to create a ordent.
     */
    data?: XOR<ordentCreateInput, ordentUncheckedCreateInput>
  }


  /**
   * ordent createMany
   */
  export type ordentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ordents.
     */
    data: ordentCreateManyInput | ordentCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * ordent update
   */
  export type ordentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ordent
     */
    select?: ordentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ordentInclude<ExtArgs> | null
    /**
     * The data needed to update a ordent.
     */
    data: XOR<ordentUpdateInput, ordentUncheckedUpdateInput>
    /**
     * Choose, which ordent to update.
     */
    where: ordentWhereUniqueInput
  }


  /**
   * ordent updateMany
   */
  export type ordentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ordents.
     */
    data: XOR<ordentUpdateManyMutationInput, ordentUncheckedUpdateManyInput>
    /**
     * Filter which ordents to update
     */
    where?: ordentWhereInput
  }


  /**
   * ordent upsert
   */
  export type ordentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ordent
     */
    select?: ordentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ordentInclude<ExtArgs> | null
    /**
     * The filter to search for the ordent to update in case it exists.
     */
    where: ordentWhereUniqueInput
    /**
     * In case the ordent found by the `where` argument doesn't exist, create a new ordent with this data.
     */
    create: XOR<ordentCreateInput, ordentUncheckedCreateInput>
    /**
     * In case the ordent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ordentUpdateInput, ordentUncheckedUpdateInput>
  }


  /**
   * ordent delete
   */
  export type ordentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ordent
     */
    select?: ordentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ordentInclude<ExtArgs> | null
    /**
     * Filter which ordent to delete.
     */
    where: ordentWhereUniqueInput
  }


  /**
   * ordent deleteMany
   */
  export type ordentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ordents to delete
     */
    where?: ordentWhereInput
  }


  /**
   * ordent.arte1
   */
  export type ordent$arte1Args<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the arte
     */
    select?: arteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: arteInclude<ExtArgs> | null
    where?: arteWhereInput
    orderBy?: arteOrderByWithRelationInput | arteOrderByWithRelationInput[]
    cursor?: arteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ArteScalarFieldEnum | ArteScalarFieldEnum[]
  }


  /**
   * ordent.detot
   */
  export type ordent$detotArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the detot
     */
    select?: detotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: detotInclude<ExtArgs> | null
    where?: detotWhereInput
    orderBy?: detotOrderByWithRelationInput | detotOrderByWithRelationInput[]
    cursor?: detotWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DetotScalarFieldEnum | DetotScalarFieldEnum[]
  }


  /**
   * ordent.factura1
   */
  export type ordent$factura1Args<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the factura
     */
    select?: facturaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: facturaInclude<ExtArgs> | null
    where?: facturaWhereInput
    orderBy?: facturaOrderByWithRelationInput | facturaOrderByWithRelationInput[]
    cursor?: facturaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FacturaScalarFieldEnum | FacturaScalarFieldEnum[]
  }


  /**
   * ordent.cliente
   */
  export type ordent$clienteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cliente
     */
    select?: clienteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: clienteInclude<ExtArgs> | null
    where?: clienteWhereInput
  }


  /**
   * ordent.cotizacion
   */
  export type ordent$cotizacionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cotizacion
     */
    select?: cotizacionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: cotizacionInclude<ExtArgs> | null
    where?: cotizacionWhereInput
  }


  /**
   * ordent.usuario
   */
  export type ordent$usuarioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usuario
     */
    select?: usuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: usuarioInclude<ExtArgs> | null
    where?: usuarioWhereInput
  }


  /**
   * ordent.pago
   */
  export type ordent$pagoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pago
     */
    select?: pagoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: pagoInclude<ExtArgs> | null
    where?: pagoWhereInput
    orderBy?: pagoOrderByWithRelationInput | pagoOrderByWithRelationInput[]
    cursor?: pagoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PagoScalarFieldEnum | PagoScalarFieldEnum[]
  }


  /**
   * ordent without action
   */
  export type ordentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ordent
     */
    select?: ordentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ordentInclude<ExtArgs> | null
  }



  /**
   * Model pago
   */

  export type AggregatePago = {
    _count: PagoCountAggregateOutputType | null
    _avg: PagoAvgAggregateOutputType | null
    _sum: PagoSumAggregateOutputType | null
    _min: PagoMinAggregateOutputType | null
    _max: PagoMaxAggregateOutputType | null
  }

  export type PagoAvgAggregateOutputType = {
    idpagp: number | null
    idot: number | null
    preciof: number | null
    pago: number | null
    saldo: number | null
  }

  export type PagoSumAggregateOutputType = {
    idpagp: number | null
    idot: number | null
    preciof: number | null
    pago: number | null
    saldo: number | null
  }

  export type PagoMinAggregateOutputType = {
    idpagp: number | null
    idot: number | null
    fecha: Date | null
    preciof: number | null
    pago: number | null
    saldo: number | null
    des: string | null
    comprobante: Buffer | null
  }

  export type PagoMaxAggregateOutputType = {
    idpagp: number | null
    idot: number | null
    fecha: Date | null
    preciof: number | null
    pago: number | null
    saldo: number | null
    des: string | null
    comprobante: Buffer | null
  }

  export type PagoCountAggregateOutputType = {
    idpagp: number
    idot: number
    fecha: number
    preciof: number
    pago: number
    saldo: number
    des: number
    comprobante: number
    _all: number
  }


  export type PagoAvgAggregateInputType = {
    idpagp?: true
    idot?: true
    preciof?: true
    pago?: true
    saldo?: true
  }

  export type PagoSumAggregateInputType = {
    idpagp?: true
    idot?: true
    preciof?: true
    pago?: true
    saldo?: true
  }

  export type PagoMinAggregateInputType = {
    idpagp?: true
    idot?: true
    fecha?: true
    preciof?: true
    pago?: true
    saldo?: true
    des?: true
    comprobante?: true
  }

  export type PagoMaxAggregateInputType = {
    idpagp?: true
    idot?: true
    fecha?: true
    preciof?: true
    pago?: true
    saldo?: true
    des?: true
    comprobante?: true
  }

  export type PagoCountAggregateInputType = {
    idpagp?: true
    idot?: true
    fecha?: true
    preciof?: true
    pago?: true
    saldo?: true
    des?: true
    comprobante?: true
    _all?: true
  }

  export type PagoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which pago to aggregate.
     */
    where?: pagoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pagos to fetch.
     */
    orderBy?: pagoOrderByWithRelationInput | pagoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: pagoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pagos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pagos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned pagos
    **/
    _count?: true | PagoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PagoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PagoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PagoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PagoMaxAggregateInputType
  }

  export type GetPagoAggregateType<T extends PagoAggregateArgs> = {
        [P in keyof T & keyof AggregatePago]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePago[P]>
      : GetScalarType<T[P], AggregatePago[P]>
  }




  export type pagoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: pagoWhereInput
    orderBy?: pagoOrderByWithAggregationInput | pagoOrderByWithAggregationInput[]
    by: PagoScalarFieldEnum[] | PagoScalarFieldEnum
    having?: pagoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PagoCountAggregateInputType | true
    _avg?: PagoAvgAggregateInputType
    _sum?: PagoSumAggregateInputType
    _min?: PagoMinAggregateInputType
    _max?: PagoMaxAggregateInputType
  }

  export type PagoGroupByOutputType = {
    idpagp: number
    idot: number | null
    fecha: Date | null
    preciof: number | null
    pago: number | null
    saldo: number | null
    des: string | null
    comprobante: Buffer | null
    _count: PagoCountAggregateOutputType | null
    _avg: PagoAvgAggregateOutputType | null
    _sum: PagoSumAggregateOutputType | null
    _min: PagoMinAggregateOutputType | null
    _max: PagoMaxAggregateOutputType | null
  }

  type GetPagoGroupByPayload<T extends pagoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PagoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PagoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PagoGroupByOutputType[P]>
            : GetScalarType<T[P], PagoGroupByOutputType[P]>
        }
      >
    >


  export type pagoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idpagp?: boolean
    idot?: boolean
    fecha?: boolean
    preciof?: boolean
    pago?: boolean
    saldo?: boolean
    des?: boolean
    comprobante?: boolean
    ordent?: boolean | pago$ordentArgs<ExtArgs>
  }, ExtArgs["result"]["pago"]>

  export type pagoSelectScalar = {
    idpagp?: boolean
    idot?: boolean
    fecha?: boolean
    preciof?: boolean
    pago?: boolean
    saldo?: boolean
    des?: boolean
    comprobante?: boolean
  }

  export type pagoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ordent?: boolean | pago$ordentArgs<ExtArgs>
  }


  export type $pagoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "pago"
    objects: {
      ordent: Prisma.$ordentPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      idpagp: number
      idot: number | null
      fecha: Date | null
      preciof: number | null
      pago: number | null
      saldo: number | null
      des: string | null
      comprobante: Buffer | null
    }, ExtArgs["result"]["pago"]>
    composites: {}
  }


  type pagoGetPayload<S extends boolean | null | undefined | pagoDefaultArgs> = $Result.GetResult<Prisma.$pagoPayload, S>

  type pagoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<pagoFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: PagoCountAggregateInputType | true
    }

  export interface pagoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['pago'], meta: { name: 'pago' } }
    /**
     * Find zero or one Pago that matches the filter.
     * @param {pagoFindUniqueArgs} args - Arguments to find a Pago
     * @example
     * // Get one Pago
     * const pago = await prisma.pago.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends pagoFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, pagoFindUniqueArgs<ExtArgs>>
    ): Prisma__pagoClient<$Result.GetResult<Prisma.$pagoPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Pago that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {pagoFindUniqueOrThrowArgs} args - Arguments to find a Pago
     * @example
     * // Get one Pago
     * const pago = await prisma.pago.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends pagoFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, pagoFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__pagoClient<$Result.GetResult<Prisma.$pagoPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Pago that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pagoFindFirstArgs} args - Arguments to find a Pago
     * @example
     * // Get one Pago
     * const pago = await prisma.pago.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends pagoFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, pagoFindFirstArgs<ExtArgs>>
    ): Prisma__pagoClient<$Result.GetResult<Prisma.$pagoPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Pago that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pagoFindFirstOrThrowArgs} args - Arguments to find a Pago
     * @example
     * // Get one Pago
     * const pago = await prisma.pago.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends pagoFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, pagoFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__pagoClient<$Result.GetResult<Prisma.$pagoPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Pagos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pagoFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Pagos
     * const pagos = await prisma.pago.findMany()
     * 
     * // Get first 10 Pagos
     * const pagos = await prisma.pago.findMany({ take: 10 })
     * 
     * // Only select the `idpagp`
     * const pagoWithIdpagpOnly = await prisma.pago.findMany({ select: { idpagp: true } })
     * 
    **/
    findMany<T extends pagoFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, pagoFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$pagoPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Pago.
     * @param {pagoCreateArgs} args - Arguments to create a Pago.
     * @example
     * // Create one Pago
     * const Pago = await prisma.pago.create({
     *   data: {
     *     // ... data to create a Pago
     *   }
     * })
     * 
    **/
    create<T extends pagoCreateArgs<ExtArgs>>(
      args: SelectSubset<T, pagoCreateArgs<ExtArgs>>
    ): Prisma__pagoClient<$Result.GetResult<Prisma.$pagoPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Pagos.
     *     @param {pagoCreateManyArgs} args - Arguments to create many Pagos.
     *     @example
     *     // Create many Pagos
     *     const pago = await prisma.pago.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends pagoCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, pagoCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Pago.
     * @param {pagoDeleteArgs} args - Arguments to delete one Pago.
     * @example
     * // Delete one Pago
     * const Pago = await prisma.pago.delete({
     *   where: {
     *     // ... filter to delete one Pago
     *   }
     * })
     * 
    **/
    delete<T extends pagoDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, pagoDeleteArgs<ExtArgs>>
    ): Prisma__pagoClient<$Result.GetResult<Prisma.$pagoPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Pago.
     * @param {pagoUpdateArgs} args - Arguments to update one Pago.
     * @example
     * // Update one Pago
     * const pago = await prisma.pago.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends pagoUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, pagoUpdateArgs<ExtArgs>>
    ): Prisma__pagoClient<$Result.GetResult<Prisma.$pagoPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Pagos.
     * @param {pagoDeleteManyArgs} args - Arguments to filter Pagos to delete.
     * @example
     * // Delete a few Pagos
     * const { count } = await prisma.pago.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends pagoDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, pagoDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Pagos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pagoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Pagos
     * const pago = await prisma.pago.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends pagoUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, pagoUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Pago.
     * @param {pagoUpsertArgs} args - Arguments to update or create a Pago.
     * @example
     * // Update or create a Pago
     * const pago = await prisma.pago.upsert({
     *   create: {
     *     // ... data to create a Pago
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Pago we want to update
     *   }
     * })
    **/
    upsert<T extends pagoUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, pagoUpsertArgs<ExtArgs>>
    ): Prisma__pagoClient<$Result.GetResult<Prisma.$pagoPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Pagos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pagoCountArgs} args - Arguments to filter Pagos to count.
     * @example
     * // Count the number of Pagos
     * const count = await prisma.pago.count({
     *   where: {
     *     // ... the filter for the Pagos we want to count
     *   }
     * })
    **/
    count<T extends pagoCountArgs>(
      args?: Subset<T, pagoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PagoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Pago.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PagoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PagoAggregateArgs>(args: Subset<T, PagoAggregateArgs>): Prisma.PrismaPromise<GetPagoAggregateType<T>>

    /**
     * Group by Pago.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pagoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends pagoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: pagoGroupByArgs['orderBy'] }
        : { orderBy?: pagoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, pagoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPagoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the pago model
   */
  readonly fields: pagoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for pago.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__pagoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    ordent<T extends pago$ordentArgs<ExtArgs> = {}>(args?: Subset<T, pago$ordentArgs<ExtArgs>>): Prisma__ordentClient<$Result.GetResult<Prisma.$ordentPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the pago model
   */ 
  interface pagoFieldRefs {
    readonly idpagp: FieldRef<"pago", 'Int'>
    readonly idot: FieldRef<"pago", 'Int'>
    readonly fecha: FieldRef<"pago", 'DateTime'>
    readonly preciof: FieldRef<"pago", 'Float'>
    readonly pago: FieldRef<"pago", 'Float'>
    readonly saldo: FieldRef<"pago", 'Float'>
    readonly des: FieldRef<"pago", 'String'>
    readonly comprobante: FieldRef<"pago", 'Bytes'>
  }
    

  // Custom InputTypes

  /**
   * pago findUnique
   */
  export type pagoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pago
     */
    select?: pagoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: pagoInclude<ExtArgs> | null
    /**
     * Filter, which pago to fetch.
     */
    where: pagoWhereUniqueInput
  }


  /**
   * pago findUniqueOrThrow
   */
  export type pagoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pago
     */
    select?: pagoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: pagoInclude<ExtArgs> | null
    /**
     * Filter, which pago to fetch.
     */
    where: pagoWhereUniqueInput
  }


  /**
   * pago findFirst
   */
  export type pagoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pago
     */
    select?: pagoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: pagoInclude<ExtArgs> | null
    /**
     * Filter, which pago to fetch.
     */
    where?: pagoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pagos to fetch.
     */
    orderBy?: pagoOrderByWithRelationInput | pagoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for pagos.
     */
    cursor?: pagoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pagos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pagos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of pagos.
     */
    distinct?: PagoScalarFieldEnum | PagoScalarFieldEnum[]
  }


  /**
   * pago findFirstOrThrow
   */
  export type pagoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pago
     */
    select?: pagoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: pagoInclude<ExtArgs> | null
    /**
     * Filter, which pago to fetch.
     */
    where?: pagoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pagos to fetch.
     */
    orderBy?: pagoOrderByWithRelationInput | pagoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for pagos.
     */
    cursor?: pagoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pagos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pagos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of pagos.
     */
    distinct?: PagoScalarFieldEnum | PagoScalarFieldEnum[]
  }


  /**
   * pago findMany
   */
  export type pagoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pago
     */
    select?: pagoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: pagoInclude<ExtArgs> | null
    /**
     * Filter, which pagos to fetch.
     */
    where?: pagoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pagos to fetch.
     */
    orderBy?: pagoOrderByWithRelationInput | pagoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing pagos.
     */
    cursor?: pagoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pagos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pagos.
     */
    skip?: number
    distinct?: PagoScalarFieldEnum | PagoScalarFieldEnum[]
  }


  /**
   * pago create
   */
  export type pagoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pago
     */
    select?: pagoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: pagoInclude<ExtArgs> | null
    /**
     * The data needed to create a pago.
     */
    data?: XOR<pagoCreateInput, pagoUncheckedCreateInput>
  }


  /**
   * pago createMany
   */
  export type pagoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many pagos.
     */
    data: pagoCreateManyInput | pagoCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * pago update
   */
  export type pagoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pago
     */
    select?: pagoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: pagoInclude<ExtArgs> | null
    /**
     * The data needed to update a pago.
     */
    data: XOR<pagoUpdateInput, pagoUncheckedUpdateInput>
    /**
     * Choose, which pago to update.
     */
    where: pagoWhereUniqueInput
  }


  /**
   * pago updateMany
   */
  export type pagoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update pagos.
     */
    data: XOR<pagoUpdateManyMutationInput, pagoUncheckedUpdateManyInput>
    /**
     * Filter which pagos to update
     */
    where?: pagoWhereInput
  }


  /**
   * pago upsert
   */
  export type pagoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pago
     */
    select?: pagoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: pagoInclude<ExtArgs> | null
    /**
     * The filter to search for the pago to update in case it exists.
     */
    where: pagoWhereUniqueInput
    /**
     * In case the pago found by the `where` argument doesn't exist, create a new pago with this data.
     */
    create: XOR<pagoCreateInput, pagoUncheckedCreateInput>
    /**
     * In case the pago was found with the provided `where` argument, update it with this data.
     */
    update: XOR<pagoUpdateInput, pagoUncheckedUpdateInput>
  }


  /**
   * pago delete
   */
  export type pagoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pago
     */
    select?: pagoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: pagoInclude<ExtArgs> | null
    /**
     * Filter which pago to delete.
     */
    where: pagoWhereUniqueInput
  }


  /**
   * pago deleteMany
   */
  export type pagoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which pagos to delete
     */
    where?: pagoWhereInput
  }


  /**
   * pago.ordent
   */
  export type pago$ordentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ordent
     */
    select?: ordentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ordentInclude<ExtArgs> | null
    where?: ordentWhereInput
  }


  /**
   * pago without action
   */
  export type pagoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pago
     */
    select?: pagoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: pagoInclude<ExtArgs> | null
  }



  /**
   * Model persona
   */

  export type AggregatePersona = {
    _count: PersonaCountAggregateOutputType | null
    _avg: PersonaAvgAggregateOutputType | null
    _sum: PersonaSumAggregateOutputType | null
    _min: PersonaMinAggregateOutputType | null
    _max: PersonaMaxAggregateOutputType | null
  }

  export type PersonaAvgAggregateOutputType = {
    idpe: number | null
  }

  export type PersonaSumAggregateOutputType = {
    idpe: number | null
  }

  export type PersonaMinAggregateOutputType = {
    idpe: number | null
    ci: string | null
    nombre: string | null
    ap: string | null
    am: string | null
    direccion: string | null
    email: string | null
    estado: boolean | null
    base64: string | null
  }

  export type PersonaMaxAggregateOutputType = {
    idpe: number | null
    ci: string | null
    nombre: string | null
    ap: string | null
    am: string | null
    direccion: string | null
    email: string | null
    estado: boolean | null
    base64: string | null
  }

  export type PersonaCountAggregateOutputType = {
    idpe: number
    ci: number
    nombre: number
    ap: number
    am: number
    direccion: number
    email: number
    estado: number
    base64: number
    _all: number
  }


  export type PersonaAvgAggregateInputType = {
    idpe?: true
  }

  export type PersonaSumAggregateInputType = {
    idpe?: true
  }

  export type PersonaMinAggregateInputType = {
    idpe?: true
    ci?: true
    nombre?: true
    ap?: true
    am?: true
    direccion?: true
    email?: true
    estado?: true
    base64?: true
  }

  export type PersonaMaxAggregateInputType = {
    idpe?: true
    ci?: true
    nombre?: true
    ap?: true
    am?: true
    direccion?: true
    email?: true
    estado?: true
    base64?: true
  }

  export type PersonaCountAggregateInputType = {
    idpe?: true
    ci?: true
    nombre?: true
    ap?: true
    am?: true
    direccion?: true
    email?: true
    estado?: true
    base64?: true
    _all?: true
  }

  export type PersonaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which persona to aggregate.
     */
    where?: personaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of personas to fetch.
     */
    orderBy?: personaOrderByWithRelationInput | personaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: personaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` personas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` personas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned personas
    **/
    _count?: true | PersonaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PersonaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PersonaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PersonaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PersonaMaxAggregateInputType
  }

  export type GetPersonaAggregateType<T extends PersonaAggregateArgs> = {
        [P in keyof T & keyof AggregatePersona]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePersona[P]>
      : GetScalarType<T[P], AggregatePersona[P]>
  }




  export type personaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: personaWhereInput
    orderBy?: personaOrderByWithAggregationInput | personaOrderByWithAggregationInput[]
    by: PersonaScalarFieldEnum[] | PersonaScalarFieldEnum
    having?: personaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PersonaCountAggregateInputType | true
    _avg?: PersonaAvgAggregateInputType
    _sum?: PersonaSumAggregateInputType
    _min?: PersonaMinAggregateInputType
    _max?: PersonaMaxAggregateInputType
  }

  export type PersonaGroupByOutputType = {
    idpe: number
    ci: string
    nombre: string
    ap: string
    am: string | null
    direccion: string | null
    email: string | null
    estado: boolean | null
    base64: string | null
    _count: PersonaCountAggregateOutputType | null
    _avg: PersonaAvgAggregateOutputType | null
    _sum: PersonaSumAggregateOutputType | null
    _min: PersonaMinAggregateOutputType | null
    _max: PersonaMaxAggregateOutputType | null
  }

  type GetPersonaGroupByPayload<T extends personaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PersonaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PersonaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PersonaGroupByOutputType[P]>
            : GetScalarType<T[P], PersonaGroupByOutputType[P]>
        }
      >
    >


  export type personaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idpe?: boolean
    ci?: boolean
    nombre?: boolean
    ap?: boolean
    am?: boolean
    direccion?: boolean
    email?: boolean
    estado?: boolean
    base64?: boolean
    cliente?: boolean | persona$clienteArgs<ExtArgs>
    empresa?: boolean | persona$empresaArgs<ExtArgs>
    proveedor?: boolean | persona$proveedorArgs<ExtArgs>
    telefono?: boolean | persona$telefonoArgs<ExtArgs>
    usuario?: boolean | persona$usuarioArgs<ExtArgs>
    _count?: boolean | PersonaCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["persona"]>

  export type personaSelectScalar = {
    idpe?: boolean
    ci?: boolean
    nombre?: boolean
    ap?: boolean
    am?: boolean
    direccion?: boolean
    email?: boolean
    estado?: boolean
    base64?: boolean
  }

  export type personaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cliente?: boolean | persona$clienteArgs<ExtArgs>
    empresa?: boolean | persona$empresaArgs<ExtArgs>
    proveedor?: boolean | persona$proveedorArgs<ExtArgs>
    telefono?: boolean | persona$telefonoArgs<ExtArgs>
    usuario?: boolean | persona$usuarioArgs<ExtArgs>
    _count?: boolean | PersonaCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $personaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "persona"
    objects: {
      cliente: Prisma.$clientePayload<ExtArgs>[]
      empresa: Prisma.$empresaPayload<ExtArgs>[]
      proveedor: Prisma.$proveedorPayload<ExtArgs>[]
      telefono: Prisma.$telefonoPayload<ExtArgs>[]
      usuario: Prisma.$usuarioPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      idpe: number
      ci: string
      nombre: string
      ap: string
      am: string | null
      direccion: string | null
      email: string | null
      estado: boolean | null
      base64: string | null
    }, ExtArgs["result"]["persona"]>
    composites: {}
  }


  type personaGetPayload<S extends boolean | null | undefined | personaDefaultArgs> = $Result.GetResult<Prisma.$personaPayload, S>

  type personaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<personaFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: PersonaCountAggregateInputType | true
    }

  export interface personaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['persona'], meta: { name: 'persona' } }
    /**
     * Find zero or one Persona that matches the filter.
     * @param {personaFindUniqueArgs} args - Arguments to find a Persona
     * @example
     * // Get one Persona
     * const persona = await prisma.persona.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends personaFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, personaFindUniqueArgs<ExtArgs>>
    ): Prisma__personaClient<$Result.GetResult<Prisma.$personaPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Persona that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {personaFindUniqueOrThrowArgs} args - Arguments to find a Persona
     * @example
     * // Get one Persona
     * const persona = await prisma.persona.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends personaFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, personaFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__personaClient<$Result.GetResult<Prisma.$personaPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Persona that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {personaFindFirstArgs} args - Arguments to find a Persona
     * @example
     * // Get one Persona
     * const persona = await prisma.persona.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends personaFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, personaFindFirstArgs<ExtArgs>>
    ): Prisma__personaClient<$Result.GetResult<Prisma.$personaPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Persona that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {personaFindFirstOrThrowArgs} args - Arguments to find a Persona
     * @example
     * // Get one Persona
     * const persona = await prisma.persona.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends personaFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, personaFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__personaClient<$Result.GetResult<Prisma.$personaPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Personas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {personaFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Personas
     * const personas = await prisma.persona.findMany()
     * 
     * // Get first 10 Personas
     * const personas = await prisma.persona.findMany({ take: 10 })
     * 
     * // Only select the `idpe`
     * const personaWithIdpeOnly = await prisma.persona.findMany({ select: { idpe: true } })
     * 
    **/
    findMany<T extends personaFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, personaFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$personaPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Persona.
     * @param {personaCreateArgs} args - Arguments to create a Persona.
     * @example
     * // Create one Persona
     * const Persona = await prisma.persona.create({
     *   data: {
     *     // ... data to create a Persona
     *   }
     * })
     * 
    **/
    create<T extends personaCreateArgs<ExtArgs>>(
      args: SelectSubset<T, personaCreateArgs<ExtArgs>>
    ): Prisma__personaClient<$Result.GetResult<Prisma.$personaPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Personas.
     *     @param {personaCreateManyArgs} args - Arguments to create many Personas.
     *     @example
     *     // Create many Personas
     *     const persona = await prisma.persona.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends personaCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, personaCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Persona.
     * @param {personaDeleteArgs} args - Arguments to delete one Persona.
     * @example
     * // Delete one Persona
     * const Persona = await prisma.persona.delete({
     *   where: {
     *     // ... filter to delete one Persona
     *   }
     * })
     * 
    **/
    delete<T extends personaDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, personaDeleteArgs<ExtArgs>>
    ): Prisma__personaClient<$Result.GetResult<Prisma.$personaPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Persona.
     * @param {personaUpdateArgs} args - Arguments to update one Persona.
     * @example
     * // Update one Persona
     * const persona = await prisma.persona.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends personaUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, personaUpdateArgs<ExtArgs>>
    ): Prisma__personaClient<$Result.GetResult<Prisma.$personaPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Personas.
     * @param {personaDeleteManyArgs} args - Arguments to filter Personas to delete.
     * @example
     * // Delete a few Personas
     * const { count } = await prisma.persona.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends personaDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, personaDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Personas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {personaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Personas
     * const persona = await prisma.persona.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends personaUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, personaUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Persona.
     * @param {personaUpsertArgs} args - Arguments to update or create a Persona.
     * @example
     * // Update or create a Persona
     * const persona = await prisma.persona.upsert({
     *   create: {
     *     // ... data to create a Persona
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Persona we want to update
     *   }
     * })
    **/
    upsert<T extends personaUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, personaUpsertArgs<ExtArgs>>
    ): Prisma__personaClient<$Result.GetResult<Prisma.$personaPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Personas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {personaCountArgs} args - Arguments to filter Personas to count.
     * @example
     * // Count the number of Personas
     * const count = await prisma.persona.count({
     *   where: {
     *     // ... the filter for the Personas we want to count
     *   }
     * })
    **/
    count<T extends personaCountArgs>(
      args?: Subset<T, personaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PersonaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Persona.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PersonaAggregateArgs>(args: Subset<T, PersonaAggregateArgs>): Prisma.PrismaPromise<GetPersonaAggregateType<T>>

    /**
     * Group by Persona.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {personaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends personaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: personaGroupByArgs['orderBy'] }
        : { orderBy?: personaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, personaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPersonaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the persona model
   */
  readonly fields: personaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for persona.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__personaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    cliente<T extends persona$clienteArgs<ExtArgs> = {}>(args?: Subset<T, persona$clienteArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$clientePayload<ExtArgs>, T, 'findMany'> | Null>;

    empresa<T extends persona$empresaArgs<ExtArgs> = {}>(args?: Subset<T, persona$empresaArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$empresaPayload<ExtArgs>, T, 'findMany'> | Null>;

    proveedor<T extends persona$proveedorArgs<ExtArgs> = {}>(args?: Subset<T, persona$proveedorArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$proveedorPayload<ExtArgs>, T, 'findMany'> | Null>;

    telefono<T extends persona$telefonoArgs<ExtArgs> = {}>(args?: Subset<T, persona$telefonoArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$telefonoPayload<ExtArgs>, T, 'findMany'> | Null>;

    usuario<T extends persona$usuarioArgs<ExtArgs> = {}>(args?: Subset<T, persona$usuarioArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$usuarioPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the persona model
   */ 
  interface personaFieldRefs {
    readonly idpe: FieldRef<"persona", 'Int'>
    readonly ci: FieldRef<"persona", 'String'>
    readonly nombre: FieldRef<"persona", 'String'>
    readonly ap: FieldRef<"persona", 'String'>
    readonly am: FieldRef<"persona", 'String'>
    readonly direccion: FieldRef<"persona", 'String'>
    readonly email: FieldRef<"persona", 'String'>
    readonly estado: FieldRef<"persona", 'Boolean'>
    readonly base64: FieldRef<"persona", 'String'>
  }
    

  // Custom InputTypes

  /**
   * persona findUnique
   */
  export type personaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the persona
     */
    select?: personaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: personaInclude<ExtArgs> | null
    /**
     * Filter, which persona to fetch.
     */
    where: personaWhereUniqueInput
  }


  /**
   * persona findUniqueOrThrow
   */
  export type personaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the persona
     */
    select?: personaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: personaInclude<ExtArgs> | null
    /**
     * Filter, which persona to fetch.
     */
    where: personaWhereUniqueInput
  }


  /**
   * persona findFirst
   */
  export type personaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the persona
     */
    select?: personaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: personaInclude<ExtArgs> | null
    /**
     * Filter, which persona to fetch.
     */
    where?: personaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of personas to fetch.
     */
    orderBy?: personaOrderByWithRelationInput | personaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for personas.
     */
    cursor?: personaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` personas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` personas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of personas.
     */
    distinct?: PersonaScalarFieldEnum | PersonaScalarFieldEnum[]
  }


  /**
   * persona findFirstOrThrow
   */
  export type personaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the persona
     */
    select?: personaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: personaInclude<ExtArgs> | null
    /**
     * Filter, which persona to fetch.
     */
    where?: personaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of personas to fetch.
     */
    orderBy?: personaOrderByWithRelationInput | personaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for personas.
     */
    cursor?: personaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` personas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` personas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of personas.
     */
    distinct?: PersonaScalarFieldEnum | PersonaScalarFieldEnum[]
  }


  /**
   * persona findMany
   */
  export type personaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the persona
     */
    select?: personaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: personaInclude<ExtArgs> | null
    /**
     * Filter, which personas to fetch.
     */
    where?: personaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of personas to fetch.
     */
    orderBy?: personaOrderByWithRelationInput | personaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing personas.
     */
    cursor?: personaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` personas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` personas.
     */
    skip?: number
    distinct?: PersonaScalarFieldEnum | PersonaScalarFieldEnum[]
  }


  /**
   * persona create
   */
  export type personaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the persona
     */
    select?: personaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: personaInclude<ExtArgs> | null
    /**
     * The data needed to create a persona.
     */
    data: XOR<personaCreateInput, personaUncheckedCreateInput>
  }


  /**
   * persona createMany
   */
  export type personaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many personas.
     */
    data: personaCreateManyInput | personaCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * persona update
   */
  export type personaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the persona
     */
    select?: personaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: personaInclude<ExtArgs> | null
    /**
     * The data needed to update a persona.
     */
    data: XOR<personaUpdateInput, personaUncheckedUpdateInput>
    /**
     * Choose, which persona to update.
     */
    where: personaWhereUniqueInput
  }


  /**
   * persona updateMany
   */
  export type personaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update personas.
     */
    data: XOR<personaUpdateManyMutationInput, personaUncheckedUpdateManyInput>
    /**
     * Filter which personas to update
     */
    where?: personaWhereInput
  }


  /**
   * persona upsert
   */
  export type personaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the persona
     */
    select?: personaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: personaInclude<ExtArgs> | null
    /**
     * The filter to search for the persona to update in case it exists.
     */
    where: personaWhereUniqueInput
    /**
     * In case the persona found by the `where` argument doesn't exist, create a new persona with this data.
     */
    create: XOR<personaCreateInput, personaUncheckedCreateInput>
    /**
     * In case the persona was found with the provided `where` argument, update it with this data.
     */
    update: XOR<personaUpdateInput, personaUncheckedUpdateInput>
  }


  /**
   * persona delete
   */
  export type personaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the persona
     */
    select?: personaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: personaInclude<ExtArgs> | null
    /**
     * Filter which persona to delete.
     */
    where: personaWhereUniqueInput
  }


  /**
   * persona deleteMany
   */
  export type personaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which personas to delete
     */
    where?: personaWhereInput
  }


  /**
   * persona.cliente
   */
  export type persona$clienteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cliente
     */
    select?: clienteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: clienteInclude<ExtArgs> | null
    where?: clienteWhereInput
    orderBy?: clienteOrderByWithRelationInput | clienteOrderByWithRelationInput[]
    cursor?: clienteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClienteScalarFieldEnum | ClienteScalarFieldEnum[]
  }


  /**
   * persona.empresa
   */
  export type persona$empresaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the empresa
     */
    select?: empresaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: empresaInclude<ExtArgs> | null
    where?: empresaWhereInput
    orderBy?: empresaOrderByWithRelationInput | empresaOrderByWithRelationInput[]
    cursor?: empresaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmpresaScalarFieldEnum | EmpresaScalarFieldEnum[]
  }


  /**
   * persona.proveedor
   */
  export type persona$proveedorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the proveedor
     */
    select?: proveedorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: proveedorInclude<ExtArgs> | null
    where?: proveedorWhereInput
    orderBy?: proveedorOrderByWithRelationInput | proveedorOrderByWithRelationInput[]
    cursor?: proveedorWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProveedorScalarFieldEnum | ProveedorScalarFieldEnum[]
  }


  /**
   * persona.telefono
   */
  export type persona$telefonoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the telefono
     */
    select?: telefonoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: telefonoInclude<ExtArgs> | null
    where?: telefonoWhereInput
    orderBy?: telefonoOrderByWithRelationInput | telefonoOrderByWithRelationInput[]
    cursor?: telefonoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TelefonoScalarFieldEnum | TelefonoScalarFieldEnum[]
  }


  /**
   * persona.usuario
   */
  export type persona$usuarioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usuario
     */
    select?: usuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: usuarioInclude<ExtArgs> | null
    where?: usuarioWhereInput
    orderBy?: usuarioOrderByWithRelationInput | usuarioOrderByWithRelationInput[]
    cursor?: usuarioWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UsuarioScalarFieldEnum | UsuarioScalarFieldEnum[]
  }


  /**
   * persona without action
   */
  export type personaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the persona
     */
    select?: personaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: personaInclude<ExtArgs> | null
  }



  /**
   * Model producto
   */

  export type AggregateProducto = {
    _count: ProductoCountAggregateOutputType | null
    _avg: ProductoAvgAggregateOutputType | null
    _sum: ProductoSumAggregateOutputType | null
    _min: ProductoMinAggregateOutputType | null
    _max: ProductoMaxAggregateOutputType | null
  }

  export type ProductoAvgAggregateOutputType = {
    idpro: number | null
    preciov: number | null
    precioc: number | null
    cantidad: number | null
    idmar: number | null
    ranking: number | null
  }

  export type ProductoSumAggregateOutputType = {
    idpro: number | null
    preciov: number | null
    precioc: number | null
    cantidad: number | null
    idmar: number | null
    ranking: number | null
  }

  export type ProductoMinAggregateOutputType = {
    idpro: number | null
    nom: string | null
    tam: string | null
    des: string | null
    preciov: number | null
    precioc: number | null
    cantidad: number | null
    foto: Buffer | null
    idmar: number | null
    estado: boolean | null
    base64: string | null
    ranking: number | null
  }

  export type ProductoMaxAggregateOutputType = {
    idpro: number | null
    nom: string | null
    tam: string | null
    des: string | null
    preciov: number | null
    precioc: number | null
    cantidad: number | null
    foto: Buffer | null
    idmar: number | null
    estado: boolean | null
    base64: string | null
    ranking: number | null
  }

  export type ProductoCountAggregateOutputType = {
    idpro: number
    nom: number
    tam: number
    des: number
    preciov: number
    precioc: number
    cantidad: number
    foto: number
    idmar: number
    estado: number
    base64: number
    ranking: number
    _all: number
  }


  export type ProductoAvgAggregateInputType = {
    idpro?: true
    preciov?: true
    precioc?: true
    cantidad?: true
    idmar?: true
    ranking?: true
  }

  export type ProductoSumAggregateInputType = {
    idpro?: true
    preciov?: true
    precioc?: true
    cantidad?: true
    idmar?: true
    ranking?: true
  }

  export type ProductoMinAggregateInputType = {
    idpro?: true
    nom?: true
    tam?: true
    des?: true
    preciov?: true
    precioc?: true
    cantidad?: true
    foto?: true
    idmar?: true
    estado?: true
    base64?: true
    ranking?: true
  }

  export type ProductoMaxAggregateInputType = {
    idpro?: true
    nom?: true
    tam?: true
    des?: true
    preciov?: true
    precioc?: true
    cantidad?: true
    foto?: true
    idmar?: true
    estado?: true
    base64?: true
    ranking?: true
  }

  export type ProductoCountAggregateInputType = {
    idpro?: true
    nom?: true
    tam?: true
    des?: true
    preciov?: true
    precioc?: true
    cantidad?: true
    foto?: true
    idmar?: true
    estado?: true
    base64?: true
    ranking?: true
    _all?: true
  }

  export type ProductoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which producto to aggregate.
     */
    where?: productoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of productos to fetch.
     */
    orderBy?: productoOrderByWithRelationInput | productoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: productoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` productos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` productos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned productos
    **/
    _count?: true | ProductoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductoMaxAggregateInputType
  }

  export type GetProductoAggregateType<T extends ProductoAggregateArgs> = {
        [P in keyof T & keyof AggregateProducto]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProducto[P]>
      : GetScalarType<T[P], AggregateProducto[P]>
  }




  export type productoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: productoWhereInput
    orderBy?: productoOrderByWithAggregationInput | productoOrderByWithAggregationInput[]
    by: ProductoScalarFieldEnum[] | ProductoScalarFieldEnum
    having?: productoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductoCountAggregateInputType | true
    _avg?: ProductoAvgAggregateInputType
    _sum?: ProductoSumAggregateInputType
    _min?: ProductoMinAggregateInputType
    _max?: ProductoMaxAggregateInputType
  }

  export type ProductoGroupByOutputType = {
    idpro: number
    nom: string | null
    tam: string | null
    des: string | null
    preciov: number | null
    precioc: number | null
    cantidad: number | null
    foto: Buffer | null
    idmar: number | null
    estado: boolean | null
    base64: string | null
    ranking: number | null
    _count: ProductoCountAggregateOutputType | null
    _avg: ProductoAvgAggregateOutputType | null
    _sum: ProductoSumAggregateOutputType | null
    _min: ProductoMinAggregateOutputType | null
    _max: ProductoMaxAggregateOutputType | null
  }

  type GetProductoGroupByPayload<T extends productoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductoGroupByOutputType[P]>
            : GetScalarType<T[P], ProductoGroupByOutputType[P]>
        }
      >
    >


  export type productoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idpro?: boolean
    nom?: boolean
    tam?: boolean
    des?: boolean
    preciov?: boolean
    precioc?: boolean
    cantidad?: boolean
    foto?: boolean
    idmar?: boolean
    estado?: boolean
    base64?: boolean
    ranking?: boolean
    detcot?: boolean | producto$detcotArgs<ExtArgs>
    detot?: boolean | producto$detotArgs<ExtArgs>
    marca?: boolean | producto$marcaArgs<ExtArgs>
    _count?: boolean | ProductoCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["producto"]>

  export type productoSelectScalar = {
    idpro?: boolean
    nom?: boolean
    tam?: boolean
    des?: boolean
    preciov?: boolean
    precioc?: boolean
    cantidad?: boolean
    foto?: boolean
    idmar?: boolean
    estado?: boolean
    base64?: boolean
    ranking?: boolean
  }

  export type productoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    detcot?: boolean | producto$detcotArgs<ExtArgs>
    detot?: boolean | producto$detotArgs<ExtArgs>
    marca?: boolean | producto$marcaArgs<ExtArgs>
    _count?: boolean | ProductoCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $productoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "producto"
    objects: {
      detcot: Prisma.$detcotPayload<ExtArgs>[]
      detot: Prisma.$detotPayload<ExtArgs>[]
      marca: Prisma.$marcaPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      idpro: number
      nom: string | null
      tam: string | null
      des: string | null
      preciov: number | null
      precioc: number | null
      cantidad: number | null
      foto: Buffer | null
      idmar: number | null
      estado: boolean | null
      base64: string | null
      ranking: number | null
    }, ExtArgs["result"]["producto"]>
    composites: {}
  }


  type productoGetPayload<S extends boolean | null | undefined | productoDefaultArgs> = $Result.GetResult<Prisma.$productoPayload, S>

  type productoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<productoFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: ProductoCountAggregateInputType | true
    }

  export interface productoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['producto'], meta: { name: 'producto' } }
    /**
     * Find zero or one Producto that matches the filter.
     * @param {productoFindUniqueArgs} args - Arguments to find a Producto
     * @example
     * // Get one Producto
     * const producto = await prisma.producto.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends productoFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, productoFindUniqueArgs<ExtArgs>>
    ): Prisma__productoClient<$Result.GetResult<Prisma.$productoPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Producto that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {productoFindUniqueOrThrowArgs} args - Arguments to find a Producto
     * @example
     * // Get one Producto
     * const producto = await prisma.producto.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends productoFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, productoFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__productoClient<$Result.GetResult<Prisma.$productoPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Producto that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {productoFindFirstArgs} args - Arguments to find a Producto
     * @example
     * // Get one Producto
     * const producto = await prisma.producto.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends productoFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, productoFindFirstArgs<ExtArgs>>
    ): Prisma__productoClient<$Result.GetResult<Prisma.$productoPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Producto that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {productoFindFirstOrThrowArgs} args - Arguments to find a Producto
     * @example
     * // Get one Producto
     * const producto = await prisma.producto.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends productoFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, productoFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__productoClient<$Result.GetResult<Prisma.$productoPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Productos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {productoFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Productos
     * const productos = await prisma.producto.findMany()
     * 
     * // Get first 10 Productos
     * const productos = await prisma.producto.findMany({ take: 10 })
     * 
     * // Only select the `idpro`
     * const productoWithIdproOnly = await prisma.producto.findMany({ select: { idpro: true } })
     * 
    **/
    findMany<T extends productoFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, productoFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$productoPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Producto.
     * @param {productoCreateArgs} args - Arguments to create a Producto.
     * @example
     * // Create one Producto
     * const Producto = await prisma.producto.create({
     *   data: {
     *     // ... data to create a Producto
     *   }
     * })
     * 
    **/
    create<T extends productoCreateArgs<ExtArgs>>(
      args: SelectSubset<T, productoCreateArgs<ExtArgs>>
    ): Prisma__productoClient<$Result.GetResult<Prisma.$productoPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Productos.
     *     @param {productoCreateManyArgs} args - Arguments to create many Productos.
     *     @example
     *     // Create many Productos
     *     const producto = await prisma.producto.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends productoCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, productoCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Producto.
     * @param {productoDeleteArgs} args - Arguments to delete one Producto.
     * @example
     * // Delete one Producto
     * const Producto = await prisma.producto.delete({
     *   where: {
     *     // ... filter to delete one Producto
     *   }
     * })
     * 
    **/
    delete<T extends productoDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, productoDeleteArgs<ExtArgs>>
    ): Prisma__productoClient<$Result.GetResult<Prisma.$productoPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Producto.
     * @param {productoUpdateArgs} args - Arguments to update one Producto.
     * @example
     * // Update one Producto
     * const producto = await prisma.producto.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends productoUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, productoUpdateArgs<ExtArgs>>
    ): Prisma__productoClient<$Result.GetResult<Prisma.$productoPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Productos.
     * @param {productoDeleteManyArgs} args - Arguments to filter Productos to delete.
     * @example
     * // Delete a few Productos
     * const { count } = await prisma.producto.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends productoDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, productoDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Productos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {productoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Productos
     * const producto = await prisma.producto.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends productoUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, productoUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Producto.
     * @param {productoUpsertArgs} args - Arguments to update or create a Producto.
     * @example
     * // Update or create a Producto
     * const producto = await prisma.producto.upsert({
     *   create: {
     *     // ... data to create a Producto
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Producto we want to update
     *   }
     * })
    **/
    upsert<T extends productoUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, productoUpsertArgs<ExtArgs>>
    ): Prisma__productoClient<$Result.GetResult<Prisma.$productoPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Productos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {productoCountArgs} args - Arguments to filter Productos to count.
     * @example
     * // Count the number of Productos
     * const count = await prisma.producto.count({
     *   where: {
     *     // ... the filter for the Productos we want to count
     *   }
     * })
    **/
    count<T extends productoCountArgs>(
      args?: Subset<T, productoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Producto.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductoAggregateArgs>(args: Subset<T, ProductoAggregateArgs>): Prisma.PrismaPromise<GetProductoAggregateType<T>>

    /**
     * Group by Producto.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {productoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends productoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: productoGroupByArgs['orderBy'] }
        : { orderBy?: productoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, productoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the producto model
   */
  readonly fields: productoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for producto.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__productoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    detcot<T extends producto$detcotArgs<ExtArgs> = {}>(args?: Subset<T, producto$detcotArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$detcotPayload<ExtArgs>, T, 'findMany'> | Null>;

    detot<T extends producto$detotArgs<ExtArgs> = {}>(args?: Subset<T, producto$detotArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$detotPayload<ExtArgs>, T, 'findMany'> | Null>;

    marca<T extends producto$marcaArgs<ExtArgs> = {}>(args?: Subset<T, producto$marcaArgs<ExtArgs>>): Prisma__marcaClient<$Result.GetResult<Prisma.$marcaPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the producto model
   */ 
  interface productoFieldRefs {
    readonly idpro: FieldRef<"producto", 'Int'>
    readonly nom: FieldRef<"producto", 'String'>
    readonly tam: FieldRef<"producto", 'String'>
    readonly des: FieldRef<"producto", 'String'>
    readonly preciov: FieldRef<"producto", 'Float'>
    readonly precioc: FieldRef<"producto", 'Float'>
    readonly cantidad: FieldRef<"producto", 'Int'>
    readonly foto: FieldRef<"producto", 'Bytes'>
    readonly idmar: FieldRef<"producto", 'Int'>
    readonly estado: FieldRef<"producto", 'Boolean'>
    readonly base64: FieldRef<"producto", 'String'>
    readonly ranking: FieldRef<"producto", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * producto findUnique
   */
  export type productoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the producto
     */
    select?: productoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: productoInclude<ExtArgs> | null
    /**
     * Filter, which producto to fetch.
     */
    where: productoWhereUniqueInput
  }


  /**
   * producto findUniqueOrThrow
   */
  export type productoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the producto
     */
    select?: productoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: productoInclude<ExtArgs> | null
    /**
     * Filter, which producto to fetch.
     */
    where: productoWhereUniqueInput
  }


  /**
   * producto findFirst
   */
  export type productoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the producto
     */
    select?: productoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: productoInclude<ExtArgs> | null
    /**
     * Filter, which producto to fetch.
     */
    where?: productoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of productos to fetch.
     */
    orderBy?: productoOrderByWithRelationInput | productoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for productos.
     */
    cursor?: productoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` productos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` productos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of productos.
     */
    distinct?: ProductoScalarFieldEnum | ProductoScalarFieldEnum[]
  }


  /**
   * producto findFirstOrThrow
   */
  export type productoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the producto
     */
    select?: productoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: productoInclude<ExtArgs> | null
    /**
     * Filter, which producto to fetch.
     */
    where?: productoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of productos to fetch.
     */
    orderBy?: productoOrderByWithRelationInput | productoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for productos.
     */
    cursor?: productoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` productos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` productos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of productos.
     */
    distinct?: ProductoScalarFieldEnum | ProductoScalarFieldEnum[]
  }


  /**
   * producto findMany
   */
  export type productoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the producto
     */
    select?: productoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: productoInclude<ExtArgs> | null
    /**
     * Filter, which productos to fetch.
     */
    where?: productoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of productos to fetch.
     */
    orderBy?: productoOrderByWithRelationInput | productoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing productos.
     */
    cursor?: productoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` productos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` productos.
     */
    skip?: number
    distinct?: ProductoScalarFieldEnum | ProductoScalarFieldEnum[]
  }


  /**
   * producto create
   */
  export type productoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the producto
     */
    select?: productoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: productoInclude<ExtArgs> | null
    /**
     * The data needed to create a producto.
     */
    data?: XOR<productoCreateInput, productoUncheckedCreateInput>
  }


  /**
   * producto createMany
   */
  export type productoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many productos.
     */
    data: productoCreateManyInput | productoCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * producto update
   */
  export type productoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the producto
     */
    select?: productoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: productoInclude<ExtArgs> | null
    /**
     * The data needed to update a producto.
     */
    data: XOR<productoUpdateInput, productoUncheckedUpdateInput>
    /**
     * Choose, which producto to update.
     */
    where: productoWhereUniqueInput
  }


  /**
   * producto updateMany
   */
  export type productoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update productos.
     */
    data: XOR<productoUpdateManyMutationInput, productoUncheckedUpdateManyInput>
    /**
     * Filter which productos to update
     */
    where?: productoWhereInput
  }


  /**
   * producto upsert
   */
  export type productoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the producto
     */
    select?: productoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: productoInclude<ExtArgs> | null
    /**
     * The filter to search for the producto to update in case it exists.
     */
    where: productoWhereUniqueInput
    /**
     * In case the producto found by the `where` argument doesn't exist, create a new producto with this data.
     */
    create: XOR<productoCreateInput, productoUncheckedCreateInput>
    /**
     * In case the producto was found with the provided `where` argument, update it with this data.
     */
    update: XOR<productoUpdateInput, productoUncheckedUpdateInput>
  }


  /**
   * producto delete
   */
  export type productoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the producto
     */
    select?: productoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: productoInclude<ExtArgs> | null
    /**
     * Filter which producto to delete.
     */
    where: productoWhereUniqueInput
  }


  /**
   * producto deleteMany
   */
  export type productoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which productos to delete
     */
    where?: productoWhereInput
  }


  /**
   * producto.detcot
   */
  export type producto$detcotArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the detcot
     */
    select?: detcotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: detcotInclude<ExtArgs> | null
    where?: detcotWhereInput
    orderBy?: detcotOrderByWithRelationInput | detcotOrderByWithRelationInput[]
    cursor?: detcotWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DetcotScalarFieldEnum | DetcotScalarFieldEnum[]
  }


  /**
   * producto.detot
   */
  export type producto$detotArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the detot
     */
    select?: detotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: detotInclude<ExtArgs> | null
    where?: detotWhereInput
    orderBy?: detotOrderByWithRelationInput | detotOrderByWithRelationInput[]
    cursor?: detotWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DetotScalarFieldEnum | DetotScalarFieldEnum[]
  }


  /**
   * producto.marca
   */
  export type producto$marcaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the marca
     */
    select?: marcaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: marcaInclude<ExtArgs> | null
    where?: marcaWhereInput
  }


  /**
   * producto without action
   */
  export type productoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the producto
     */
    select?: productoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: productoInclude<ExtArgs> | null
  }



  /**
   * Model proveedor
   */

  export type AggregateProveedor = {
    _count: ProveedorCountAggregateOutputType | null
    _avg: ProveedorAvgAggregateOutputType | null
    _sum: ProveedorSumAggregateOutputType | null
    _min: ProveedorMinAggregateOutputType | null
    _max: ProveedorMaxAggregateOutputType | null
  }

  export type ProveedorAvgAggregateOutputType = {
    idprov: number | null
    idpe: number | null
  }

  export type ProveedorSumAggregateOutputType = {
    idprov: number | null
    idpe: number | null
  }

  export type ProveedorMinAggregateOutputType = {
    idprov: number | null
    nom: string | null
    dir: string | null
    dep: string | null
    logo: Buffer | null
    idpe: number | null
    estado: boolean | null
    nit: string | null
  }

  export type ProveedorMaxAggregateOutputType = {
    idprov: number | null
    nom: string | null
    dir: string | null
    dep: string | null
    logo: Buffer | null
    idpe: number | null
    estado: boolean | null
    nit: string | null
  }

  export type ProveedorCountAggregateOutputType = {
    idprov: number
    nom: number
    dir: number
    dep: number
    logo: number
    idpe: number
    estado: number
    nit: number
    _all: number
  }


  export type ProveedorAvgAggregateInputType = {
    idprov?: true
    idpe?: true
  }

  export type ProveedorSumAggregateInputType = {
    idprov?: true
    idpe?: true
  }

  export type ProveedorMinAggregateInputType = {
    idprov?: true
    nom?: true
    dir?: true
    dep?: true
    logo?: true
    idpe?: true
    estado?: true
    nit?: true
  }

  export type ProveedorMaxAggregateInputType = {
    idprov?: true
    nom?: true
    dir?: true
    dep?: true
    logo?: true
    idpe?: true
    estado?: true
    nit?: true
  }

  export type ProveedorCountAggregateInputType = {
    idprov?: true
    nom?: true
    dir?: true
    dep?: true
    logo?: true
    idpe?: true
    estado?: true
    nit?: true
    _all?: true
  }

  export type ProveedorAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which proveedor to aggregate.
     */
    where?: proveedorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of proveedors to fetch.
     */
    orderBy?: proveedorOrderByWithRelationInput | proveedorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: proveedorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` proveedors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` proveedors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned proveedors
    **/
    _count?: true | ProveedorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProveedorAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProveedorSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProveedorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProveedorMaxAggregateInputType
  }

  export type GetProveedorAggregateType<T extends ProveedorAggregateArgs> = {
        [P in keyof T & keyof AggregateProveedor]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProveedor[P]>
      : GetScalarType<T[P], AggregateProveedor[P]>
  }




  export type proveedorGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: proveedorWhereInput
    orderBy?: proveedorOrderByWithAggregationInput | proveedorOrderByWithAggregationInput[]
    by: ProveedorScalarFieldEnum[] | ProveedorScalarFieldEnum
    having?: proveedorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProveedorCountAggregateInputType | true
    _avg?: ProveedorAvgAggregateInputType
    _sum?: ProveedorSumAggregateInputType
    _min?: ProveedorMinAggregateInputType
    _max?: ProveedorMaxAggregateInputType
  }

  export type ProveedorGroupByOutputType = {
    idprov: number
    nom: string | null
    dir: string | null
    dep: string | null
    logo: Buffer | null
    idpe: number | null
    estado: boolean | null
    nit: string | null
    _count: ProveedorCountAggregateOutputType | null
    _avg: ProveedorAvgAggregateOutputType | null
    _sum: ProveedorSumAggregateOutputType | null
    _min: ProveedorMinAggregateOutputType | null
    _max: ProveedorMaxAggregateOutputType | null
  }

  type GetProveedorGroupByPayload<T extends proveedorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProveedorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProveedorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProveedorGroupByOutputType[P]>
            : GetScalarType<T[P], ProveedorGroupByOutputType[P]>
        }
      >
    >


  export type proveedorSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idprov?: boolean
    nom?: boolean
    dir?: boolean
    dep?: boolean
    logo?: boolean
    idpe?: boolean
    estado?: boolean
    nit?: boolean
    inventario?: boolean | proveedor$inventarioArgs<ExtArgs>
    persona?: boolean | proveedor$personaArgs<ExtArgs>
    _count?: boolean | ProveedorCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["proveedor"]>

  export type proveedorSelectScalar = {
    idprov?: boolean
    nom?: boolean
    dir?: boolean
    dep?: boolean
    logo?: boolean
    idpe?: boolean
    estado?: boolean
    nit?: boolean
  }

  export type proveedorInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    inventario?: boolean | proveedor$inventarioArgs<ExtArgs>
    persona?: boolean | proveedor$personaArgs<ExtArgs>
    _count?: boolean | ProveedorCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $proveedorPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "proveedor"
    objects: {
      inventario: Prisma.$inventarioPayload<ExtArgs>[]
      persona: Prisma.$personaPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      idprov: number
      nom: string | null
      dir: string | null
      dep: string | null
      logo: Buffer | null
      idpe: number | null
      estado: boolean | null
      nit: string | null
    }, ExtArgs["result"]["proveedor"]>
    composites: {}
  }


  type proveedorGetPayload<S extends boolean | null | undefined | proveedorDefaultArgs> = $Result.GetResult<Prisma.$proveedorPayload, S>

  type proveedorCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<proveedorFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: ProveedorCountAggregateInputType | true
    }

  export interface proveedorDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['proveedor'], meta: { name: 'proveedor' } }
    /**
     * Find zero or one Proveedor that matches the filter.
     * @param {proveedorFindUniqueArgs} args - Arguments to find a Proveedor
     * @example
     * // Get one Proveedor
     * const proveedor = await prisma.proveedor.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends proveedorFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, proveedorFindUniqueArgs<ExtArgs>>
    ): Prisma__proveedorClient<$Result.GetResult<Prisma.$proveedorPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Proveedor that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {proveedorFindUniqueOrThrowArgs} args - Arguments to find a Proveedor
     * @example
     * // Get one Proveedor
     * const proveedor = await prisma.proveedor.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends proveedorFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, proveedorFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__proveedorClient<$Result.GetResult<Prisma.$proveedorPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Proveedor that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {proveedorFindFirstArgs} args - Arguments to find a Proveedor
     * @example
     * // Get one Proveedor
     * const proveedor = await prisma.proveedor.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends proveedorFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, proveedorFindFirstArgs<ExtArgs>>
    ): Prisma__proveedorClient<$Result.GetResult<Prisma.$proveedorPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Proveedor that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {proveedorFindFirstOrThrowArgs} args - Arguments to find a Proveedor
     * @example
     * // Get one Proveedor
     * const proveedor = await prisma.proveedor.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends proveedorFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, proveedorFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__proveedorClient<$Result.GetResult<Prisma.$proveedorPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Proveedors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {proveedorFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Proveedors
     * const proveedors = await prisma.proveedor.findMany()
     * 
     * // Get first 10 Proveedors
     * const proveedors = await prisma.proveedor.findMany({ take: 10 })
     * 
     * // Only select the `idprov`
     * const proveedorWithIdprovOnly = await prisma.proveedor.findMany({ select: { idprov: true } })
     * 
    **/
    findMany<T extends proveedorFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, proveedorFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$proveedorPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Proveedor.
     * @param {proveedorCreateArgs} args - Arguments to create a Proveedor.
     * @example
     * // Create one Proveedor
     * const Proveedor = await prisma.proveedor.create({
     *   data: {
     *     // ... data to create a Proveedor
     *   }
     * })
     * 
    **/
    create<T extends proveedorCreateArgs<ExtArgs>>(
      args: SelectSubset<T, proveedorCreateArgs<ExtArgs>>
    ): Prisma__proveedorClient<$Result.GetResult<Prisma.$proveedorPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Proveedors.
     *     @param {proveedorCreateManyArgs} args - Arguments to create many Proveedors.
     *     @example
     *     // Create many Proveedors
     *     const proveedor = await prisma.proveedor.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends proveedorCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, proveedorCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Proveedor.
     * @param {proveedorDeleteArgs} args - Arguments to delete one Proveedor.
     * @example
     * // Delete one Proveedor
     * const Proveedor = await prisma.proveedor.delete({
     *   where: {
     *     // ... filter to delete one Proveedor
     *   }
     * })
     * 
    **/
    delete<T extends proveedorDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, proveedorDeleteArgs<ExtArgs>>
    ): Prisma__proveedorClient<$Result.GetResult<Prisma.$proveedorPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Proveedor.
     * @param {proveedorUpdateArgs} args - Arguments to update one Proveedor.
     * @example
     * // Update one Proveedor
     * const proveedor = await prisma.proveedor.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends proveedorUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, proveedorUpdateArgs<ExtArgs>>
    ): Prisma__proveedorClient<$Result.GetResult<Prisma.$proveedorPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Proveedors.
     * @param {proveedorDeleteManyArgs} args - Arguments to filter Proveedors to delete.
     * @example
     * // Delete a few Proveedors
     * const { count } = await prisma.proveedor.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends proveedorDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, proveedorDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Proveedors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {proveedorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Proveedors
     * const proveedor = await prisma.proveedor.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends proveedorUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, proveedorUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Proveedor.
     * @param {proveedorUpsertArgs} args - Arguments to update or create a Proveedor.
     * @example
     * // Update or create a Proveedor
     * const proveedor = await prisma.proveedor.upsert({
     *   create: {
     *     // ... data to create a Proveedor
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Proveedor we want to update
     *   }
     * })
    **/
    upsert<T extends proveedorUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, proveedorUpsertArgs<ExtArgs>>
    ): Prisma__proveedorClient<$Result.GetResult<Prisma.$proveedorPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Proveedors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {proveedorCountArgs} args - Arguments to filter Proveedors to count.
     * @example
     * // Count the number of Proveedors
     * const count = await prisma.proveedor.count({
     *   where: {
     *     // ... the filter for the Proveedors we want to count
     *   }
     * })
    **/
    count<T extends proveedorCountArgs>(
      args?: Subset<T, proveedorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProveedorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Proveedor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProveedorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProveedorAggregateArgs>(args: Subset<T, ProveedorAggregateArgs>): Prisma.PrismaPromise<GetProveedorAggregateType<T>>

    /**
     * Group by Proveedor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {proveedorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends proveedorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: proveedorGroupByArgs['orderBy'] }
        : { orderBy?: proveedorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, proveedorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProveedorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the proveedor model
   */
  readonly fields: proveedorFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for proveedor.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__proveedorClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    inventario<T extends proveedor$inventarioArgs<ExtArgs> = {}>(args?: Subset<T, proveedor$inventarioArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$inventarioPayload<ExtArgs>, T, 'findMany'> | Null>;

    persona<T extends proveedor$personaArgs<ExtArgs> = {}>(args?: Subset<T, proveedor$personaArgs<ExtArgs>>): Prisma__personaClient<$Result.GetResult<Prisma.$personaPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the proveedor model
   */ 
  interface proveedorFieldRefs {
    readonly idprov: FieldRef<"proveedor", 'Int'>
    readonly nom: FieldRef<"proveedor", 'String'>
    readonly dir: FieldRef<"proveedor", 'String'>
    readonly dep: FieldRef<"proveedor", 'String'>
    readonly logo: FieldRef<"proveedor", 'Bytes'>
    readonly idpe: FieldRef<"proveedor", 'Int'>
    readonly estado: FieldRef<"proveedor", 'Boolean'>
    readonly nit: FieldRef<"proveedor", 'String'>
  }
    

  // Custom InputTypes

  /**
   * proveedor findUnique
   */
  export type proveedorFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the proveedor
     */
    select?: proveedorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: proveedorInclude<ExtArgs> | null
    /**
     * Filter, which proveedor to fetch.
     */
    where: proveedorWhereUniqueInput
  }


  /**
   * proveedor findUniqueOrThrow
   */
  export type proveedorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the proveedor
     */
    select?: proveedorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: proveedorInclude<ExtArgs> | null
    /**
     * Filter, which proveedor to fetch.
     */
    where: proveedorWhereUniqueInput
  }


  /**
   * proveedor findFirst
   */
  export type proveedorFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the proveedor
     */
    select?: proveedorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: proveedorInclude<ExtArgs> | null
    /**
     * Filter, which proveedor to fetch.
     */
    where?: proveedorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of proveedors to fetch.
     */
    orderBy?: proveedorOrderByWithRelationInput | proveedorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for proveedors.
     */
    cursor?: proveedorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` proveedors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` proveedors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of proveedors.
     */
    distinct?: ProveedorScalarFieldEnum | ProveedorScalarFieldEnum[]
  }


  /**
   * proveedor findFirstOrThrow
   */
  export type proveedorFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the proveedor
     */
    select?: proveedorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: proveedorInclude<ExtArgs> | null
    /**
     * Filter, which proveedor to fetch.
     */
    where?: proveedorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of proveedors to fetch.
     */
    orderBy?: proveedorOrderByWithRelationInput | proveedorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for proveedors.
     */
    cursor?: proveedorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` proveedors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` proveedors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of proveedors.
     */
    distinct?: ProveedorScalarFieldEnum | ProveedorScalarFieldEnum[]
  }


  /**
   * proveedor findMany
   */
  export type proveedorFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the proveedor
     */
    select?: proveedorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: proveedorInclude<ExtArgs> | null
    /**
     * Filter, which proveedors to fetch.
     */
    where?: proveedorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of proveedors to fetch.
     */
    orderBy?: proveedorOrderByWithRelationInput | proveedorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing proveedors.
     */
    cursor?: proveedorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` proveedors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` proveedors.
     */
    skip?: number
    distinct?: ProveedorScalarFieldEnum | ProveedorScalarFieldEnum[]
  }


  /**
   * proveedor create
   */
  export type proveedorCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the proveedor
     */
    select?: proveedorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: proveedorInclude<ExtArgs> | null
    /**
     * The data needed to create a proveedor.
     */
    data?: XOR<proveedorCreateInput, proveedorUncheckedCreateInput>
  }


  /**
   * proveedor createMany
   */
  export type proveedorCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many proveedors.
     */
    data: proveedorCreateManyInput | proveedorCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * proveedor update
   */
  export type proveedorUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the proveedor
     */
    select?: proveedorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: proveedorInclude<ExtArgs> | null
    /**
     * The data needed to update a proveedor.
     */
    data: XOR<proveedorUpdateInput, proveedorUncheckedUpdateInput>
    /**
     * Choose, which proveedor to update.
     */
    where: proveedorWhereUniqueInput
  }


  /**
   * proveedor updateMany
   */
  export type proveedorUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update proveedors.
     */
    data: XOR<proveedorUpdateManyMutationInput, proveedorUncheckedUpdateManyInput>
    /**
     * Filter which proveedors to update
     */
    where?: proveedorWhereInput
  }


  /**
   * proveedor upsert
   */
  export type proveedorUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the proveedor
     */
    select?: proveedorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: proveedorInclude<ExtArgs> | null
    /**
     * The filter to search for the proveedor to update in case it exists.
     */
    where: proveedorWhereUniqueInput
    /**
     * In case the proveedor found by the `where` argument doesn't exist, create a new proveedor with this data.
     */
    create: XOR<proveedorCreateInput, proveedorUncheckedCreateInput>
    /**
     * In case the proveedor was found with the provided `where` argument, update it with this data.
     */
    update: XOR<proveedorUpdateInput, proveedorUncheckedUpdateInput>
  }


  /**
   * proveedor delete
   */
  export type proveedorDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the proveedor
     */
    select?: proveedorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: proveedorInclude<ExtArgs> | null
    /**
     * Filter which proveedor to delete.
     */
    where: proveedorWhereUniqueInput
  }


  /**
   * proveedor deleteMany
   */
  export type proveedorDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which proveedors to delete
     */
    where?: proveedorWhereInput
  }


  /**
   * proveedor.inventario
   */
  export type proveedor$inventarioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inventario
     */
    select?: inventarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: inventarioInclude<ExtArgs> | null
    where?: inventarioWhereInput
    orderBy?: inventarioOrderByWithRelationInput | inventarioOrderByWithRelationInput[]
    cursor?: inventarioWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InventarioScalarFieldEnum | InventarioScalarFieldEnum[]
  }


  /**
   * proveedor.persona
   */
  export type proveedor$personaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the persona
     */
    select?: personaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: personaInclude<ExtArgs> | null
    where?: personaWhereInput
  }


  /**
   * proveedor without action
   */
  export type proveedorDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the proveedor
     */
    select?: proveedorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: proveedorInclude<ExtArgs> | null
  }



  /**
   * Model registrolaboral
   */

  export type AggregateRegistrolaboral = {
    _count: RegistrolaboralCountAggregateOutputType | null
    _avg: RegistrolaboralAvgAggregateOutputType | null
    _sum: RegistrolaboralSumAggregateOutputType | null
    _min: RegistrolaboralMinAggregateOutputType | null
    _max: RegistrolaboralMaxAggregateOutputType | null
  }

  export type RegistrolaboralAvgAggregateOutputType = {
    idre: number | null
    idu: number | null
  }

  export type RegistrolaboralSumAggregateOutputType = {
    idre: number | null
    idu: number | null
  }

  export type RegistrolaboralMinAggregateOutputType = {
    idre: number | null
    idu: number | null
    tiporegistro: string | null
    fecha: Date | null
    hora: Date | null
    mes: string | null
    estado: string | null
    adicional: string | null
    adicional2: string | null
    atraso: Date | null
  }

  export type RegistrolaboralMaxAggregateOutputType = {
    idre: number | null
    idu: number | null
    tiporegistro: string | null
    fecha: Date | null
    hora: Date | null
    mes: string | null
    estado: string | null
    adicional: string | null
    adicional2: string | null
    atraso: Date | null
  }

  export type RegistrolaboralCountAggregateOutputType = {
    idre: number
    idu: number
    tiporegistro: number
    fecha: number
    hora: number
    mes: number
    estado: number
    adicional: number
    adicional2: number
    atraso: number
    _all: number
  }


  export type RegistrolaboralAvgAggregateInputType = {
    idre?: true
    idu?: true
  }

  export type RegistrolaboralSumAggregateInputType = {
    idre?: true
    idu?: true
  }

  export type RegistrolaboralMinAggregateInputType = {
    idre?: true
    idu?: true
    tiporegistro?: true
    fecha?: true
    hora?: true
    mes?: true
    estado?: true
    adicional?: true
    adicional2?: true
    atraso?: true
  }

  export type RegistrolaboralMaxAggregateInputType = {
    idre?: true
    idu?: true
    tiporegistro?: true
    fecha?: true
    hora?: true
    mes?: true
    estado?: true
    adicional?: true
    adicional2?: true
    atraso?: true
  }

  export type RegistrolaboralCountAggregateInputType = {
    idre?: true
    idu?: true
    tiporegistro?: true
    fecha?: true
    hora?: true
    mes?: true
    estado?: true
    adicional?: true
    adicional2?: true
    atraso?: true
    _all?: true
  }

  export type RegistrolaboralAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which registrolaboral to aggregate.
     */
    where?: registrolaboralWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of registrolaborals to fetch.
     */
    orderBy?: registrolaboralOrderByWithRelationInput | registrolaboralOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: registrolaboralWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` registrolaborals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` registrolaborals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned registrolaborals
    **/
    _count?: true | RegistrolaboralCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RegistrolaboralAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RegistrolaboralSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RegistrolaboralMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RegistrolaboralMaxAggregateInputType
  }

  export type GetRegistrolaboralAggregateType<T extends RegistrolaboralAggregateArgs> = {
        [P in keyof T & keyof AggregateRegistrolaboral]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRegistrolaboral[P]>
      : GetScalarType<T[P], AggregateRegistrolaboral[P]>
  }




  export type registrolaboralGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: registrolaboralWhereInput
    orderBy?: registrolaboralOrderByWithAggregationInput | registrolaboralOrderByWithAggregationInput[]
    by: RegistrolaboralScalarFieldEnum[] | RegistrolaboralScalarFieldEnum
    having?: registrolaboralScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RegistrolaboralCountAggregateInputType | true
    _avg?: RegistrolaboralAvgAggregateInputType
    _sum?: RegistrolaboralSumAggregateInputType
    _min?: RegistrolaboralMinAggregateInputType
    _max?: RegistrolaboralMaxAggregateInputType
  }

  export type RegistrolaboralGroupByOutputType = {
    idre: number
    idu: number | null
    tiporegistro: string | null
    fecha: Date | null
    hora: Date | null
    mes: string | null
    estado: string | null
    adicional: string | null
    adicional2: string | null
    atraso: Date | null
    _count: RegistrolaboralCountAggregateOutputType | null
    _avg: RegistrolaboralAvgAggregateOutputType | null
    _sum: RegistrolaboralSumAggregateOutputType | null
    _min: RegistrolaboralMinAggregateOutputType | null
    _max: RegistrolaboralMaxAggregateOutputType | null
  }

  type GetRegistrolaboralGroupByPayload<T extends registrolaboralGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RegistrolaboralGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RegistrolaboralGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RegistrolaboralGroupByOutputType[P]>
            : GetScalarType<T[P], RegistrolaboralGroupByOutputType[P]>
        }
      >
    >


  export type registrolaboralSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idre?: boolean
    idu?: boolean
    tiporegistro?: boolean
    fecha?: boolean
    hora?: boolean
    mes?: boolean
    estado?: boolean
    adicional?: boolean
    adicional2?: boolean
    atraso?: boolean
    usuario?: boolean | registrolaboral$usuarioArgs<ExtArgs>
  }, ExtArgs["result"]["registrolaboral"]>

  export type registrolaboralSelectScalar = {
    idre?: boolean
    idu?: boolean
    tiporegistro?: boolean
    fecha?: boolean
    hora?: boolean
    mes?: boolean
    estado?: boolean
    adicional?: boolean
    adicional2?: boolean
    atraso?: boolean
  }

  export type registrolaboralInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    usuario?: boolean | registrolaboral$usuarioArgs<ExtArgs>
  }


  export type $registrolaboralPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "registrolaboral"
    objects: {
      usuario: Prisma.$usuarioPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      idre: number
      idu: number | null
      tiporegistro: string | null
      fecha: Date | null
      hora: Date | null
      mes: string | null
      estado: string | null
      adicional: string | null
      adicional2: string | null
      atraso: Date | null
    }, ExtArgs["result"]["registrolaboral"]>
    composites: {}
  }


  type registrolaboralGetPayload<S extends boolean | null | undefined | registrolaboralDefaultArgs> = $Result.GetResult<Prisma.$registrolaboralPayload, S>

  type registrolaboralCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<registrolaboralFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: RegistrolaboralCountAggregateInputType | true
    }

  export interface registrolaboralDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['registrolaboral'], meta: { name: 'registrolaboral' } }
    /**
     * Find zero or one Registrolaboral that matches the filter.
     * @param {registrolaboralFindUniqueArgs} args - Arguments to find a Registrolaboral
     * @example
     * // Get one Registrolaboral
     * const registrolaboral = await prisma.registrolaboral.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends registrolaboralFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, registrolaboralFindUniqueArgs<ExtArgs>>
    ): Prisma__registrolaboralClient<$Result.GetResult<Prisma.$registrolaboralPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Registrolaboral that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {registrolaboralFindUniqueOrThrowArgs} args - Arguments to find a Registrolaboral
     * @example
     * // Get one Registrolaboral
     * const registrolaboral = await prisma.registrolaboral.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends registrolaboralFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, registrolaboralFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__registrolaboralClient<$Result.GetResult<Prisma.$registrolaboralPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Registrolaboral that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {registrolaboralFindFirstArgs} args - Arguments to find a Registrolaboral
     * @example
     * // Get one Registrolaboral
     * const registrolaboral = await prisma.registrolaboral.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends registrolaboralFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, registrolaboralFindFirstArgs<ExtArgs>>
    ): Prisma__registrolaboralClient<$Result.GetResult<Prisma.$registrolaboralPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Registrolaboral that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {registrolaboralFindFirstOrThrowArgs} args - Arguments to find a Registrolaboral
     * @example
     * // Get one Registrolaboral
     * const registrolaboral = await prisma.registrolaboral.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends registrolaboralFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, registrolaboralFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__registrolaboralClient<$Result.GetResult<Prisma.$registrolaboralPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Registrolaborals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {registrolaboralFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Registrolaborals
     * const registrolaborals = await prisma.registrolaboral.findMany()
     * 
     * // Get first 10 Registrolaborals
     * const registrolaborals = await prisma.registrolaboral.findMany({ take: 10 })
     * 
     * // Only select the `idre`
     * const registrolaboralWithIdreOnly = await prisma.registrolaboral.findMany({ select: { idre: true } })
     * 
    **/
    findMany<T extends registrolaboralFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, registrolaboralFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$registrolaboralPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Registrolaboral.
     * @param {registrolaboralCreateArgs} args - Arguments to create a Registrolaboral.
     * @example
     * // Create one Registrolaboral
     * const Registrolaboral = await prisma.registrolaboral.create({
     *   data: {
     *     // ... data to create a Registrolaboral
     *   }
     * })
     * 
    **/
    create<T extends registrolaboralCreateArgs<ExtArgs>>(
      args: SelectSubset<T, registrolaboralCreateArgs<ExtArgs>>
    ): Prisma__registrolaboralClient<$Result.GetResult<Prisma.$registrolaboralPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Registrolaborals.
     *     @param {registrolaboralCreateManyArgs} args - Arguments to create many Registrolaborals.
     *     @example
     *     // Create many Registrolaborals
     *     const registrolaboral = await prisma.registrolaboral.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends registrolaboralCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, registrolaboralCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Registrolaboral.
     * @param {registrolaboralDeleteArgs} args - Arguments to delete one Registrolaboral.
     * @example
     * // Delete one Registrolaboral
     * const Registrolaboral = await prisma.registrolaboral.delete({
     *   where: {
     *     // ... filter to delete one Registrolaboral
     *   }
     * })
     * 
    **/
    delete<T extends registrolaboralDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, registrolaboralDeleteArgs<ExtArgs>>
    ): Prisma__registrolaboralClient<$Result.GetResult<Prisma.$registrolaboralPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Registrolaboral.
     * @param {registrolaboralUpdateArgs} args - Arguments to update one Registrolaboral.
     * @example
     * // Update one Registrolaboral
     * const registrolaboral = await prisma.registrolaboral.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends registrolaboralUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, registrolaboralUpdateArgs<ExtArgs>>
    ): Prisma__registrolaboralClient<$Result.GetResult<Prisma.$registrolaboralPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Registrolaborals.
     * @param {registrolaboralDeleteManyArgs} args - Arguments to filter Registrolaborals to delete.
     * @example
     * // Delete a few Registrolaborals
     * const { count } = await prisma.registrolaboral.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends registrolaboralDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, registrolaboralDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Registrolaborals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {registrolaboralUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Registrolaborals
     * const registrolaboral = await prisma.registrolaboral.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends registrolaboralUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, registrolaboralUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Registrolaboral.
     * @param {registrolaboralUpsertArgs} args - Arguments to update or create a Registrolaboral.
     * @example
     * // Update or create a Registrolaboral
     * const registrolaboral = await prisma.registrolaboral.upsert({
     *   create: {
     *     // ... data to create a Registrolaboral
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Registrolaboral we want to update
     *   }
     * })
    **/
    upsert<T extends registrolaboralUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, registrolaboralUpsertArgs<ExtArgs>>
    ): Prisma__registrolaboralClient<$Result.GetResult<Prisma.$registrolaboralPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Registrolaborals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {registrolaboralCountArgs} args - Arguments to filter Registrolaborals to count.
     * @example
     * // Count the number of Registrolaborals
     * const count = await prisma.registrolaboral.count({
     *   where: {
     *     // ... the filter for the Registrolaborals we want to count
     *   }
     * })
    **/
    count<T extends registrolaboralCountArgs>(
      args?: Subset<T, registrolaboralCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RegistrolaboralCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Registrolaboral.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegistrolaboralAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RegistrolaboralAggregateArgs>(args: Subset<T, RegistrolaboralAggregateArgs>): Prisma.PrismaPromise<GetRegistrolaboralAggregateType<T>>

    /**
     * Group by Registrolaboral.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {registrolaboralGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends registrolaboralGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: registrolaboralGroupByArgs['orderBy'] }
        : { orderBy?: registrolaboralGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, registrolaboralGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRegistrolaboralGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the registrolaboral model
   */
  readonly fields: registrolaboralFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for registrolaboral.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__registrolaboralClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    usuario<T extends registrolaboral$usuarioArgs<ExtArgs> = {}>(args?: Subset<T, registrolaboral$usuarioArgs<ExtArgs>>): Prisma__usuarioClient<$Result.GetResult<Prisma.$usuarioPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the registrolaboral model
   */ 
  interface registrolaboralFieldRefs {
    readonly idre: FieldRef<"registrolaboral", 'Int'>
    readonly idu: FieldRef<"registrolaboral", 'Int'>
    readonly tiporegistro: FieldRef<"registrolaboral", 'String'>
    readonly fecha: FieldRef<"registrolaboral", 'DateTime'>
    readonly hora: FieldRef<"registrolaboral", 'DateTime'>
    readonly mes: FieldRef<"registrolaboral", 'String'>
    readonly estado: FieldRef<"registrolaboral", 'String'>
    readonly adicional: FieldRef<"registrolaboral", 'String'>
    readonly adicional2: FieldRef<"registrolaboral", 'String'>
    readonly atraso: FieldRef<"registrolaboral", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * registrolaboral findUnique
   */
  export type registrolaboralFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the registrolaboral
     */
    select?: registrolaboralSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: registrolaboralInclude<ExtArgs> | null
    /**
     * Filter, which registrolaboral to fetch.
     */
    where: registrolaboralWhereUniqueInput
  }


  /**
   * registrolaboral findUniqueOrThrow
   */
  export type registrolaboralFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the registrolaboral
     */
    select?: registrolaboralSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: registrolaboralInclude<ExtArgs> | null
    /**
     * Filter, which registrolaboral to fetch.
     */
    where: registrolaboralWhereUniqueInput
  }


  /**
   * registrolaboral findFirst
   */
  export type registrolaboralFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the registrolaboral
     */
    select?: registrolaboralSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: registrolaboralInclude<ExtArgs> | null
    /**
     * Filter, which registrolaboral to fetch.
     */
    where?: registrolaboralWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of registrolaborals to fetch.
     */
    orderBy?: registrolaboralOrderByWithRelationInput | registrolaboralOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for registrolaborals.
     */
    cursor?: registrolaboralWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` registrolaborals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` registrolaborals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of registrolaborals.
     */
    distinct?: RegistrolaboralScalarFieldEnum | RegistrolaboralScalarFieldEnum[]
  }


  /**
   * registrolaboral findFirstOrThrow
   */
  export type registrolaboralFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the registrolaboral
     */
    select?: registrolaboralSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: registrolaboralInclude<ExtArgs> | null
    /**
     * Filter, which registrolaboral to fetch.
     */
    where?: registrolaboralWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of registrolaborals to fetch.
     */
    orderBy?: registrolaboralOrderByWithRelationInput | registrolaboralOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for registrolaborals.
     */
    cursor?: registrolaboralWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` registrolaborals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` registrolaborals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of registrolaborals.
     */
    distinct?: RegistrolaboralScalarFieldEnum | RegistrolaboralScalarFieldEnum[]
  }


  /**
   * registrolaboral findMany
   */
  export type registrolaboralFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the registrolaboral
     */
    select?: registrolaboralSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: registrolaboralInclude<ExtArgs> | null
    /**
     * Filter, which registrolaborals to fetch.
     */
    where?: registrolaboralWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of registrolaborals to fetch.
     */
    orderBy?: registrolaboralOrderByWithRelationInput | registrolaboralOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing registrolaborals.
     */
    cursor?: registrolaboralWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` registrolaborals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` registrolaborals.
     */
    skip?: number
    distinct?: RegistrolaboralScalarFieldEnum | RegistrolaboralScalarFieldEnum[]
  }


  /**
   * registrolaboral create
   */
  export type registrolaboralCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the registrolaboral
     */
    select?: registrolaboralSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: registrolaboralInclude<ExtArgs> | null
    /**
     * The data needed to create a registrolaboral.
     */
    data?: XOR<registrolaboralCreateInput, registrolaboralUncheckedCreateInput>
  }


  /**
   * registrolaboral createMany
   */
  export type registrolaboralCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many registrolaborals.
     */
    data: registrolaboralCreateManyInput | registrolaboralCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * registrolaboral update
   */
  export type registrolaboralUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the registrolaboral
     */
    select?: registrolaboralSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: registrolaboralInclude<ExtArgs> | null
    /**
     * The data needed to update a registrolaboral.
     */
    data: XOR<registrolaboralUpdateInput, registrolaboralUncheckedUpdateInput>
    /**
     * Choose, which registrolaboral to update.
     */
    where: registrolaboralWhereUniqueInput
  }


  /**
   * registrolaboral updateMany
   */
  export type registrolaboralUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update registrolaborals.
     */
    data: XOR<registrolaboralUpdateManyMutationInput, registrolaboralUncheckedUpdateManyInput>
    /**
     * Filter which registrolaborals to update
     */
    where?: registrolaboralWhereInput
  }


  /**
   * registrolaboral upsert
   */
  export type registrolaboralUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the registrolaboral
     */
    select?: registrolaboralSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: registrolaboralInclude<ExtArgs> | null
    /**
     * The filter to search for the registrolaboral to update in case it exists.
     */
    where: registrolaboralWhereUniqueInput
    /**
     * In case the registrolaboral found by the `where` argument doesn't exist, create a new registrolaboral with this data.
     */
    create: XOR<registrolaboralCreateInput, registrolaboralUncheckedCreateInput>
    /**
     * In case the registrolaboral was found with the provided `where` argument, update it with this data.
     */
    update: XOR<registrolaboralUpdateInput, registrolaboralUncheckedUpdateInput>
  }


  /**
   * registrolaboral delete
   */
  export type registrolaboralDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the registrolaboral
     */
    select?: registrolaboralSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: registrolaboralInclude<ExtArgs> | null
    /**
     * Filter which registrolaboral to delete.
     */
    where: registrolaboralWhereUniqueInput
  }


  /**
   * registrolaboral deleteMany
   */
  export type registrolaboralDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which registrolaborals to delete
     */
    where?: registrolaboralWhereInput
  }


  /**
   * registrolaboral.usuario
   */
  export type registrolaboral$usuarioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usuario
     */
    select?: usuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: usuarioInclude<ExtArgs> | null
    where?: usuarioWhereInput
  }


  /**
   * registrolaboral without action
   */
  export type registrolaboralDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the registrolaboral
     */
    select?: registrolaboralSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: registrolaboralInclude<ExtArgs> | null
  }



  /**
   * Model roles
   */

  export type AggregateRoles = {
    _count: RolesCountAggregateOutputType | null
    _avg: RolesAvgAggregateOutputType | null
    _sum: RolesSumAggregateOutputType | null
    _min: RolesMinAggregateOutputType | null
    _max: RolesMaxAggregateOutputType | null
  }

  export type RolesAvgAggregateOutputType = {
    idr: number | null
    jerarquia: number | null
  }

  export type RolesSumAggregateOutputType = {
    idr: number | null
    jerarquia: number | null
  }

  export type RolesMinAggregateOutputType = {
    idr: number | null
    nombre: string | null
    descrip: string | null
    jerarquia: number | null
    estado: boolean | null
  }

  export type RolesMaxAggregateOutputType = {
    idr: number | null
    nombre: string | null
    descrip: string | null
    jerarquia: number | null
    estado: boolean | null
  }

  export type RolesCountAggregateOutputType = {
    idr: number
    nombre: number
    descrip: number
    jerarquia: number
    estado: number
    _all: number
  }


  export type RolesAvgAggregateInputType = {
    idr?: true
    jerarquia?: true
  }

  export type RolesSumAggregateInputType = {
    idr?: true
    jerarquia?: true
  }

  export type RolesMinAggregateInputType = {
    idr?: true
    nombre?: true
    descrip?: true
    jerarquia?: true
    estado?: true
  }

  export type RolesMaxAggregateInputType = {
    idr?: true
    nombre?: true
    descrip?: true
    jerarquia?: true
    estado?: true
  }

  export type RolesCountAggregateInputType = {
    idr?: true
    nombre?: true
    descrip?: true
    jerarquia?: true
    estado?: true
    _all?: true
  }

  export type RolesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which roles to aggregate.
     */
    where?: rolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of roles to fetch.
     */
    orderBy?: rolesOrderByWithRelationInput | rolesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: rolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned roles
    **/
    _count?: true | RolesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RolesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RolesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RolesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RolesMaxAggregateInputType
  }

  export type GetRolesAggregateType<T extends RolesAggregateArgs> = {
        [P in keyof T & keyof AggregateRoles]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRoles[P]>
      : GetScalarType<T[P], AggregateRoles[P]>
  }




  export type rolesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: rolesWhereInput
    orderBy?: rolesOrderByWithAggregationInput | rolesOrderByWithAggregationInput[]
    by: RolesScalarFieldEnum[] | RolesScalarFieldEnum
    having?: rolesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RolesCountAggregateInputType | true
    _avg?: RolesAvgAggregateInputType
    _sum?: RolesSumAggregateInputType
    _min?: RolesMinAggregateInputType
    _max?: RolesMaxAggregateInputType
  }

  export type RolesGroupByOutputType = {
    idr: number
    nombre: string
    descrip: string
    jerarquia: number
    estado: boolean
    _count: RolesCountAggregateOutputType | null
    _avg: RolesAvgAggregateOutputType | null
    _sum: RolesSumAggregateOutputType | null
    _min: RolesMinAggregateOutputType | null
    _max: RolesMaxAggregateOutputType | null
  }

  type GetRolesGroupByPayload<T extends rolesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RolesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RolesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RolesGroupByOutputType[P]>
            : GetScalarType<T[P], RolesGroupByOutputType[P]>
        }
      >
    >


  export type rolesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idr?: boolean
    nombre?: boolean
    descrip?: boolean
    jerarquia?: boolean
    estado?: boolean
    rolmenu?: boolean | roles$rolmenuArgs<ExtArgs>
    usurol?: boolean | roles$usurolArgs<ExtArgs>
    _count?: boolean | RolesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["roles"]>

  export type rolesSelectScalar = {
    idr?: boolean
    nombre?: boolean
    descrip?: boolean
    jerarquia?: boolean
    estado?: boolean
  }

  export type rolesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    rolmenu?: boolean | roles$rolmenuArgs<ExtArgs>
    usurol?: boolean | roles$usurolArgs<ExtArgs>
    _count?: boolean | RolesCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $rolesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "roles"
    objects: {
      rolmenu: Prisma.$rolmenuPayload<ExtArgs>[]
      usurol: Prisma.$usurolPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      idr: number
      nombre: string
      descrip: string
      jerarquia: number
      estado: boolean
    }, ExtArgs["result"]["roles"]>
    composites: {}
  }


  type rolesGetPayload<S extends boolean | null | undefined | rolesDefaultArgs> = $Result.GetResult<Prisma.$rolesPayload, S>

  type rolesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<rolesFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: RolesCountAggregateInputType | true
    }

  export interface rolesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['roles'], meta: { name: 'roles' } }
    /**
     * Find zero or one Roles that matches the filter.
     * @param {rolesFindUniqueArgs} args - Arguments to find a Roles
     * @example
     * // Get one Roles
     * const roles = await prisma.roles.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends rolesFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, rolesFindUniqueArgs<ExtArgs>>
    ): Prisma__rolesClient<$Result.GetResult<Prisma.$rolesPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Roles that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {rolesFindUniqueOrThrowArgs} args - Arguments to find a Roles
     * @example
     * // Get one Roles
     * const roles = await prisma.roles.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends rolesFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, rolesFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__rolesClient<$Result.GetResult<Prisma.$rolesPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Roles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rolesFindFirstArgs} args - Arguments to find a Roles
     * @example
     * // Get one Roles
     * const roles = await prisma.roles.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends rolesFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, rolesFindFirstArgs<ExtArgs>>
    ): Prisma__rolesClient<$Result.GetResult<Prisma.$rolesPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Roles that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rolesFindFirstOrThrowArgs} args - Arguments to find a Roles
     * @example
     * // Get one Roles
     * const roles = await prisma.roles.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends rolesFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, rolesFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__rolesClient<$Result.GetResult<Prisma.$rolesPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Roles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rolesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Roles
     * const roles = await prisma.roles.findMany()
     * 
     * // Get first 10 Roles
     * const roles = await prisma.roles.findMany({ take: 10 })
     * 
     * // Only select the `idr`
     * const rolesWithIdrOnly = await prisma.roles.findMany({ select: { idr: true } })
     * 
    **/
    findMany<T extends rolesFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, rolesFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$rolesPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Roles.
     * @param {rolesCreateArgs} args - Arguments to create a Roles.
     * @example
     * // Create one Roles
     * const Roles = await prisma.roles.create({
     *   data: {
     *     // ... data to create a Roles
     *   }
     * })
     * 
    **/
    create<T extends rolesCreateArgs<ExtArgs>>(
      args: SelectSubset<T, rolesCreateArgs<ExtArgs>>
    ): Prisma__rolesClient<$Result.GetResult<Prisma.$rolesPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Roles.
     *     @param {rolesCreateManyArgs} args - Arguments to create many Roles.
     *     @example
     *     // Create many Roles
     *     const roles = await prisma.roles.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends rolesCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, rolesCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Roles.
     * @param {rolesDeleteArgs} args - Arguments to delete one Roles.
     * @example
     * // Delete one Roles
     * const Roles = await prisma.roles.delete({
     *   where: {
     *     // ... filter to delete one Roles
     *   }
     * })
     * 
    **/
    delete<T extends rolesDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, rolesDeleteArgs<ExtArgs>>
    ): Prisma__rolesClient<$Result.GetResult<Prisma.$rolesPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Roles.
     * @param {rolesUpdateArgs} args - Arguments to update one Roles.
     * @example
     * // Update one Roles
     * const roles = await prisma.roles.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends rolesUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, rolesUpdateArgs<ExtArgs>>
    ): Prisma__rolesClient<$Result.GetResult<Prisma.$rolesPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Roles.
     * @param {rolesDeleteManyArgs} args - Arguments to filter Roles to delete.
     * @example
     * // Delete a few Roles
     * const { count } = await prisma.roles.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends rolesDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, rolesDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rolesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Roles
     * const roles = await prisma.roles.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends rolesUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, rolesUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Roles.
     * @param {rolesUpsertArgs} args - Arguments to update or create a Roles.
     * @example
     * // Update or create a Roles
     * const roles = await prisma.roles.upsert({
     *   create: {
     *     // ... data to create a Roles
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Roles we want to update
     *   }
     * })
    **/
    upsert<T extends rolesUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, rolesUpsertArgs<ExtArgs>>
    ): Prisma__rolesClient<$Result.GetResult<Prisma.$rolesPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rolesCountArgs} args - Arguments to filter Roles to count.
     * @example
     * // Count the number of Roles
     * const count = await prisma.roles.count({
     *   where: {
     *     // ... the filter for the Roles we want to count
     *   }
     * })
    **/
    count<T extends rolesCountArgs>(
      args?: Subset<T, rolesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RolesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RolesAggregateArgs>(args: Subset<T, RolesAggregateArgs>): Prisma.PrismaPromise<GetRolesAggregateType<T>>

    /**
     * Group by Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rolesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends rolesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: rolesGroupByArgs['orderBy'] }
        : { orderBy?: rolesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, rolesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRolesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the roles model
   */
  readonly fields: rolesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for roles.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__rolesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    rolmenu<T extends roles$rolmenuArgs<ExtArgs> = {}>(args?: Subset<T, roles$rolmenuArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$rolmenuPayload<ExtArgs>, T, 'findMany'> | Null>;

    usurol<T extends roles$usurolArgs<ExtArgs> = {}>(args?: Subset<T, roles$usurolArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$usurolPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the roles model
   */ 
  interface rolesFieldRefs {
    readonly idr: FieldRef<"roles", 'Int'>
    readonly nombre: FieldRef<"roles", 'String'>
    readonly descrip: FieldRef<"roles", 'String'>
    readonly jerarquia: FieldRef<"roles", 'Int'>
    readonly estado: FieldRef<"roles", 'Boolean'>
  }
    

  // Custom InputTypes

  /**
   * roles findUnique
   */
  export type rolesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the roles
     */
    select?: rolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: rolesInclude<ExtArgs> | null
    /**
     * Filter, which roles to fetch.
     */
    where: rolesWhereUniqueInput
  }


  /**
   * roles findUniqueOrThrow
   */
  export type rolesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the roles
     */
    select?: rolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: rolesInclude<ExtArgs> | null
    /**
     * Filter, which roles to fetch.
     */
    where: rolesWhereUniqueInput
  }


  /**
   * roles findFirst
   */
  export type rolesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the roles
     */
    select?: rolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: rolesInclude<ExtArgs> | null
    /**
     * Filter, which roles to fetch.
     */
    where?: rolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of roles to fetch.
     */
    orderBy?: rolesOrderByWithRelationInput | rolesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for roles.
     */
    cursor?: rolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of roles.
     */
    distinct?: RolesScalarFieldEnum | RolesScalarFieldEnum[]
  }


  /**
   * roles findFirstOrThrow
   */
  export type rolesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the roles
     */
    select?: rolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: rolesInclude<ExtArgs> | null
    /**
     * Filter, which roles to fetch.
     */
    where?: rolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of roles to fetch.
     */
    orderBy?: rolesOrderByWithRelationInput | rolesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for roles.
     */
    cursor?: rolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of roles.
     */
    distinct?: RolesScalarFieldEnum | RolesScalarFieldEnum[]
  }


  /**
   * roles findMany
   */
  export type rolesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the roles
     */
    select?: rolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: rolesInclude<ExtArgs> | null
    /**
     * Filter, which roles to fetch.
     */
    where?: rolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of roles to fetch.
     */
    orderBy?: rolesOrderByWithRelationInput | rolesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing roles.
     */
    cursor?: rolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` roles.
     */
    skip?: number
    distinct?: RolesScalarFieldEnum | RolesScalarFieldEnum[]
  }


  /**
   * roles create
   */
  export type rolesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the roles
     */
    select?: rolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: rolesInclude<ExtArgs> | null
    /**
     * The data needed to create a roles.
     */
    data: XOR<rolesCreateInput, rolesUncheckedCreateInput>
  }


  /**
   * roles createMany
   */
  export type rolesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many roles.
     */
    data: rolesCreateManyInput | rolesCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * roles update
   */
  export type rolesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the roles
     */
    select?: rolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: rolesInclude<ExtArgs> | null
    /**
     * The data needed to update a roles.
     */
    data: XOR<rolesUpdateInput, rolesUncheckedUpdateInput>
    /**
     * Choose, which roles to update.
     */
    where: rolesWhereUniqueInput
  }


  /**
   * roles updateMany
   */
  export type rolesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update roles.
     */
    data: XOR<rolesUpdateManyMutationInput, rolesUncheckedUpdateManyInput>
    /**
     * Filter which roles to update
     */
    where?: rolesWhereInput
  }


  /**
   * roles upsert
   */
  export type rolesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the roles
     */
    select?: rolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: rolesInclude<ExtArgs> | null
    /**
     * The filter to search for the roles to update in case it exists.
     */
    where: rolesWhereUniqueInput
    /**
     * In case the roles found by the `where` argument doesn't exist, create a new roles with this data.
     */
    create: XOR<rolesCreateInput, rolesUncheckedCreateInput>
    /**
     * In case the roles was found with the provided `where` argument, update it with this data.
     */
    update: XOR<rolesUpdateInput, rolesUncheckedUpdateInput>
  }


  /**
   * roles delete
   */
  export type rolesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the roles
     */
    select?: rolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: rolesInclude<ExtArgs> | null
    /**
     * Filter which roles to delete.
     */
    where: rolesWhereUniqueInput
  }


  /**
   * roles deleteMany
   */
  export type rolesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which roles to delete
     */
    where?: rolesWhereInput
  }


  /**
   * roles.rolmenu
   */
  export type roles$rolmenuArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rolmenu
     */
    select?: rolmenuSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: rolmenuInclude<ExtArgs> | null
    where?: rolmenuWhereInput
    orderBy?: rolmenuOrderByWithRelationInput | rolmenuOrderByWithRelationInput[]
    cursor?: rolmenuWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RolmenuScalarFieldEnum | RolmenuScalarFieldEnum[]
  }


  /**
   * roles.usurol
   */
  export type roles$usurolArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usurol
     */
    select?: usurolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: usurolInclude<ExtArgs> | null
    where?: usurolWhereInput
    orderBy?: usurolOrderByWithRelationInput | usurolOrderByWithRelationInput[]
    cursor?: usurolWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UsurolScalarFieldEnum | UsurolScalarFieldEnum[]
  }


  /**
   * roles without action
   */
  export type rolesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the roles
     */
    select?: rolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: rolesInclude<ExtArgs> | null
  }



  /**
   * Model rolmenu
   */

  export type AggregateRolmenu = {
    _count: RolmenuCountAggregateOutputType | null
    _avg: RolmenuAvgAggregateOutputType | null
    _sum: RolmenuSumAggregateOutputType | null
    _min: RolmenuMinAggregateOutputType | null
    _max: RolmenuMaxAggregateOutputType | null
  }

  export type RolmenuAvgAggregateOutputType = {
    idr: number | null
    idm: number | null
  }

  export type RolmenuSumAggregateOutputType = {
    idr: number | null
    idm: number | null
  }

  export type RolmenuMinAggregateOutputType = {
    idr: number | null
    idm: number | null
  }

  export type RolmenuMaxAggregateOutputType = {
    idr: number | null
    idm: number | null
  }

  export type RolmenuCountAggregateOutputType = {
    idr: number
    idm: number
    _all: number
  }


  export type RolmenuAvgAggregateInputType = {
    idr?: true
    idm?: true
  }

  export type RolmenuSumAggregateInputType = {
    idr?: true
    idm?: true
  }

  export type RolmenuMinAggregateInputType = {
    idr?: true
    idm?: true
  }

  export type RolmenuMaxAggregateInputType = {
    idr?: true
    idm?: true
  }

  export type RolmenuCountAggregateInputType = {
    idr?: true
    idm?: true
    _all?: true
  }

  export type RolmenuAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which rolmenu to aggregate.
     */
    where?: rolmenuWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of rolmenus to fetch.
     */
    orderBy?: rolmenuOrderByWithRelationInput | rolmenuOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: rolmenuWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` rolmenus from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` rolmenus.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned rolmenus
    **/
    _count?: true | RolmenuCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RolmenuAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RolmenuSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RolmenuMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RolmenuMaxAggregateInputType
  }

  export type GetRolmenuAggregateType<T extends RolmenuAggregateArgs> = {
        [P in keyof T & keyof AggregateRolmenu]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRolmenu[P]>
      : GetScalarType<T[P], AggregateRolmenu[P]>
  }




  export type rolmenuGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: rolmenuWhereInput
    orderBy?: rolmenuOrderByWithAggregationInput | rolmenuOrderByWithAggregationInput[]
    by: RolmenuScalarFieldEnum[] | RolmenuScalarFieldEnum
    having?: rolmenuScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RolmenuCountAggregateInputType | true
    _avg?: RolmenuAvgAggregateInputType
    _sum?: RolmenuSumAggregateInputType
    _min?: RolmenuMinAggregateInputType
    _max?: RolmenuMaxAggregateInputType
  }

  export type RolmenuGroupByOutputType = {
    idr: number
    idm: number
    _count: RolmenuCountAggregateOutputType | null
    _avg: RolmenuAvgAggregateOutputType | null
    _sum: RolmenuSumAggregateOutputType | null
    _min: RolmenuMinAggregateOutputType | null
    _max: RolmenuMaxAggregateOutputType | null
  }

  type GetRolmenuGroupByPayload<T extends rolmenuGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RolmenuGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RolmenuGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RolmenuGroupByOutputType[P]>
            : GetScalarType<T[P], RolmenuGroupByOutputType[P]>
        }
      >
    >


  export type rolmenuSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idr?: boolean
    idm?: boolean
    menu?: boolean | menuDefaultArgs<ExtArgs>
    roles?: boolean | rolesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rolmenu"]>

  export type rolmenuSelectScalar = {
    idr?: boolean
    idm?: boolean
  }

  export type rolmenuInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    menu?: boolean | menuDefaultArgs<ExtArgs>
    roles?: boolean | rolesDefaultArgs<ExtArgs>
  }


  export type $rolmenuPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "rolmenu"
    objects: {
      menu: Prisma.$menuPayload<ExtArgs>
      roles: Prisma.$rolesPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      idr: number
      idm: number
    }, ExtArgs["result"]["rolmenu"]>
    composites: {}
  }


  type rolmenuGetPayload<S extends boolean | null | undefined | rolmenuDefaultArgs> = $Result.GetResult<Prisma.$rolmenuPayload, S>

  type rolmenuCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<rolmenuFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: RolmenuCountAggregateInputType | true
    }

  export interface rolmenuDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['rolmenu'], meta: { name: 'rolmenu' } }
    /**
     * Find zero or one Rolmenu that matches the filter.
     * @param {rolmenuFindUniqueArgs} args - Arguments to find a Rolmenu
     * @example
     * // Get one Rolmenu
     * const rolmenu = await prisma.rolmenu.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends rolmenuFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, rolmenuFindUniqueArgs<ExtArgs>>
    ): Prisma__rolmenuClient<$Result.GetResult<Prisma.$rolmenuPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Rolmenu that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {rolmenuFindUniqueOrThrowArgs} args - Arguments to find a Rolmenu
     * @example
     * // Get one Rolmenu
     * const rolmenu = await prisma.rolmenu.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends rolmenuFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, rolmenuFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__rolmenuClient<$Result.GetResult<Prisma.$rolmenuPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Rolmenu that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rolmenuFindFirstArgs} args - Arguments to find a Rolmenu
     * @example
     * // Get one Rolmenu
     * const rolmenu = await prisma.rolmenu.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends rolmenuFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, rolmenuFindFirstArgs<ExtArgs>>
    ): Prisma__rolmenuClient<$Result.GetResult<Prisma.$rolmenuPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Rolmenu that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rolmenuFindFirstOrThrowArgs} args - Arguments to find a Rolmenu
     * @example
     * // Get one Rolmenu
     * const rolmenu = await prisma.rolmenu.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends rolmenuFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, rolmenuFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__rolmenuClient<$Result.GetResult<Prisma.$rolmenuPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Rolmenus that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rolmenuFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Rolmenus
     * const rolmenus = await prisma.rolmenu.findMany()
     * 
     * // Get first 10 Rolmenus
     * const rolmenus = await prisma.rolmenu.findMany({ take: 10 })
     * 
     * // Only select the `idr`
     * const rolmenuWithIdrOnly = await prisma.rolmenu.findMany({ select: { idr: true } })
     * 
    **/
    findMany<T extends rolmenuFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, rolmenuFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$rolmenuPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Rolmenu.
     * @param {rolmenuCreateArgs} args - Arguments to create a Rolmenu.
     * @example
     * // Create one Rolmenu
     * const Rolmenu = await prisma.rolmenu.create({
     *   data: {
     *     // ... data to create a Rolmenu
     *   }
     * })
     * 
    **/
    create<T extends rolmenuCreateArgs<ExtArgs>>(
      args: SelectSubset<T, rolmenuCreateArgs<ExtArgs>>
    ): Prisma__rolmenuClient<$Result.GetResult<Prisma.$rolmenuPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Rolmenus.
     *     @param {rolmenuCreateManyArgs} args - Arguments to create many Rolmenus.
     *     @example
     *     // Create many Rolmenus
     *     const rolmenu = await prisma.rolmenu.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends rolmenuCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, rolmenuCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Rolmenu.
     * @param {rolmenuDeleteArgs} args - Arguments to delete one Rolmenu.
     * @example
     * // Delete one Rolmenu
     * const Rolmenu = await prisma.rolmenu.delete({
     *   where: {
     *     // ... filter to delete one Rolmenu
     *   }
     * })
     * 
    **/
    delete<T extends rolmenuDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, rolmenuDeleteArgs<ExtArgs>>
    ): Prisma__rolmenuClient<$Result.GetResult<Prisma.$rolmenuPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Rolmenu.
     * @param {rolmenuUpdateArgs} args - Arguments to update one Rolmenu.
     * @example
     * // Update one Rolmenu
     * const rolmenu = await prisma.rolmenu.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends rolmenuUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, rolmenuUpdateArgs<ExtArgs>>
    ): Prisma__rolmenuClient<$Result.GetResult<Prisma.$rolmenuPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Rolmenus.
     * @param {rolmenuDeleteManyArgs} args - Arguments to filter Rolmenus to delete.
     * @example
     * // Delete a few Rolmenus
     * const { count } = await prisma.rolmenu.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends rolmenuDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, rolmenuDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Rolmenus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rolmenuUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Rolmenus
     * const rolmenu = await prisma.rolmenu.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends rolmenuUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, rolmenuUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Rolmenu.
     * @param {rolmenuUpsertArgs} args - Arguments to update or create a Rolmenu.
     * @example
     * // Update or create a Rolmenu
     * const rolmenu = await prisma.rolmenu.upsert({
     *   create: {
     *     // ... data to create a Rolmenu
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Rolmenu we want to update
     *   }
     * })
    **/
    upsert<T extends rolmenuUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, rolmenuUpsertArgs<ExtArgs>>
    ): Prisma__rolmenuClient<$Result.GetResult<Prisma.$rolmenuPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Rolmenus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rolmenuCountArgs} args - Arguments to filter Rolmenus to count.
     * @example
     * // Count the number of Rolmenus
     * const count = await prisma.rolmenu.count({
     *   where: {
     *     // ... the filter for the Rolmenus we want to count
     *   }
     * })
    **/
    count<T extends rolmenuCountArgs>(
      args?: Subset<T, rolmenuCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RolmenuCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Rolmenu.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolmenuAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RolmenuAggregateArgs>(args: Subset<T, RolmenuAggregateArgs>): Prisma.PrismaPromise<GetRolmenuAggregateType<T>>

    /**
     * Group by Rolmenu.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rolmenuGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends rolmenuGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: rolmenuGroupByArgs['orderBy'] }
        : { orderBy?: rolmenuGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, rolmenuGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRolmenuGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the rolmenu model
   */
  readonly fields: rolmenuFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for rolmenu.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__rolmenuClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    menu<T extends menuDefaultArgs<ExtArgs> = {}>(args?: Subset<T, menuDefaultArgs<ExtArgs>>): Prisma__menuClient<$Result.GetResult<Prisma.$menuPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    roles<T extends rolesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, rolesDefaultArgs<ExtArgs>>): Prisma__rolesClient<$Result.GetResult<Prisma.$rolesPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the rolmenu model
   */ 
  interface rolmenuFieldRefs {
    readonly idr: FieldRef<"rolmenu", 'Int'>
    readonly idm: FieldRef<"rolmenu", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * rolmenu findUnique
   */
  export type rolmenuFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rolmenu
     */
    select?: rolmenuSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: rolmenuInclude<ExtArgs> | null
    /**
     * Filter, which rolmenu to fetch.
     */
    where: rolmenuWhereUniqueInput
  }


  /**
   * rolmenu findUniqueOrThrow
   */
  export type rolmenuFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rolmenu
     */
    select?: rolmenuSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: rolmenuInclude<ExtArgs> | null
    /**
     * Filter, which rolmenu to fetch.
     */
    where: rolmenuWhereUniqueInput
  }


  /**
   * rolmenu findFirst
   */
  export type rolmenuFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rolmenu
     */
    select?: rolmenuSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: rolmenuInclude<ExtArgs> | null
    /**
     * Filter, which rolmenu to fetch.
     */
    where?: rolmenuWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of rolmenus to fetch.
     */
    orderBy?: rolmenuOrderByWithRelationInput | rolmenuOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for rolmenus.
     */
    cursor?: rolmenuWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` rolmenus from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` rolmenus.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of rolmenus.
     */
    distinct?: RolmenuScalarFieldEnum | RolmenuScalarFieldEnum[]
  }


  /**
   * rolmenu findFirstOrThrow
   */
  export type rolmenuFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rolmenu
     */
    select?: rolmenuSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: rolmenuInclude<ExtArgs> | null
    /**
     * Filter, which rolmenu to fetch.
     */
    where?: rolmenuWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of rolmenus to fetch.
     */
    orderBy?: rolmenuOrderByWithRelationInput | rolmenuOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for rolmenus.
     */
    cursor?: rolmenuWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` rolmenus from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` rolmenus.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of rolmenus.
     */
    distinct?: RolmenuScalarFieldEnum | RolmenuScalarFieldEnum[]
  }


  /**
   * rolmenu findMany
   */
  export type rolmenuFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rolmenu
     */
    select?: rolmenuSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: rolmenuInclude<ExtArgs> | null
    /**
     * Filter, which rolmenus to fetch.
     */
    where?: rolmenuWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of rolmenus to fetch.
     */
    orderBy?: rolmenuOrderByWithRelationInput | rolmenuOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing rolmenus.
     */
    cursor?: rolmenuWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` rolmenus from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` rolmenus.
     */
    skip?: number
    distinct?: RolmenuScalarFieldEnum | RolmenuScalarFieldEnum[]
  }


  /**
   * rolmenu create
   */
  export type rolmenuCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rolmenu
     */
    select?: rolmenuSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: rolmenuInclude<ExtArgs> | null
    /**
     * The data needed to create a rolmenu.
     */
    data: XOR<rolmenuCreateInput, rolmenuUncheckedCreateInput>
  }


  /**
   * rolmenu createMany
   */
  export type rolmenuCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many rolmenus.
     */
    data: rolmenuCreateManyInput | rolmenuCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * rolmenu update
   */
  export type rolmenuUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rolmenu
     */
    select?: rolmenuSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: rolmenuInclude<ExtArgs> | null
    /**
     * The data needed to update a rolmenu.
     */
    data: XOR<rolmenuUpdateInput, rolmenuUncheckedUpdateInput>
    /**
     * Choose, which rolmenu to update.
     */
    where: rolmenuWhereUniqueInput
  }


  /**
   * rolmenu updateMany
   */
  export type rolmenuUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update rolmenus.
     */
    data: XOR<rolmenuUpdateManyMutationInput, rolmenuUncheckedUpdateManyInput>
    /**
     * Filter which rolmenus to update
     */
    where?: rolmenuWhereInput
  }


  /**
   * rolmenu upsert
   */
  export type rolmenuUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rolmenu
     */
    select?: rolmenuSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: rolmenuInclude<ExtArgs> | null
    /**
     * The filter to search for the rolmenu to update in case it exists.
     */
    where: rolmenuWhereUniqueInput
    /**
     * In case the rolmenu found by the `where` argument doesn't exist, create a new rolmenu with this data.
     */
    create: XOR<rolmenuCreateInput, rolmenuUncheckedCreateInput>
    /**
     * In case the rolmenu was found with the provided `where` argument, update it with this data.
     */
    update: XOR<rolmenuUpdateInput, rolmenuUncheckedUpdateInput>
  }


  /**
   * rolmenu delete
   */
  export type rolmenuDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rolmenu
     */
    select?: rolmenuSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: rolmenuInclude<ExtArgs> | null
    /**
     * Filter which rolmenu to delete.
     */
    where: rolmenuWhereUniqueInput
  }


  /**
   * rolmenu deleteMany
   */
  export type rolmenuDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which rolmenus to delete
     */
    where?: rolmenuWhereInput
  }


  /**
   * rolmenu without action
   */
  export type rolmenuDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rolmenu
     */
    select?: rolmenuSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: rolmenuInclude<ExtArgs> | null
  }



  /**
   * Model telefono
   */

  export type AggregateTelefono = {
    _count: TelefonoCountAggregateOutputType | null
    _avg: TelefonoAvgAggregateOutputType | null
    _sum: TelefonoSumAggregateOutputType | null
    _min: TelefonoMinAggregateOutputType | null
    _max: TelefonoMaxAggregateOutputType | null
  }

  export type TelefonoAvgAggregateOutputType = {
    idtel: number | null
    idpe: number | null
  }

  export type TelefonoSumAggregateOutputType = {
    idtel: number | null
    idpe: number | null
  }

  export type TelefonoMinAggregateOutputType = {
    idtel: number | null
    idpe: number | null
    numero: string | null
    estado: boolean | null
  }

  export type TelefonoMaxAggregateOutputType = {
    idtel: number | null
    idpe: number | null
    numero: string | null
    estado: boolean | null
  }

  export type TelefonoCountAggregateOutputType = {
    idtel: number
    idpe: number
    numero: number
    estado: number
    _all: number
  }


  export type TelefonoAvgAggregateInputType = {
    idtel?: true
    idpe?: true
  }

  export type TelefonoSumAggregateInputType = {
    idtel?: true
    idpe?: true
  }

  export type TelefonoMinAggregateInputType = {
    idtel?: true
    idpe?: true
    numero?: true
    estado?: true
  }

  export type TelefonoMaxAggregateInputType = {
    idtel?: true
    idpe?: true
    numero?: true
    estado?: true
  }

  export type TelefonoCountAggregateInputType = {
    idtel?: true
    idpe?: true
    numero?: true
    estado?: true
    _all?: true
  }

  export type TelefonoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which telefono to aggregate.
     */
    where?: telefonoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of telefonos to fetch.
     */
    orderBy?: telefonoOrderByWithRelationInput | telefonoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: telefonoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` telefonos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` telefonos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned telefonos
    **/
    _count?: true | TelefonoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TelefonoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TelefonoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TelefonoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TelefonoMaxAggregateInputType
  }

  export type GetTelefonoAggregateType<T extends TelefonoAggregateArgs> = {
        [P in keyof T & keyof AggregateTelefono]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTelefono[P]>
      : GetScalarType<T[P], AggregateTelefono[P]>
  }




  export type telefonoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: telefonoWhereInput
    orderBy?: telefonoOrderByWithAggregationInput | telefonoOrderByWithAggregationInput[]
    by: TelefonoScalarFieldEnum[] | TelefonoScalarFieldEnum
    having?: telefonoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TelefonoCountAggregateInputType | true
    _avg?: TelefonoAvgAggregateInputType
    _sum?: TelefonoSumAggregateInputType
    _min?: TelefonoMinAggregateInputType
    _max?: TelefonoMaxAggregateInputType
  }

  export type TelefonoGroupByOutputType = {
    idtel: number
    idpe: number
    numero: string
    estado: boolean | null
    _count: TelefonoCountAggregateOutputType | null
    _avg: TelefonoAvgAggregateOutputType | null
    _sum: TelefonoSumAggregateOutputType | null
    _min: TelefonoMinAggregateOutputType | null
    _max: TelefonoMaxAggregateOutputType | null
  }

  type GetTelefonoGroupByPayload<T extends telefonoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TelefonoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TelefonoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TelefonoGroupByOutputType[P]>
            : GetScalarType<T[P], TelefonoGroupByOutputType[P]>
        }
      >
    >


  export type telefonoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idtel?: boolean
    idpe?: boolean
    numero?: boolean
    estado?: boolean
    persona?: boolean | personaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["telefono"]>

  export type telefonoSelectScalar = {
    idtel?: boolean
    idpe?: boolean
    numero?: boolean
    estado?: boolean
  }

  export type telefonoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    persona?: boolean | personaDefaultArgs<ExtArgs>
  }


  export type $telefonoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "telefono"
    objects: {
      persona: Prisma.$personaPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      idtel: number
      idpe: number
      numero: string
      estado: boolean | null
    }, ExtArgs["result"]["telefono"]>
    composites: {}
  }


  type telefonoGetPayload<S extends boolean | null | undefined | telefonoDefaultArgs> = $Result.GetResult<Prisma.$telefonoPayload, S>

  type telefonoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<telefonoFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: TelefonoCountAggregateInputType | true
    }

  export interface telefonoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['telefono'], meta: { name: 'telefono' } }
    /**
     * Find zero or one Telefono that matches the filter.
     * @param {telefonoFindUniqueArgs} args - Arguments to find a Telefono
     * @example
     * // Get one Telefono
     * const telefono = await prisma.telefono.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends telefonoFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, telefonoFindUniqueArgs<ExtArgs>>
    ): Prisma__telefonoClient<$Result.GetResult<Prisma.$telefonoPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Telefono that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {telefonoFindUniqueOrThrowArgs} args - Arguments to find a Telefono
     * @example
     * // Get one Telefono
     * const telefono = await prisma.telefono.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends telefonoFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, telefonoFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__telefonoClient<$Result.GetResult<Prisma.$telefonoPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Telefono that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {telefonoFindFirstArgs} args - Arguments to find a Telefono
     * @example
     * // Get one Telefono
     * const telefono = await prisma.telefono.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends telefonoFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, telefonoFindFirstArgs<ExtArgs>>
    ): Prisma__telefonoClient<$Result.GetResult<Prisma.$telefonoPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Telefono that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {telefonoFindFirstOrThrowArgs} args - Arguments to find a Telefono
     * @example
     * // Get one Telefono
     * const telefono = await prisma.telefono.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends telefonoFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, telefonoFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__telefonoClient<$Result.GetResult<Prisma.$telefonoPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Telefonos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {telefonoFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Telefonos
     * const telefonos = await prisma.telefono.findMany()
     * 
     * // Get first 10 Telefonos
     * const telefonos = await prisma.telefono.findMany({ take: 10 })
     * 
     * // Only select the `idtel`
     * const telefonoWithIdtelOnly = await prisma.telefono.findMany({ select: { idtel: true } })
     * 
    **/
    findMany<T extends telefonoFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, telefonoFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$telefonoPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Telefono.
     * @param {telefonoCreateArgs} args - Arguments to create a Telefono.
     * @example
     * // Create one Telefono
     * const Telefono = await prisma.telefono.create({
     *   data: {
     *     // ... data to create a Telefono
     *   }
     * })
     * 
    **/
    create<T extends telefonoCreateArgs<ExtArgs>>(
      args: SelectSubset<T, telefonoCreateArgs<ExtArgs>>
    ): Prisma__telefonoClient<$Result.GetResult<Prisma.$telefonoPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Telefonos.
     *     @param {telefonoCreateManyArgs} args - Arguments to create many Telefonos.
     *     @example
     *     // Create many Telefonos
     *     const telefono = await prisma.telefono.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends telefonoCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, telefonoCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Telefono.
     * @param {telefonoDeleteArgs} args - Arguments to delete one Telefono.
     * @example
     * // Delete one Telefono
     * const Telefono = await prisma.telefono.delete({
     *   where: {
     *     // ... filter to delete one Telefono
     *   }
     * })
     * 
    **/
    delete<T extends telefonoDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, telefonoDeleteArgs<ExtArgs>>
    ): Prisma__telefonoClient<$Result.GetResult<Prisma.$telefonoPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Telefono.
     * @param {telefonoUpdateArgs} args - Arguments to update one Telefono.
     * @example
     * // Update one Telefono
     * const telefono = await prisma.telefono.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends telefonoUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, telefonoUpdateArgs<ExtArgs>>
    ): Prisma__telefonoClient<$Result.GetResult<Prisma.$telefonoPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Telefonos.
     * @param {telefonoDeleteManyArgs} args - Arguments to filter Telefonos to delete.
     * @example
     * // Delete a few Telefonos
     * const { count } = await prisma.telefono.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends telefonoDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, telefonoDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Telefonos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {telefonoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Telefonos
     * const telefono = await prisma.telefono.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends telefonoUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, telefonoUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Telefono.
     * @param {telefonoUpsertArgs} args - Arguments to update or create a Telefono.
     * @example
     * // Update or create a Telefono
     * const telefono = await prisma.telefono.upsert({
     *   create: {
     *     // ... data to create a Telefono
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Telefono we want to update
     *   }
     * })
    **/
    upsert<T extends telefonoUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, telefonoUpsertArgs<ExtArgs>>
    ): Prisma__telefonoClient<$Result.GetResult<Prisma.$telefonoPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Telefonos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {telefonoCountArgs} args - Arguments to filter Telefonos to count.
     * @example
     * // Count the number of Telefonos
     * const count = await prisma.telefono.count({
     *   where: {
     *     // ... the filter for the Telefonos we want to count
     *   }
     * })
    **/
    count<T extends telefonoCountArgs>(
      args?: Subset<T, telefonoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TelefonoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Telefono.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TelefonoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TelefonoAggregateArgs>(args: Subset<T, TelefonoAggregateArgs>): Prisma.PrismaPromise<GetTelefonoAggregateType<T>>

    /**
     * Group by Telefono.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {telefonoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends telefonoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: telefonoGroupByArgs['orderBy'] }
        : { orderBy?: telefonoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, telefonoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTelefonoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the telefono model
   */
  readonly fields: telefonoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for telefono.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__telefonoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    persona<T extends personaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, personaDefaultArgs<ExtArgs>>): Prisma__personaClient<$Result.GetResult<Prisma.$personaPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the telefono model
   */ 
  interface telefonoFieldRefs {
    readonly idtel: FieldRef<"telefono", 'Int'>
    readonly idpe: FieldRef<"telefono", 'Int'>
    readonly numero: FieldRef<"telefono", 'String'>
    readonly estado: FieldRef<"telefono", 'Boolean'>
  }
    

  // Custom InputTypes

  /**
   * telefono findUnique
   */
  export type telefonoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the telefono
     */
    select?: telefonoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: telefonoInclude<ExtArgs> | null
    /**
     * Filter, which telefono to fetch.
     */
    where: telefonoWhereUniqueInput
  }


  /**
   * telefono findUniqueOrThrow
   */
  export type telefonoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the telefono
     */
    select?: telefonoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: telefonoInclude<ExtArgs> | null
    /**
     * Filter, which telefono to fetch.
     */
    where: telefonoWhereUniqueInput
  }


  /**
   * telefono findFirst
   */
  export type telefonoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the telefono
     */
    select?: telefonoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: telefonoInclude<ExtArgs> | null
    /**
     * Filter, which telefono to fetch.
     */
    where?: telefonoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of telefonos to fetch.
     */
    orderBy?: telefonoOrderByWithRelationInput | telefonoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for telefonos.
     */
    cursor?: telefonoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` telefonos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` telefonos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of telefonos.
     */
    distinct?: TelefonoScalarFieldEnum | TelefonoScalarFieldEnum[]
  }


  /**
   * telefono findFirstOrThrow
   */
  export type telefonoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the telefono
     */
    select?: telefonoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: telefonoInclude<ExtArgs> | null
    /**
     * Filter, which telefono to fetch.
     */
    where?: telefonoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of telefonos to fetch.
     */
    orderBy?: telefonoOrderByWithRelationInput | telefonoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for telefonos.
     */
    cursor?: telefonoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` telefonos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` telefonos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of telefonos.
     */
    distinct?: TelefonoScalarFieldEnum | TelefonoScalarFieldEnum[]
  }


  /**
   * telefono findMany
   */
  export type telefonoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the telefono
     */
    select?: telefonoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: telefonoInclude<ExtArgs> | null
    /**
     * Filter, which telefonos to fetch.
     */
    where?: telefonoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of telefonos to fetch.
     */
    orderBy?: telefonoOrderByWithRelationInput | telefonoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing telefonos.
     */
    cursor?: telefonoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` telefonos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` telefonos.
     */
    skip?: number
    distinct?: TelefonoScalarFieldEnum | TelefonoScalarFieldEnum[]
  }


  /**
   * telefono create
   */
  export type telefonoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the telefono
     */
    select?: telefonoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: telefonoInclude<ExtArgs> | null
    /**
     * The data needed to create a telefono.
     */
    data: XOR<telefonoCreateInput, telefonoUncheckedCreateInput>
  }


  /**
   * telefono createMany
   */
  export type telefonoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many telefonos.
     */
    data: telefonoCreateManyInput | telefonoCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * telefono update
   */
  export type telefonoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the telefono
     */
    select?: telefonoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: telefonoInclude<ExtArgs> | null
    /**
     * The data needed to update a telefono.
     */
    data: XOR<telefonoUpdateInput, telefonoUncheckedUpdateInput>
    /**
     * Choose, which telefono to update.
     */
    where: telefonoWhereUniqueInput
  }


  /**
   * telefono updateMany
   */
  export type telefonoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update telefonos.
     */
    data: XOR<telefonoUpdateManyMutationInput, telefonoUncheckedUpdateManyInput>
    /**
     * Filter which telefonos to update
     */
    where?: telefonoWhereInput
  }


  /**
   * telefono upsert
   */
  export type telefonoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the telefono
     */
    select?: telefonoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: telefonoInclude<ExtArgs> | null
    /**
     * The filter to search for the telefono to update in case it exists.
     */
    where: telefonoWhereUniqueInput
    /**
     * In case the telefono found by the `where` argument doesn't exist, create a new telefono with this data.
     */
    create: XOR<telefonoCreateInput, telefonoUncheckedCreateInput>
    /**
     * In case the telefono was found with the provided `where` argument, update it with this data.
     */
    update: XOR<telefonoUpdateInput, telefonoUncheckedUpdateInput>
  }


  /**
   * telefono delete
   */
  export type telefonoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the telefono
     */
    select?: telefonoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: telefonoInclude<ExtArgs> | null
    /**
     * Filter which telefono to delete.
     */
    where: telefonoWhereUniqueInput
  }


  /**
   * telefono deleteMany
   */
  export type telefonoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which telefonos to delete
     */
    where?: telefonoWhereInput
  }


  /**
   * telefono without action
   */
  export type telefonoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the telefono
     */
    select?: telefonoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: telefonoInclude<ExtArgs> | null
  }



  /**
   * Model terminado
   */

  export type AggregateTerminado = {
    _count: TerminadoCountAggregateOutputType | null
    _avg: TerminadoAvgAggregateOutputType | null
    _sum: TerminadoSumAggregateOutputType | null
    _min: TerminadoMinAggregateOutputType | null
    _max: TerminadoMaxAggregateOutputType | null
  }

  export type TerminadoAvgAggregateOutputType = {
    idter: number | null
    punit: number | null
    idmar: number | null
  }

  export type TerminadoSumAggregateOutputType = {
    idter: number | null
    punit: number | null
    idmar: number | null
  }

  export type TerminadoMinAggregateOutputType = {
    idter: number | null
    nom: string | null
    punit: number | null
    idmar: number | null
    estado: boolean | null
  }

  export type TerminadoMaxAggregateOutputType = {
    idter: number | null
    nom: string | null
    punit: number | null
    idmar: number | null
    estado: boolean | null
  }

  export type TerminadoCountAggregateOutputType = {
    idter: number
    nom: number
    punit: number
    idmar: number
    estado: number
    _all: number
  }


  export type TerminadoAvgAggregateInputType = {
    idter?: true
    punit?: true
    idmar?: true
  }

  export type TerminadoSumAggregateInputType = {
    idter?: true
    punit?: true
    idmar?: true
  }

  export type TerminadoMinAggregateInputType = {
    idter?: true
    nom?: true
    punit?: true
    idmar?: true
    estado?: true
  }

  export type TerminadoMaxAggregateInputType = {
    idter?: true
    nom?: true
    punit?: true
    idmar?: true
    estado?: true
  }

  export type TerminadoCountAggregateInputType = {
    idter?: true
    nom?: true
    punit?: true
    idmar?: true
    estado?: true
    _all?: true
  }

  export type TerminadoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which terminado to aggregate.
     */
    where?: terminadoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of terminados to fetch.
     */
    orderBy?: terminadoOrderByWithRelationInput | terminadoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: terminadoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` terminados from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` terminados.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned terminados
    **/
    _count?: true | TerminadoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TerminadoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TerminadoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TerminadoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TerminadoMaxAggregateInputType
  }

  export type GetTerminadoAggregateType<T extends TerminadoAggregateArgs> = {
        [P in keyof T & keyof AggregateTerminado]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTerminado[P]>
      : GetScalarType<T[P], AggregateTerminado[P]>
  }




  export type terminadoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: terminadoWhereInput
    orderBy?: terminadoOrderByWithAggregationInput | terminadoOrderByWithAggregationInput[]
    by: TerminadoScalarFieldEnum[] | TerminadoScalarFieldEnum
    having?: terminadoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TerminadoCountAggregateInputType | true
    _avg?: TerminadoAvgAggregateInputType
    _sum?: TerminadoSumAggregateInputType
    _min?: TerminadoMinAggregateInputType
    _max?: TerminadoMaxAggregateInputType
  }

  export type TerminadoGroupByOutputType = {
    idter: number
    nom: string | null
    punit: number | null
    idmar: number | null
    estado: boolean | null
    _count: TerminadoCountAggregateOutputType | null
    _avg: TerminadoAvgAggregateOutputType | null
    _sum: TerminadoSumAggregateOutputType | null
    _min: TerminadoMinAggregateOutputType | null
    _max: TerminadoMaxAggregateOutputType | null
  }

  type GetTerminadoGroupByPayload<T extends terminadoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TerminadoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TerminadoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TerminadoGroupByOutputType[P]>
            : GetScalarType<T[P], TerminadoGroupByOutputType[P]>
        }
      >
    >


  export type terminadoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idter?: boolean
    nom?: boolean
    punit?: boolean
    idmar?: boolean
    estado?: boolean
    marca?: boolean | terminado$marcaArgs<ExtArgs>
  }, ExtArgs["result"]["terminado"]>

  export type terminadoSelectScalar = {
    idter?: boolean
    nom?: boolean
    punit?: boolean
    idmar?: boolean
    estado?: boolean
  }

  export type terminadoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    marca?: boolean | terminado$marcaArgs<ExtArgs>
  }


  export type $terminadoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "terminado"
    objects: {
      marca: Prisma.$marcaPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      idter: number
      nom: string | null
      punit: number | null
      idmar: number | null
      estado: boolean | null
    }, ExtArgs["result"]["terminado"]>
    composites: {}
  }


  type terminadoGetPayload<S extends boolean | null | undefined | terminadoDefaultArgs> = $Result.GetResult<Prisma.$terminadoPayload, S>

  type terminadoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<terminadoFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: TerminadoCountAggregateInputType | true
    }

  export interface terminadoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['terminado'], meta: { name: 'terminado' } }
    /**
     * Find zero or one Terminado that matches the filter.
     * @param {terminadoFindUniqueArgs} args - Arguments to find a Terminado
     * @example
     * // Get one Terminado
     * const terminado = await prisma.terminado.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends terminadoFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, terminadoFindUniqueArgs<ExtArgs>>
    ): Prisma__terminadoClient<$Result.GetResult<Prisma.$terminadoPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Terminado that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {terminadoFindUniqueOrThrowArgs} args - Arguments to find a Terminado
     * @example
     * // Get one Terminado
     * const terminado = await prisma.terminado.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends terminadoFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, terminadoFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__terminadoClient<$Result.GetResult<Prisma.$terminadoPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Terminado that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {terminadoFindFirstArgs} args - Arguments to find a Terminado
     * @example
     * // Get one Terminado
     * const terminado = await prisma.terminado.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends terminadoFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, terminadoFindFirstArgs<ExtArgs>>
    ): Prisma__terminadoClient<$Result.GetResult<Prisma.$terminadoPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Terminado that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {terminadoFindFirstOrThrowArgs} args - Arguments to find a Terminado
     * @example
     * // Get one Terminado
     * const terminado = await prisma.terminado.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends terminadoFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, terminadoFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__terminadoClient<$Result.GetResult<Prisma.$terminadoPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Terminados that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {terminadoFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Terminados
     * const terminados = await prisma.terminado.findMany()
     * 
     * // Get first 10 Terminados
     * const terminados = await prisma.terminado.findMany({ take: 10 })
     * 
     * // Only select the `idter`
     * const terminadoWithIdterOnly = await prisma.terminado.findMany({ select: { idter: true } })
     * 
    **/
    findMany<T extends terminadoFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, terminadoFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$terminadoPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Terminado.
     * @param {terminadoCreateArgs} args - Arguments to create a Terminado.
     * @example
     * // Create one Terminado
     * const Terminado = await prisma.terminado.create({
     *   data: {
     *     // ... data to create a Terminado
     *   }
     * })
     * 
    **/
    create<T extends terminadoCreateArgs<ExtArgs>>(
      args: SelectSubset<T, terminadoCreateArgs<ExtArgs>>
    ): Prisma__terminadoClient<$Result.GetResult<Prisma.$terminadoPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Terminados.
     *     @param {terminadoCreateManyArgs} args - Arguments to create many Terminados.
     *     @example
     *     // Create many Terminados
     *     const terminado = await prisma.terminado.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends terminadoCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, terminadoCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Terminado.
     * @param {terminadoDeleteArgs} args - Arguments to delete one Terminado.
     * @example
     * // Delete one Terminado
     * const Terminado = await prisma.terminado.delete({
     *   where: {
     *     // ... filter to delete one Terminado
     *   }
     * })
     * 
    **/
    delete<T extends terminadoDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, terminadoDeleteArgs<ExtArgs>>
    ): Prisma__terminadoClient<$Result.GetResult<Prisma.$terminadoPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Terminado.
     * @param {terminadoUpdateArgs} args - Arguments to update one Terminado.
     * @example
     * // Update one Terminado
     * const terminado = await prisma.terminado.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends terminadoUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, terminadoUpdateArgs<ExtArgs>>
    ): Prisma__terminadoClient<$Result.GetResult<Prisma.$terminadoPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Terminados.
     * @param {terminadoDeleteManyArgs} args - Arguments to filter Terminados to delete.
     * @example
     * // Delete a few Terminados
     * const { count } = await prisma.terminado.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends terminadoDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, terminadoDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Terminados.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {terminadoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Terminados
     * const terminado = await prisma.terminado.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends terminadoUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, terminadoUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Terminado.
     * @param {terminadoUpsertArgs} args - Arguments to update or create a Terminado.
     * @example
     * // Update or create a Terminado
     * const terminado = await prisma.terminado.upsert({
     *   create: {
     *     // ... data to create a Terminado
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Terminado we want to update
     *   }
     * })
    **/
    upsert<T extends terminadoUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, terminadoUpsertArgs<ExtArgs>>
    ): Prisma__terminadoClient<$Result.GetResult<Prisma.$terminadoPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Terminados.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {terminadoCountArgs} args - Arguments to filter Terminados to count.
     * @example
     * // Count the number of Terminados
     * const count = await prisma.terminado.count({
     *   where: {
     *     // ... the filter for the Terminados we want to count
     *   }
     * })
    **/
    count<T extends terminadoCountArgs>(
      args?: Subset<T, terminadoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TerminadoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Terminado.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TerminadoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TerminadoAggregateArgs>(args: Subset<T, TerminadoAggregateArgs>): Prisma.PrismaPromise<GetTerminadoAggregateType<T>>

    /**
     * Group by Terminado.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {terminadoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends terminadoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: terminadoGroupByArgs['orderBy'] }
        : { orderBy?: terminadoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, terminadoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTerminadoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the terminado model
   */
  readonly fields: terminadoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for terminado.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__terminadoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    marca<T extends terminado$marcaArgs<ExtArgs> = {}>(args?: Subset<T, terminado$marcaArgs<ExtArgs>>): Prisma__marcaClient<$Result.GetResult<Prisma.$marcaPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the terminado model
   */ 
  interface terminadoFieldRefs {
    readonly idter: FieldRef<"terminado", 'Int'>
    readonly nom: FieldRef<"terminado", 'String'>
    readonly punit: FieldRef<"terminado", 'Float'>
    readonly idmar: FieldRef<"terminado", 'Int'>
    readonly estado: FieldRef<"terminado", 'Boolean'>
  }
    

  // Custom InputTypes

  /**
   * terminado findUnique
   */
  export type terminadoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the terminado
     */
    select?: terminadoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: terminadoInclude<ExtArgs> | null
    /**
     * Filter, which terminado to fetch.
     */
    where: terminadoWhereUniqueInput
  }


  /**
   * terminado findUniqueOrThrow
   */
  export type terminadoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the terminado
     */
    select?: terminadoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: terminadoInclude<ExtArgs> | null
    /**
     * Filter, which terminado to fetch.
     */
    where: terminadoWhereUniqueInput
  }


  /**
   * terminado findFirst
   */
  export type terminadoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the terminado
     */
    select?: terminadoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: terminadoInclude<ExtArgs> | null
    /**
     * Filter, which terminado to fetch.
     */
    where?: terminadoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of terminados to fetch.
     */
    orderBy?: terminadoOrderByWithRelationInput | terminadoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for terminados.
     */
    cursor?: terminadoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` terminados from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` terminados.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of terminados.
     */
    distinct?: TerminadoScalarFieldEnum | TerminadoScalarFieldEnum[]
  }


  /**
   * terminado findFirstOrThrow
   */
  export type terminadoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the terminado
     */
    select?: terminadoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: terminadoInclude<ExtArgs> | null
    /**
     * Filter, which terminado to fetch.
     */
    where?: terminadoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of terminados to fetch.
     */
    orderBy?: terminadoOrderByWithRelationInput | terminadoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for terminados.
     */
    cursor?: terminadoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` terminados from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` terminados.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of terminados.
     */
    distinct?: TerminadoScalarFieldEnum | TerminadoScalarFieldEnum[]
  }


  /**
   * terminado findMany
   */
  export type terminadoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the terminado
     */
    select?: terminadoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: terminadoInclude<ExtArgs> | null
    /**
     * Filter, which terminados to fetch.
     */
    where?: terminadoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of terminados to fetch.
     */
    orderBy?: terminadoOrderByWithRelationInput | terminadoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing terminados.
     */
    cursor?: terminadoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` terminados from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` terminados.
     */
    skip?: number
    distinct?: TerminadoScalarFieldEnum | TerminadoScalarFieldEnum[]
  }


  /**
   * terminado create
   */
  export type terminadoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the terminado
     */
    select?: terminadoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: terminadoInclude<ExtArgs> | null
    /**
     * The data needed to create a terminado.
     */
    data?: XOR<terminadoCreateInput, terminadoUncheckedCreateInput>
  }


  /**
   * terminado createMany
   */
  export type terminadoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many terminados.
     */
    data: terminadoCreateManyInput | terminadoCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * terminado update
   */
  export type terminadoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the terminado
     */
    select?: terminadoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: terminadoInclude<ExtArgs> | null
    /**
     * The data needed to update a terminado.
     */
    data: XOR<terminadoUpdateInput, terminadoUncheckedUpdateInput>
    /**
     * Choose, which terminado to update.
     */
    where: terminadoWhereUniqueInput
  }


  /**
   * terminado updateMany
   */
  export type terminadoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update terminados.
     */
    data: XOR<terminadoUpdateManyMutationInput, terminadoUncheckedUpdateManyInput>
    /**
     * Filter which terminados to update
     */
    where?: terminadoWhereInput
  }


  /**
   * terminado upsert
   */
  export type terminadoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the terminado
     */
    select?: terminadoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: terminadoInclude<ExtArgs> | null
    /**
     * The filter to search for the terminado to update in case it exists.
     */
    where: terminadoWhereUniqueInput
    /**
     * In case the terminado found by the `where` argument doesn't exist, create a new terminado with this data.
     */
    create: XOR<terminadoCreateInput, terminadoUncheckedCreateInput>
    /**
     * In case the terminado was found with the provided `where` argument, update it with this data.
     */
    update: XOR<terminadoUpdateInput, terminadoUncheckedUpdateInput>
  }


  /**
   * terminado delete
   */
  export type terminadoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the terminado
     */
    select?: terminadoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: terminadoInclude<ExtArgs> | null
    /**
     * Filter which terminado to delete.
     */
    where: terminadoWhereUniqueInput
  }


  /**
   * terminado deleteMany
   */
  export type terminadoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which terminados to delete
     */
    where?: terminadoWhereInput
  }


  /**
   * terminado.marca
   */
  export type terminado$marcaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the marca
     */
    select?: marcaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: marcaInclude<ExtArgs> | null
    where?: marcaWhereInput
  }


  /**
   * terminado without action
   */
  export type terminadoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the terminado
     */
    select?: terminadoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: terminadoInclude<ExtArgs> | null
  }



  /**
   * Model usuario
   */

  export type AggregateUsuario = {
    _count: UsuarioCountAggregateOutputType | null
    _avg: UsuarioAvgAggregateOutputType | null
    _sum: UsuarioSumAggregateOutputType | null
    _min: UsuarioMinAggregateOutputType | null
    _max: UsuarioMaxAggregateOutputType | null
  }

  export type UsuarioAvgAggregateOutputType = {
    idu: number | null
    idpe: number | null
    idem: number | null
  }

  export type UsuarioSumAggregateOutputType = {
    idu: number | null
    idpe: number | null
    idem: number | null
  }

  export type UsuarioMinAggregateOutputType = {
    idu: number | null
    sexo: string | null
    foto: Buffer | null
    fecnac: Date | null
    idpe: number | null
    estado: boolean | null
    idem: number | null
    base64: string | null
  }

  export type UsuarioMaxAggregateOutputType = {
    idu: number | null
    sexo: string | null
    foto: Buffer | null
    fecnac: Date | null
    idpe: number | null
    estado: boolean | null
    idem: number | null
    base64: string | null
  }

  export type UsuarioCountAggregateOutputType = {
    idu: number
    sexo: number
    foto: number
    fecnac: number
    idpe: number
    estado: number
    idem: number
    base64: number
    _all: number
  }


  export type UsuarioAvgAggregateInputType = {
    idu?: true
    idpe?: true
    idem?: true
  }

  export type UsuarioSumAggregateInputType = {
    idu?: true
    idpe?: true
    idem?: true
  }

  export type UsuarioMinAggregateInputType = {
    idu?: true
    sexo?: true
    foto?: true
    fecnac?: true
    idpe?: true
    estado?: true
    idem?: true
    base64?: true
  }

  export type UsuarioMaxAggregateInputType = {
    idu?: true
    sexo?: true
    foto?: true
    fecnac?: true
    idpe?: true
    estado?: true
    idem?: true
    base64?: true
  }

  export type UsuarioCountAggregateInputType = {
    idu?: true
    sexo?: true
    foto?: true
    fecnac?: true
    idpe?: true
    estado?: true
    idem?: true
    base64?: true
    _all?: true
  }

  export type UsuarioAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which usuario to aggregate.
     */
    where?: usuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of usuarios to fetch.
     */
    orderBy?: usuarioOrderByWithRelationInput | usuarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: usuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` usuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` usuarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned usuarios
    **/
    _count?: true | UsuarioCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UsuarioAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UsuarioSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UsuarioMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UsuarioMaxAggregateInputType
  }

  export type GetUsuarioAggregateType<T extends UsuarioAggregateArgs> = {
        [P in keyof T & keyof AggregateUsuario]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsuario[P]>
      : GetScalarType<T[P], AggregateUsuario[P]>
  }




  export type usuarioGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: usuarioWhereInput
    orderBy?: usuarioOrderByWithAggregationInput | usuarioOrderByWithAggregationInput[]
    by: UsuarioScalarFieldEnum[] | UsuarioScalarFieldEnum
    having?: usuarioScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UsuarioCountAggregateInputType | true
    _avg?: UsuarioAvgAggregateInputType
    _sum?: UsuarioSumAggregateInputType
    _min?: UsuarioMinAggregateInputType
    _max?: UsuarioMaxAggregateInputType
  }

  export type UsuarioGroupByOutputType = {
    idu: number
    sexo: string
    foto: Buffer | null
    fecnac: Date
    idpe: number
    estado: boolean | null
    idem: number | null
    base64: string | null
    _count: UsuarioCountAggregateOutputType | null
    _avg: UsuarioAvgAggregateOutputType | null
    _sum: UsuarioSumAggregateOutputType | null
    _min: UsuarioMinAggregateOutputType | null
    _max: UsuarioMaxAggregateOutputType | null
  }

  type GetUsuarioGroupByPayload<T extends usuarioGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UsuarioGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UsuarioGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UsuarioGroupByOutputType[P]>
            : GetScalarType<T[P], UsuarioGroupByOutputType[P]>
        }
      >
    >


  export type usuarioSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idu?: boolean
    sexo?: boolean
    foto?: boolean
    fecnac?: boolean
    idpe?: boolean
    estado?: boolean
    idem?: boolean
    base64?: boolean
    arte_arte_iduTousuario?: boolean | usuario$arte_arte_iduTousuarioArgs<ExtArgs>
    arte_arte_iduaTousuario?: boolean | usuario$arte_arte_iduaTousuarioArgs<ExtArgs>
    cotizacion?: boolean | usuario$cotizacionArgs<ExtArgs>
    datos?: boolean | usuario$datosArgs<ExtArgs>
    factura?: boolean | usuario$facturaArgs<ExtArgs>
    ordent?: boolean | usuario$ordentArgs<ExtArgs>
    registrolaboral?: boolean | usuario$registrolaboralArgs<ExtArgs>
    empresa?: boolean | usuario$empresaArgs<ExtArgs>
    persona?: boolean | personaDefaultArgs<ExtArgs>
    usurol?: boolean | usuario$usurolArgs<ExtArgs>
    _count?: boolean | UsuarioCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["usuario"]>

  export type usuarioSelectScalar = {
    idu?: boolean
    sexo?: boolean
    foto?: boolean
    fecnac?: boolean
    idpe?: boolean
    estado?: boolean
    idem?: boolean
    base64?: boolean
  }

  export type usuarioInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    arte_arte_iduTousuario?: boolean | usuario$arte_arte_iduTousuarioArgs<ExtArgs>
    arte_arte_iduaTousuario?: boolean | usuario$arte_arte_iduaTousuarioArgs<ExtArgs>
    cotizacion?: boolean | usuario$cotizacionArgs<ExtArgs>
    datos?: boolean | usuario$datosArgs<ExtArgs>
    factura?: boolean | usuario$facturaArgs<ExtArgs>
    ordent?: boolean | usuario$ordentArgs<ExtArgs>
    registrolaboral?: boolean | usuario$registrolaboralArgs<ExtArgs>
    empresa?: boolean | usuario$empresaArgs<ExtArgs>
    persona?: boolean | personaDefaultArgs<ExtArgs>
    usurol?: boolean | usuario$usurolArgs<ExtArgs>
    _count?: boolean | UsuarioCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $usuarioPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "usuario"
    objects: {
      arte_arte_iduTousuario: Prisma.$artePayload<ExtArgs>[]
      arte_arte_iduaTousuario: Prisma.$artePayload<ExtArgs>[]
      cotizacion: Prisma.$cotizacionPayload<ExtArgs>[]
      datos: Prisma.$datosPayload<ExtArgs>[]
      factura: Prisma.$facturaPayload<ExtArgs>[]
      ordent: Prisma.$ordentPayload<ExtArgs>[]
      registrolaboral: Prisma.$registrolaboralPayload<ExtArgs>[]
      empresa: Prisma.$empresaPayload<ExtArgs> | null
      persona: Prisma.$personaPayload<ExtArgs>
      usurol: Prisma.$usurolPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      idu: number
      sexo: string
      foto: Buffer | null
      fecnac: Date
      idpe: number
      estado: boolean | null
      idem: number | null
      base64: string | null
    }, ExtArgs["result"]["usuario"]>
    composites: {}
  }


  type usuarioGetPayload<S extends boolean | null | undefined | usuarioDefaultArgs> = $Result.GetResult<Prisma.$usuarioPayload, S>

  type usuarioCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<usuarioFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: UsuarioCountAggregateInputType | true
    }

  export interface usuarioDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['usuario'], meta: { name: 'usuario' } }
    /**
     * Find zero or one Usuario that matches the filter.
     * @param {usuarioFindUniqueArgs} args - Arguments to find a Usuario
     * @example
     * // Get one Usuario
     * const usuario = await prisma.usuario.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends usuarioFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, usuarioFindUniqueArgs<ExtArgs>>
    ): Prisma__usuarioClient<$Result.GetResult<Prisma.$usuarioPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Usuario that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {usuarioFindUniqueOrThrowArgs} args - Arguments to find a Usuario
     * @example
     * // Get one Usuario
     * const usuario = await prisma.usuario.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends usuarioFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, usuarioFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__usuarioClient<$Result.GetResult<Prisma.$usuarioPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Usuario that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usuarioFindFirstArgs} args - Arguments to find a Usuario
     * @example
     * // Get one Usuario
     * const usuario = await prisma.usuario.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends usuarioFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, usuarioFindFirstArgs<ExtArgs>>
    ): Prisma__usuarioClient<$Result.GetResult<Prisma.$usuarioPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Usuario that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usuarioFindFirstOrThrowArgs} args - Arguments to find a Usuario
     * @example
     * // Get one Usuario
     * const usuario = await prisma.usuario.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends usuarioFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, usuarioFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__usuarioClient<$Result.GetResult<Prisma.$usuarioPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Usuarios that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usuarioFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Usuarios
     * const usuarios = await prisma.usuario.findMany()
     * 
     * // Get first 10 Usuarios
     * const usuarios = await prisma.usuario.findMany({ take: 10 })
     * 
     * // Only select the `idu`
     * const usuarioWithIduOnly = await prisma.usuario.findMany({ select: { idu: true } })
     * 
    **/
    findMany<T extends usuarioFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, usuarioFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$usuarioPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Usuario.
     * @param {usuarioCreateArgs} args - Arguments to create a Usuario.
     * @example
     * // Create one Usuario
     * const Usuario = await prisma.usuario.create({
     *   data: {
     *     // ... data to create a Usuario
     *   }
     * })
     * 
    **/
    create<T extends usuarioCreateArgs<ExtArgs>>(
      args: SelectSubset<T, usuarioCreateArgs<ExtArgs>>
    ): Prisma__usuarioClient<$Result.GetResult<Prisma.$usuarioPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Usuarios.
     *     @param {usuarioCreateManyArgs} args - Arguments to create many Usuarios.
     *     @example
     *     // Create many Usuarios
     *     const usuario = await prisma.usuario.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends usuarioCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, usuarioCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Usuario.
     * @param {usuarioDeleteArgs} args - Arguments to delete one Usuario.
     * @example
     * // Delete one Usuario
     * const Usuario = await prisma.usuario.delete({
     *   where: {
     *     // ... filter to delete one Usuario
     *   }
     * })
     * 
    **/
    delete<T extends usuarioDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, usuarioDeleteArgs<ExtArgs>>
    ): Prisma__usuarioClient<$Result.GetResult<Prisma.$usuarioPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Usuario.
     * @param {usuarioUpdateArgs} args - Arguments to update one Usuario.
     * @example
     * // Update one Usuario
     * const usuario = await prisma.usuario.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends usuarioUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, usuarioUpdateArgs<ExtArgs>>
    ): Prisma__usuarioClient<$Result.GetResult<Prisma.$usuarioPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Usuarios.
     * @param {usuarioDeleteManyArgs} args - Arguments to filter Usuarios to delete.
     * @example
     * // Delete a few Usuarios
     * const { count } = await prisma.usuario.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends usuarioDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, usuarioDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Usuarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usuarioUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Usuarios
     * const usuario = await prisma.usuario.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends usuarioUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, usuarioUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Usuario.
     * @param {usuarioUpsertArgs} args - Arguments to update or create a Usuario.
     * @example
     * // Update or create a Usuario
     * const usuario = await prisma.usuario.upsert({
     *   create: {
     *     // ... data to create a Usuario
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Usuario we want to update
     *   }
     * })
    **/
    upsert<T extends usuarioUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, usuarioUpsertArgs<ExtArgs>>
    ): Prisma__usuarioClient<$Result.GetResult<Prisma.$usuarioPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Usuarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usuarioCountArgs} args - Arguments to filter Usuarios to count.
     * @example
     * // Count the number of Usuarios
     * const count = await prisma.usuario.count({
     *   where: {
     *     // ... the filter for the Usuarios we want to count
     *   }
     * })
    **/
    count<T extends usuarioCountArgs>(
      args?: Subset<T, usuarioCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UsuarioCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Usuario.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UsuarioAggregateArgs>(args: Subset<T, UsuarioAggregateArgs>): Prisma.PrismaPromise<GetUsuarioAggregateType<T>>

    /**
     * Group by Usuario.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usuarioGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends usuarioGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: usuarioGroupByArgs['orderBy'] }
        : { orderBy?: usuarioGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, usuarioGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsuarioGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the usuario model
   */
  readonly fields: usuarioFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for usuario.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__usuarioClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    arte_arte_iduTousuario<T extends usuario$arte_arte_iduTousuarioArgs<ExtArgs> = {}>(args?: Subset<T, usuario$arte_arte_iduTousuarioArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$artePayload<ExtArgs>, T, 'findMany'> | Null>;

    arte_arte_iduaTousuario<T extends usuario$arte_arte_iduaTousuarioArgs<ExtArgs> = {}>(args?: Subset<T, usuario$arte_arte_iduaTousuarioArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$artePayload<ExtArgs>, T, 'findMany'> | Null>;

    cotizacion<T extends usuario$cotizacionArgs<ExtArgs> = {}>(args?: Subset<T, usuario$cotizacionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$cotizacionPayload<ExtArgs>, T, 'findMany'> | Null>;

    datos<T extends usuario$datosArgs<ExtArgs> = {}>(args?: Subset<T, usuario$datosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$datosPayload<ExtArgs>, T, 'findMany'> | Null>;

    factura<T extends usuario$facturaArgs<ExtArgs> = {}>(args?: Subset<T, usuario$facturaArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$facturaPayload<ExtArgs>, T, 'findMany'> | Null>;

    ordent<T extends usuario$ordentArgs<ExtArgs> = {}>(args?: Subset<T, usuario$ordentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ordentPayload<ExtArgs>, T, 'findMany'> | Null>;

    registrolaboral<T extends usuario$registrolaboralArgs<ExtArgs> = {}>(args?: Subset<T, usuario$registrolaboralArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$registrolaboralPayload<ExtArgs>, T, 'findMany'> | Null>;

    empresa<T extends usuario$empresaArgs<ExtArgs> = {}>(args?: Subset<T, usuario$empresaArgs<ExtArgs>>): Prisma__empresaClient<$Result.GetResult<Prisma.$empresaPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    persona<T extends personaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, personaDefaultArgs<ExtArgs>>): Prisma__personaClient<$Result.GetResult<Prisma.$personaPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    usurol<T extends usuario$usurolArgs<ExtArgs> = {}>(args?: Subset<T, usuario$usurolArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$usurolPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the usuario model
   */ 
  interface usuarioFieldRefs {
    readonly idu: FieldRef<"usuario", 'Int'>
    readonly sexo: FieldRef<"usuario", 'String'>
    readonly foto: FieldRef<"usuario", 'Bytes'>
    readonly fecnac: FieldRef<"usuario", 'DateTime'>
    readonly idpe: FieldRef<"usuario", 'Int'>
    readonly estado: FieldRef<"usuario", 'Boolean'>
    readonly idem: FieldRef<"usuario", 'Int'>
    readonly base64: FieldRef<"usuario", 'String'>
  }
    

  // Custom InputTypes

  /**
   * usuario findUnique
   */
  export type usuarioFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usuario
     */
    select?: usuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: usuarioInclude<ExtArgs> | null
    /**
     * Filter, which usuario to fetch.
     */
    where: usuarioWhereUniqueInput
  }


  /**
   * usuario findUniqueOrThrow
   */
  export type usuarioFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usuario
     */
    select?: usuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: usuarioInclude<ExtArgs> | null
    /**
     * Filter, which usuario to fetch.
     */
    where: usuarioWhereUniqueInput
  }


  /**
   * usuario findFirst
   */
  export type usuarioFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usuario
     */
    select?: usuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: usuarioInclude<ExtArgs> | null
    /**
     * Filter, which usuario to fetch.
     */
    where?: usuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of usuarios to fetch.
     */
    orderBy?: usuarioOrderByWithRelationInput | usuarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for usuarios.
     */
    cursor?: usuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` usuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` usuarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of usuarios.
     */
    distinct?: UsuarioScalarFieldEnum | UsuarioScalarFieldEnum[]
  }


  /**
   * usuario findFirstOrThrow
   */
  export type usuarioFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usuario
     */
    select?: usuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: usuarioInclude<ExtArgs> | null
    /**
     * Filter, which usuario to fetch.
     */
    where?: usuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of usuarios to fetch.
     */
    orderBy?: usuarioOrderByWithRelationInput | usuarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for usuarios.
     */
    cursor?: usuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` usuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` usuarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of usuarios.
     */
    distinct?: UsuarioScalarFieldEnum | UsuarioScalarFieldEnum[]
  }


  /**
   * usuario findMany
   */
  export type usuarioFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usuario
     */
    select?: usuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: usuarioInclude<ExtArgs> | null
    /**
     * Filter, which usuarios to fetch.
     */
    where?: usuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of usuarios to fetch.
     */
    orderBy?: usuarioOrderByWithRelationInput | usuarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing usuarios.
     */
    cursor?: usuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` usuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` usuarios.
     */
    skip?: number
    distinct?: UsuarioScalarFieldEnum | UsuarioScalarFieldEnum[]
  }


  /**
   * usuario create
   */
  export type usuarioCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usuario
     */
    select?: usuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: usuarioInclude<ExtArgs> | null
    /**
     * The data needed to create a usuario.
     */
    data: XOR<usuarioCreateInput, usuarioUncheckedCreateInput>
  }


  /**
   * usuario createMany
   */
  export type usuarioCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many usuarios.
     */
    data: usuarioCreateManyInput | usuarioCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * usuario update
   */
  export type usuarioUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usuario
     */
    select?: usuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: usuarioInclude<ExtArgs> | null
    /**
     * The data needed to update a usuario.
     */
    data: XOR<usuarioUpdateInput, usuarioUncheckedUpdateInput>
    /**
     * Choose, which usuario to update.
     */
    where: usuarioWhereUniqueInput
  }


  /**
   * usuario updateMany
   */
  export type usuarioUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update usuarios.
     */
    data: XOR<usuarioUpdateManyMutationInput, usuarioUncheckedUpdateManyInput>
    /**
     * Filter which usuarios to update
     */
    where?: usuarioWhereInput
  }


  /**
   * usuario upsert
   */
  export type usuarioUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usuario
     */
    select?: usuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: usuarioInclude<ExtArgs> | null
    /**
     * The filter to search for the usuario to update in case it exists.
     */
    where: usuarioWhereUniqueInput
    /**
     * In case the usuario found by the `where` argument doesn't exist, create a new usuario with this data.
     */
    create: XOR<usuarioCreateInput, usuarioUncheckedCreateInput>
    /**
     * In case the usuario was found with the provided `where` argument, update it with this data.
     */
    update: XOR<usuarioUpdateInput, usuarioUncheckedUpdateInput>
  }


  /**
   * usuario delete
   */
  export type usuarioDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usuario
     */
    select?: usuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: usuarioInclude<ExtArgs> | null
    /**
     * Filter which usuario to delete.
     */
    where: usuarioWhereUniqueInput
  }


  /**
   * usuario deleteMany
   */
  export type usuarioDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which usuarios to delete
     */
    where?: usuarioWhereInput
  }


  /**
   * usuario.arte_arte_iduTousuario
   */
  export type usuario$arte_arte_iduTousuarioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the arte
     */
    select?: arteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: arteInclude<ExtArgs> | null
    where?: arteWhereInput
    orderBy?: arteOrderByWithRelationInput | arteOrderByWithRelationInput[]
    cursor?: arteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ArteScalarFieldEnum | ArteScalarFieldEnum[]
  }


  /**
   * usuario.arte_arte_iduaTousuario
   */
  export type usuario$arte_arte_iduaTousuarioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the arte
     */
    select?: arteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: arteInclude<ExtArgs> | null
    where?: arteWhereInput
    orderBy?: arteOrderByWithRelationInput | arteOrderByWithRelationInput[]
    cursor?: arteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ArteScalarFieldEnum | ArteScalarFieldEnum[]
  }


  /**
   * usuario.cotizacion
   */
  export type usuario$cotizacionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cotizacion
     */
    select?: cotizacionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: cotizacionInclude<ExtArgs> | null
    where?: cotizacionWhereInput
    orderBy?: cotizacionOrderByWithRelationInput | cotizacionOrderByWithRelationInput[]
    cursor?: cotizacionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CotizacionScalarFieldEnum | CotizacionScalarFieldEnum[]
  }


  /**
   * usuario.datos
   */
  export type usuario$datosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the datos
     */
    select?: datosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: datosInclude<ExtArgs> | null
    where?: datosWhereInput
    orderBy?: datosOrderByWithRelationInput | datosOrderByWithRelationInput[]
    cursor?: datosWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DatosScalarFieldEnum | DatosScalarFieldEnum[]
  }


  /**
   * usuario.factura
   */
  export type usuario$facturaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the factura
     */
    select?: facturaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: facturaInclude<ExtArgs> | null
    where?: facturaWhereInput
    orderBy?: facturaOrderByWithRelationInput | facturaOrderByWithRelationInput[]
    cursor?: facturaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FacturaScalarFieldEnum | FacturaScalarFieldEnum[]
  }


  /**
   * usuario.ordent
   */
  export type usuario$ordentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ordent
     */
    select?: ordentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ordentInclude<ExtArgs> | null
    where?: ordentWhereInput
    orderBy?: ordentOrderByWithRelationInput | ordentOrderByWithRelationInput[]
    cursor?: ordentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrdentScalarFieldEnum | OrdentScalarFieldEnum[]
  }


  /**
   * usuario.registrolaboral
   */
  export type usuario$registrolaboralArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the registrolaboral
     */
    select?: registrolaboralSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: registrolaboralInclude<ExtArgs> | null
    where?: registrolaboralWhereInput
    orderBy?: registrolaboralOrderByWithRelationInput | registrolaboralOrderByWithRelationInput[]
    cursor?: registrolaboralWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RegistrolaboralScalarFieldEnum | RegistrolaboralScalarFieldEnum[]
  }


  /**
   * usuario.empresa
   */
  export type usuario$empresaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the empresa
     */
    select?: empresaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: empresaInclude<ExtArgs> | null
    where?: empresaWhereInput
  }


  /**
   * usuario.usurol
   */
  export type usuario$usurolArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usurol
     */
    select?: usurolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: usurolInclude<ExtArgs> | null
    where?: usurolWhereInput
    orderBy?: usurolOrderByWithRelationInput | usurolOrderByWithRelationInput[]
    cursor?: usurolWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UsurolScalarFieldEnum | UsurolScalarFieldEnum[]
  }


  /**
   * usuario without action
   */
  export type usuarioDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usuario
     */
    select?: usuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: usuarioInclude<ExtArgs> | null
  }



  /**
   * Model usurol
   */

  export type AggregateUsurol = {
    _count: UsurolCountAggregateOutputType | null
    _avg: UsurolAvgAggregateOutputType | null
    _sum: UsurolSumAggregateOutputType | null
    _min: UsurolMinAggregateOutputType | null
    _max: UsurolMaxAggregateOutputType | null
  }

  export type UsurolAvgAggregateOutputType = {
    idr: number | null
    idu: number | null
  }

  export type UsurolSumAggregateOutputType = {
    idr: number | null
    idu: number | null
  }

  export type UsurolMinAggregateOutputType = {
    idr: number | null
    idu: number | null
  }

  export type UsurolMaxAggregateOutputType = {
    idr: number | null
    idu: number | null
  }

  export type UsurolCountAggregateOutputType = {
    idr: number
    idu: number
    _all: number
  }


  export type UsurolAvgAggregateInputType = {
    idr?: true
    idu?: true
  }

  export type UsurolSumAggregateInputType = {
    idr?: true
    idu?: true
  }

  export type UsurolMinAggregateInputType = {
    idr?: true
    idu?: true
  }

  export type UsurolMaxAggregateInputType = {
    idr?: true
    idu?: true
  }

  export type UsurolCountAggregateInputType = {
    idr?: true
    idu?: true
    _all?: true
  }

  export type UsurolAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which usurol to aggregate.
     */
    where?: usurolWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of usurols to fetch.
     */
    orderBy?: usurolOrderByWithRelationInput | usurolOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: usurolWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` usurols from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` usurols.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned usurols
    **/
    _count?: true | UsurolCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UsurolAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UsurolSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UsurolMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UsurolMaxAggregateInputType
  }

  export type GetUsurolAggregateType<T extends UsurolAggregateArgs> = {
        [P in keyof T & keyof AggregateUsurol]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsurol[P]>
      : GetScalarType<T[P], AggregateUsurol[P]>
  }




  export type usurolGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: usurolWhereInput
    orderBy?: usurolOrderByWithAggregationInput | usurolOrderByWithAggregationInput[]
    by: UsurolScalarFieldEnum[] | UsurolScalarFieldEnum
    having?: usurolScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UsurolCountAggregateInputType | true
    _avg?: UsurolAvgAggregateInputType
    _sum?: UsurolSumAggregateInputType
    _min?: UsurolMinAggregateInputType
    _max?: UsurolMaxAggregateInputType
  }

  export type UsurolGroupByOutputType = {
    idr: number
    idu: number
    _count: UsurolCountAggregateOutputType | null
    _avg: UsurolAvgAggregateOutputType | null
    _sum: UsurolSumAggregateOutputType | null
    _min: UsurolMinAggregateOutputType | null
    _max: UsurolMaxAggregateOutputType | null
  }

  type GetUsurolGroupByPayload<T extends usurolGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UsurolGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UsurolGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UsurolGroupByOutputType[P]>
            : GetScalarType<T[P], UsurolGroupByOutputType[P]>
        }
      >
    >


  export type usurolSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idr?: boolean
    idu?: boolean
    roles?: boolean | rolesDefaultArgs<ExtArgs>
    usuario?: boolean | usuarioDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["usurol"]>

  export type usurolSelectScalar = {
    idr?: boolean
    idu?: boolean
  }

  export type usurolInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    roles?: boolean | rolesDefaultArgs<ExtArgs>
    usuario?: boolean | usuarioDefaultArgs<ExtArgs>
  }


  export type $usurolPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "usurol"
    objects: {
      roles: Prisma.$rolesPayload<ExtArgs>
      usuario: Prisma.$usuarioPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      idr: number
      idu: number
    }, ExtArgs["result"]["usurol"]>
    composites: {}
  }


  type usurolGetPayload<S extends boolean | null | undefined | usurolDefaultArgs> = $Result.GetResult<Prisma.$usurolPayload, S>

  type usurolCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<usurolFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: UsurolCountAggregateInputType | true
    }

  export interface usurolDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['usurol'], meta: { name: 'usurol' } }
    /**
     * Find zero or one Usurol that matches the filter.
     * @param {usurolFindUniqueArgs} args - Arguments to find a Usurol
     * @example
     * // Get one Usurol
     * const usurol = await prisma.usurol.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends usurolFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, usurolFindUniqueArgs<ExtArgs>>
    ): Prisma__usurolClient<$Result.GetResult<Prisma.$usurolPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Usurol that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {usurolFindUniqueOrThrowArgs} args - Arguments to find a Usurol
     * @example
     * // Get one Usurol
     * const usurol = await prisma.usurol.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends usurolFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, usurolFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__usurolClient<$Result.GetResult<Prisma.$usurolPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Usurol that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usurolFindFirstArgs} args - Arguments to find a Usurol
     * @example
     * // Get one Usurol
     * const usurol = await prisma.usurol.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends usurolFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, usurolFindFirstArgs<ExtArgs>>
    ): Prisma__usurolClient<$Result.GetResult<Prisma.$usurolPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Usurol that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usurolFindFirstOrThrowArgs} args - Arguments to find a Usurol
     * @example
     * // Get one Usurol
     * const usurol = await prisma.usurol.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends usurolFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, usurolFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__usurolClient<$Result.GetResult<Prisma.$usurolPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Usurols that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usurolFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Usurols
     * const usurols = await prisma.usurol.findMany()
     * 
     * // Get first 10 Usurols
     * const usurols = await prisma.usurol.findMany({ take: 10 })
     * 
     * // Only select the `idr`
     * const usurolWithIdrOnly = await prisma.usurol.findMany({ select: { idr: true } })
     * 
    **/
    findMany<T extends usurolFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, usurolFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$usurolPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Usurol.
     * @param {usurolCreateArgs} args - Arguments to create a Usurol.
     * @example
     * // Create one Usurol
     * const Usurol = await prisma.usurol.create({
     *   data: {
     *     // ... data to create a Usurol
     *   }
     * })
     * 
    **/
    create<T extends usurolCreateArgs<ExtArgs>>(
      args: SelectSubset<T, usurolCreateArgs<ExtArgs>>
    ): Prisma__usurolClient<$Result.GetResult<Prisma.$usurolPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Usurols.
     *     @param {usurolCreateManyArgs} args - Arguments to create many Usurols.
     *     @example
     *     // Create many Usurols
     *     const usurol = await prisma.usurol.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends usurolCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, usurolCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Usurol.
     * @param {usurolDeleteArgs} args - Arguments to delete one Usurol.
     * @example
     * // Delete one Usurol
     * const Usurol = await prisma.usurol.delete({
     *   where: {
     *     // ... filter to delete one Usurol
     *   }
     * })
     * 
    **/
    delete<T extends usurolDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, usurolDeleteArgs<ExtArgs>>
    ): Prisma__usurolClient<$Result.GetResult<Prisma.$usurolPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Usurol.
     * @param {usurolUpdateArgs} args - Arguments to update one Usurol.
     * @example
     * // Update one Usurol
     * const usurol = await prisma.usurol.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends usurolUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, usurolUpdateArgs<ExtArgs>>
    ): Prisma__usurolClient<$Result.GetResult<Prisma.$usurolPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Usurols.
     * @param {usurolDeleteManyArgs} args - Arguments to filter Usurols to delete.
     * @example
     * // Delete a few Usurols
     * const { count } = await prisma.usurol.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends usurolDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, usurolDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Usurols.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usurolUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Usurols
     * const usurol = await prisma.usurol.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends usurolUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, usurolUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Usurol.
     * @param {usurolUpsertArgs} args - Arguments to update or create a Usurol.
     * @example
     * // Update or create a Usurol
     * const usurol = await prisma.usurol.upsert({
     *   create: {
     *     // ... data to create a Usurol
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Usurol we want to update
     *   }
     * })
    **/
    upsert<T extends usurolUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, usurolUpsertArgs<ExtArgs>>
    ): Prisma__usurolClient<$Result.GetResult<Prisma.$usurolPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Usurols.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usurolCountArgs} args - Arguments to filter Usurols to count.
     * @example
     * // Count the number of Usurols
     * const count = await prisma.usurol.count({
     *   where: {
     *     // ... the filter for the Usurols we want to count
     *   }
     * })
    **/
    count<T extends usurolCountArgs>(
      args?: Subset<T, usurolCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UsurolCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Usurol.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsurolAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UsurolAggregateArgs>(args: Subset<T, UsurolAggregateArgs>): Prisma.PrismaPromise<GetUsurolAggregateType<T>>

    /**
     * Group by Usurol.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usurolGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends usurolGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: usurolGroupByArgs['orderBy'] }
        : { orderBy?: usurolGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, usurolGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsurolGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the usurol model
   */
  readonly fields: usurolFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for usurol.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__usurolClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    roles<T extends rolesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, rolesDefaultArgs<ExtArgs>>): Prisma__rolesClient<$Result.GetResult<Prisma.$rolesPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    usuario<T extends usuarioDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usuarioDefaultArgs<ExtArgs>>): Prisma__usuarioClient<$Result.GetResult<Prisma.$usuarioPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the usurol model
   */ 
  interface usurolFieldRefs {
    readonly idr: FieldRef<"usurol", 'Int'>
    readonly idu: FieldRef<"usurol", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * usurol findUnique
   */
  export type usurolFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usurol
     */
    select?: usurolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: usurolInclude<ExtArgs> | null
    /**
     * Filter, which usurol to fetch.
     */
    where: usurolWhereUniqueInput
  }


  /**
   * usurol findUniqueOrThrow
   */
  export type usurolFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usurol
     */
    select?: usurolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: usurolInclude<ExtArgs> | null
    /**
     * Filter, which usurol to fetch.
     */
    where: usurolWhereUniqueInput
  }


  /**
   * usurol findFirst
   */
  export type usurolFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usurol
     */
    select?: usurolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: usurolInclude<ExtArgs> | null
    /**
     * Filter, which usurol to fetch.
     */
    where?: usurolWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of usurols to fetch.
     */
    orderBy?: usurolOrderByWithRelationInput | usurolOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for usurols.
     */
    cursor?: usurolWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` usurols from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` usurols.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of usurols.
     */
    distinct?: UsurolScalarFieldEnum | UsurolScalarFieldEnum[]
  }


  /**
   * usurol findFirstOrThrow
   */
  export type usurolFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usurol
     */
    select?: usurolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: usurolInclude<ExtArgs> | null
    /**
     * Filter, which usurol to fetch.
     */
    where?: usurolWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of usurols to fetch.
     */
    orderBy?: usurolOrderByWithRelationInput | usurolOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for usurols.
     */
    cursor?: usurolWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` usurols from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` usurols.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of usurols.
     */
    distinct?: UsurolScalarFieldEnum | UsurolScalarFieldEnum[]
  }


  /**
   * usurol findMany
   */
  export type usurolFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usurol
     */
    select?: usurolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: usurolInclude<ExtArgs> | null
    /**
     * Filter, which usurols to fetch.
     */
    where?: usurolWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of usurols to fetch.
     */
    orderBy?: usurolOrderByWithRelationInput | usurolOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing usurols.
     */
    cursor?: usurolWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` usurols from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` usurols.
     */
    skip?: number
    distinct?: UsurolScalarFieldEnum | UsurolScalarFieldEnum[]
  }


  /**
   * usurol create
   */
  export type usurolCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usurol
     */
    select?: usurolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: usurolInclude<ExtArgs> | null
    /**
     * The data needed to create a usurol.
     */
    data: XOR<usurolCreateInput, usurolUncheckedCreateInput>
  }


  /**
   * usurol createMany
   */
  export type usurolCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many usurols.
     */
    data: usurolCreateManyInput | usurolCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * usurol update
   */
  export type usurolUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usurol
     */
    select?: usurolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: usurolInclude<ExtArgs> | null
    /**
     * The data needed to update a usurol.
     */
    data: XOR<usurolUpdateInput, usurolUncheckedUpdateInput>
    /**
     * Choose, which usurol to update.
     */
    where: usurolWhereUniqueInput
  }


  /**
   * usurol updateMany
   */
  export type usurolUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update usurols.
     */
    data: XOR<usurolUpdateManyMutationInput, usurolUncheckedUpdateManyInput>
    /**
     * Filter which usurols to update
     */
    where?: usurolWhereInput
  }


  /**
   * usurol upsert
   */
  export type usurolUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usurol
     */
    select?: usurolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: usurolInclude<ExtArgs> | null
    /**
     * The filter to search for the usurol to update in case it exists.
     */
    where: usurolWhereUniqueInput
    /**
     * In case the usurol found by the `where` argument doesn't exist, create a new usurol with this data.
     */
    create: XOR<usurolCreateInput, usurolUncheckedCreateInput>
    /**
     * In case the usurol was found with the provided `where` argument, update it with this data.
     */
    update: XOR<usurolUpdateInput, usurolUncheckedUpdateInput>
  }


  /**
   * usurol delete
   */
  export type usurolDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usurol
     */
    select?: usurolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: usurolInclude<ExtArgs> | null
    /**
     * Filter which usurol to delete.
     */
    where: usurolWhereUniqueInput
  }


  /**
   * usurol deleteMany
   */
  export type usurolDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which usurols to delete
     */
    where?: usurolWhereInput
  }


  /**
   * usurol without action
   */
  export type usurolDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usurol
     */
    select?: usurolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: usurolInclude<ExtArgs> | null
  }



  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const ArteScalarFieldEnum: {
    idar: 'idar',
    idu: 'idu',
    idot: 'idot',
    fechar: 'fechar',
    fechaa: 'fechaa',
    idua: 'idua',
    estado: 'estado',
    obs: 'obs',
    precio: 'precio'
  };

  export type ArteScalarFieldEnum = (typeof ArteScalarFieldEnum)[keyof typeof ArteScalarFieldEnum]


  export const ClienteScalarFieldEnum: {
    idcli: 'idcli',
    idpe: 'idpe',
    estado: 'estado'
  };

  export type ClienteScalarFieldEnum = (typeof ClienteScalarFieldEnum)[keyof typeof ClienteScalarFieldEnum]


  export const ColorScalarFieldEnum: {
    idcolor: 'idcolor',
    nom: 'nom',
    punit: 'punit',
    idmar: 'idmar',
    estado: 'estado',
    des: 'des'
  };

  export type ColorScalarFieldEnum = (typeof ColorScalarFieldEnum)[keyof typeof ColorScalarFieldEnum]


  export const ConfiguracionlaboralScalarFieldEnum: {
    idconf: 'idconf',
    entrada: 'entrada',
    salida: 'salida',
    tipo: 'tipo',
    retrasopermitido: 'retrasopermitido',
    adicional: 'adicional',
    adicional1: 'adicional1'
  };

  export type ConfiguracionlaboralScalarFieldEnum = (typeof ConfiguracionlaboralScalarFieldEnum)[keyof typeof ConfiguracionlaboralScalarFieldEnum]


  export const CotizacionScalarFieldEnum: {
    idcot: 'idcot',
    idu: 'idu',
    idcli: 'idcli',
    fecha: 'fecha',
    precio: 'precio',
    descuento: 'descuento',
    preciofinal: 'preciofinal',
    tiempo: 'tiempo',
    arte: 'arte',
    obs: 'obs',
    estado: 'estado'
  };

  export type CotizacionScalarFieldEnum = (typeof CotizacionScalarFieldEnum)[keyof typeof CotizacionScalarFieldEnum]


  export const DatosScalarFieldEnum: {
    idu: 'idu',
    login: 'login',
    contrasenia: 'contrasenia'
  };

  export type DatosScalarFieldEnum = (typeof DatosScalarFieldEnum)[keyof typeof DatosScalarFieldEnum]


  export const DetcotScalarFieldEnum: {
    iddetcot: 'iddetcot',
    idcot: 'idcot',
    idpro: 'idpro',
    cant: 'cant',
    punit: 'punit',
    stotal: 'stotal',
    material: 'material',
    gr: 'gr',
    tintas: 'tintas',
    estado: 'estado'
  };

  export type DetcotScalarFieldEnum = (typeof DetcotScalarFieldEnum)[keyof typeof DetcotScalarFieldEnum]


  export const DetotScalarFieldEnum: {
    iddetot: 'iddetot',
    idot: 'idot',
    idpro: 'idpro',
    cant: 'cant',
    punit: 'punit',
    stotal: 'stotal',
    material: 'material',
    gr: 'gr',
    tintas: 'tintas',
    estado: 'estado'
  };

  export type DetotScalarFieldEnum = (typeof DetotScalarFieldEnum)[keyof typeof DetotScalarFieldEnum]


  export const EmpresaScalarFieldEnum: {
    idem: 'idem',
    nom: 'nom',
    dir: 'dir',
    des: 'des',
    dep: 'dep',
    logo: 'logo',
    idpe: 'idpe',
    nit: 'nit',
    auto: 'auto',
    base64: 'base64'
  };

  export type EmpresaScalarFieldEnum = (typeof EmpresaScalarFieldEnum)[keyof typeof EmpresaScalarFieldEnum]


  export const EventosScalarFieldEnum: {
    idev: 'idev',
    fechainicio: 'fechainicio',
    fechafin: 'fechafin',
    tipo: 'tipo',
    evento: 'evento',
    adicional: 'adicional',
    adicional1: 'adicional1',
    estado: 'estado'
  };

  export type EventosScalarFieldEnum = (typeof EventosScalarFieldEnum)[keyof typeof EventosScalarFieldEnum]


  export const FacturaScalarFieldEnum: {
    idfac: 'idfac',
    idot: 'idot',
    idu: 'idu',
    monto: 'monto',
    fecha: 'fecha',
    aux: 'aux',
    aux1: 'aux1'
  };

  export type FacturaScalarFieldEnum = (typeof FacturaScalarFieldEnum)[keyof typeof FacturaScalarFieldEnum]


  export const InventarioScalarFieldEnum: {
    idin: 'idin',
    idprov: 'idprov',
    codigo: 'codigo',
    nom: 'nom',
    precio: 'precio',
    gr: 'gr',
    tam: 'tam',
    des: 'des',
    cant: 'cant',
    estado: 'estado'
  };

  export type InventarioScalarFieldEnum = (typeof InventarioScalarFieldEnum)[keyof typeof InventarioScalarFieldEnum]


  export const LeyendaScalarFieldEnum: {
    idle: 'idle',
    des: 'des',
    orden: 'orden',
    idem: 'idem'
  };

  export type LeyendaScalarFieldEnum = (typeof LeyendaScalarFieldEnum)[keyof typeof LeyendaScalarFieldEnum]


  export const MarcaScalarFieldEnum: {
    idmar: 'idmar',
    nom: 'nom',
    des: 'des',
    estado: 'estado'
  };

  export type MarcaScalarFieldEnum = (typeof MarcaScalarFieldEnum)[keyof typeof MarcaScalarFieldEnum]


  export const MenuScalarFieldEnum: {
    idm: 'idm',
    nom: 'nom',
    url: 'url',
    estado: 'estado'
  };

  export type MenuScalarFieldEnum = (typeof MenuScalarFieldEnum)[keyof typeof MenuScalarFieldEnum]


  export const OrdentScalarFieldEnum: {
    idot: 'idot',
    idu: 'idu',
    idcli: 'idcli',
    idcot: 'idcot',
    fecha: 'fecha',
    precio: 'precio',
    descuento: 'descuento',
    preciofinal: 'preciofinal',
    tiempo: 'tiempo',
    arte: 'arte',
    obs: 'obs',
    estado: 'estado',
    factura: 'factura'
  };

  export type OrdentScalarFieldEnum = (typeof OrdentScalarFieldEnum)[keyof typeof OrdentScalarFieldEnum]


  export const PagoScalarFieldEnum: {
    idpagp: 'idpagp',
    idot: 'idot',
    fecha: 'fecha',
    preciof: 'preciof',
    pago: 'pago',
    saldo: 'saldo',
    des: 'des',
    comprobante: 'comprobante'
  };

  export type PagoScalarFieldEnum = (typeof PagoScalarFieldEnum)[keyof typeof PagoScalarFieldEnum]


  export const PersonaScalarFieldEnum: {
    idpe: 'idpe',
    ci: 'ci',
    nombre: 'nombre',
    ap: 'ap',
    am: 'am',
    direccion: 'direccion',
    email: 'email',
    estado: 'estado',
    base64: 'base64'
  };

  export type PersonaScalarFieldEnum = (typeof PersonaScalarFieldEnum)[keyof typeof PersonaScalarFieldEnum]


  export const ProductoScalarFieldEnum: {
    idpro: 'idpro',
    nom: 'nom',
    tam: 'tam',
    des: 'des',
    preciov: 'preciov',
    precioc: 'precioc',
    cantidad: 'cantidad',
    foto: 'foto',
    idmar: 'idmar',
    estado: 'estado',
    base64: 'base64',
    ranking: 'ranking'
  };

  export type ProductoScalarFieldEnum = (typeof ProductoScalarFieldEnum)[keyof typeof ProductoScalarFieldEnum]


  export const ProveedorScalarFieldEnum: {
    idprov: 'idprov',
    nom: 'nom',
    dir: 'dir',
    dep: 'dep',
    logo: 'logo',
    idpe: 'idpe',
    estado: 'estado',
    nit: 'nit'
  };

  export type ProveedorScalarFieldEnum = (typeof ProveedorScalarFieldEnum)[keyof typeof ProveedorScalarFieldEnum]


  export const RegistrolaboralScalarFieldEnum: {
    idre: 'idre',
    idu: 'idu',
    tiporegistro: 'tiporegistro',
    fecha: 'fecha',
    hora: 'hora',
    mes: 'mes',
    estado: 'estado',
    adicional: 'adicional',
    adicional2: 'adicional2',
    atraso: 'atraso'
  };

  export type RegistrolaboralScalarFieldEnum = (typeof RegistrolaboralScalarFieldEnum)[keyof typeof RegistrolaboralScalarFieldEnum]


  export const RolesScalarFieldEnum: {
    idr: 'idr',
    nombre: 'nombre',
    descrip: 'descrip',
    jerarquia: 'jerarquia',
    estado: 'estado'
  };

  export type RolesScalarFieldEnum = (typeof RolesScalarFieldEnum)[keyof typeof RolesScalarFieldEnum]


  export const RolmenuScalarFieldEnum: {
    idr: 'idr',
    idm: 'idm'
  };

  export type RolmenuScalarFieldEnum = (typeof RolmenuScalarFieldEnum)[keyof typeof RolmenuScalarFieldEnum]


  export const TelefonoScalarFieldEnum: {
    idtel: 'idtel',
    idpe: 'idpe',
    numero: 'numero',
    estado: 'estado'
  };

  export type TelefonoScalarFieldEnum = (typeof TelefonoScalarFieldEnum)[keyof typeof TelefonoScalarFieldEnum]


  export const TerminadoScalarFieldEnum: {
    idter: 'idter',
    nom: 'nom',
    punit: 'punit',
    idmar: 'idmar',
    estado: 'estado'
  };

  export type TerminadoScalarFieldEnum = (typeof TerminadoScalarFieldEnum)[keyof typeof TerminadoScalarFieldEnum]


  export const UsuarioScalarFieldEnum: {
    idu: 'idu',
    sexo: 'sexo',
    foto: 'foto',
    fecnac: 'fecnac',
    idpe: 'idpe',
    estado: 'estado',
    idem: 'idem',
    base64: 'base64'
  };

  export type UsuarioScalarFieldEnum = (typeof UsuarioScalarFieldEnum)[keyof typeof UsuarioScalarFieldEnum]


  export const UsurolScalarFieldEnum: {
    idr: 'idr',
    idu: 'idu'
  };

  export type UsurolScalarFieldEnum = (typeof UsurolScalarFieldEnum)[keyof typeof UsurolScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Bytes'
   */
  export type BytesFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Bytes'>
    


  /**
   * Reference to a field of type 'Bytes[]'
   */
  export type ListBytesFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Bytes[]'>
    
  /**
   * Deep Input Types
   */


  export type arteWhereInput = {
    AND?: arteWhereInput | arteWhereInput[]
    OR?: arteWhereInput[]
    NOT?: arteWhereInput | arteWhereInput[]
    idar?: IntFilter<"arte"> | number
    idu?: IntNullableFilter<"arte"> | number | null
    idot?: IntNullableFilter<"arte"> | number | null
    fechar?: DateTimeNullableFilter<"arte"> | Date | string | null
    fechaa?: DateTimeNullableFilter<"arte"> | Date | string | null
    idua?: IntNullableFilter<"arte"> | number | null
    estado?: StringNullableFilter<"arte"> | string | null
    obs?: StringNullableFilter<"arte"> | string | null
    precio?: FloatNullableFilter<"arte"> | number | null
    ordent?: XOR<OrdentNullableRelationFilter, ordentWhereInput> | null
    usuario_arte_iduTousuario?: XOR<UsuarioNullableRelationFilter, usuarioWhereInput> | null
    usuario_arte_iduaTousuario?: XOR<UsuarioNullableRelationFilter, usuarioWhereInput> | null
  }

  export type arteOrderByWithRelationInput = {
    idar?: SortOrder
    idu?: SortOrderInput | SortOrder
    idot?: SortOrderInput | SortOrder
    fechar?: SortOrderInput | SortOrder
    fechaa?: SortOrderInput | SortOrder
    idua?: SortOrderInput | SortOrder
    estado?: SortOrderInput | SortOrder
    obs?: SortOrderInput | SortOrder
    precio?: SortOrderInput | SortOrder
    ordent?: ordentOrderByWithRelationInput
    usuario_arte_iduTousuario?: usuarioOrderByWithRelationInput
    usuario_arte_iduaTousuario?: usuarioOrderByWithRelationInput
  }

  export type arteWhereUniqueInput = Prisma.AtLeast<{
    idar?: number
    AND?: arteWhereInput | arteWhereInput[]
    OR?: arteWhereInput[]
    NOT?: arteWhereInput | arteWhereInput[]
    idu?: IntNullableFilter<"arte"> | number | null
    idot?: IntNullableFilter<"arte"> | number | null
    fechar?: DateTimeNullableFilter<"arte"> | Date | string | null
    fechaa?: DateTimeNullableFilter<"arte"> | Date | string | null
    idua?: IntNullableFilter<"arte"> | number | null
    estado?: StringNullableFilter<"arte"> | string | null
    obs?: StringNullableFilter<"arte"> | string | null
    precio?: FloatNullableFilter<"arte"> | number | null
    ordent?: XOR<OrdentNullableRelationFilter, ordentWhereInput> | null
    usuario_arte_iduTousuario?: XOR<UsuarioNullableRelationFilter, usuarioWhereInput> | null
    usuario_arte_iduaTousuario?: XOR<UsuarioNullableRelationFilter, usuarioWhereInput> | null
  }, "idar">

  export type arteOrderByWithAggregationInput = {
    idar?: SortOrder
    idu?: SortOrderInput | SortOrder
    idot?: SortOrderInput | SortOrder
    fechar?: SortOrderInput | SortOrder
    fechaa?: SortOrderInput | SortOrder
    idua?: SortOrderInput | SortOrder
    estado?: SortOrderInput | SortOrder
    obs?: SortOrderInput | SortOrder
    precio?: SortOrderInput | SortOrder
    _count?: arteCountOrderByAggregateInput
    _avg?: arteAvgOrderByAggregateInput
    _max?: arteMaxOrderByAggregateInput
    _min?: arteMinOrderByAggregateInput
    _sum?: arteSumOrderByAggregateInput
  }

  export type arteScalarWhereWithAggregatesInput = {
    AND?: arteScalarWhereWithAggregatesInput | arteScalarWhereWithAggregatesInput[]
    OR?: arteScalarWhereWithAggregatesInput[]
    NOT?: arteScalarWhereWithAggregatesInput | arteScalarWhereWithAggregatesInput[]
    idar?: IntWithAggregatesFilter<"arte"> | number
    idu?: IntNullableWithAggregatesFilter<"arte"> | number | null
    idot?: IntNullableWithAggregatesFilter<"arte"> | number | null
    fechar?: DateTimeNullableWithAggregatesFilter<"arte"> | Date | string | null
    fechaa?: DateTimeNullableWithAggregatesFilter<"arte"> | Date | string | null
    idua?: IntNullableWithAggregatesFilter<"arte"> | number | null
    estado?: StringNullableWithAggregatesFilter<"arte"> | string | null
    obs?: StringNullableWithAggregatesFilter<"arte"> | string | null
    precio?: FloatNullableWithAggregatesFilter<"arte"> | number | null
  }

  export type clienteWhereInput = {
    AND?: clienteWhereInput | clienteWhereInput[]
    OR?: clienteWhereInput[]
    NOT?: clienteWhereInput | clienteWhereInput[]
    idcli?: IntFilter<"cliente"> | number
    idpe?: IntFilter<"cliente"> | number
    estado?: BoolNullableFilter<"cliente"> | boolean | null
    persona?: XOR<PersonaRelationFilter, personaWhereInput>
    cotizacion?: CotizacionListRelationFilter
    ordent?: OrdentListRelationFilter
  }

  export type clienteOrderByWithRelationInput = {
    idcli?: SortOrder
    idpe?: SortOrder
    estado?: SortOrderInput | SortOrder
    persona?: personaOrderByWithRelationInput
    cotizacion?: cotizacionOrderByRelationAggregateInput
    ordent?: ordentOrderByRelationAggregateInput
  }

  export type clienteWhereUniqueInput = Prisma.AtLeast<{
    idcli?: number
    AND?: clienteWhereInput | clienteWhereInput[]
    OR?: clienteWhereInput[]
    NOT?: clienteWhereInput | clienteWhereInput[]
    idpe?: IntFilter<"cliente"> | number
    estado?: BoolNullableFilter<"cliente"> | boolean | null
    persona?: XOR<PersonaRelationFilter, personaWhereInput>
    cotizacion?: CotizacionListRelationFilter
    ordent?: OrdentListRelationFilter
  }, "idcli">

  export type clienteOrderByWithAggregationInput = {
    idcli?: SortOrder
    idpe?: SortOrder
    estado?: SortOrderInput | SortOrder
    _count?: clienteCountOrderByAggregateInput
    _avg?: clienteAvgOrderByAggregateInput
    _max?: clienteMaxOrderByAggregateInput
    _min?: clienteMinOrderByAggregateInput
    _sum?: clienteSumOrderByAggregateInput
  }

  export type clienteScalarWhereWithAggregatesInput = {
    AND?: clienteScalarWhereWithAggregatesInput | clienteScalarWhereWithAggregatesInput[]
    OR?: clienteScalarWhereWithAggregatesInput[]
    NOT?: clienteScalarWhereWithAggregatesInput | clienteScalarWhereWithAggregatesInput[]
    idcli?: IntWithAggregatesFilter<"cliente"> | number
    idpe?: IntWithAggregatesFilter<"cliente"> | number
    estado?: BoolNullableWithAggregatesFilter<"cliente"> | boolean | null
  }

  export type colorWhereInput = {
    AND?: colorWhereInput | colorWhereInput[]
    OR?: colorWhereInput[]
    NOT?: colorWhereInput | colorWhereInput[]
    idcolor?: IntFilter<"color"> | number
    nom?: StringNullableFilter<"color"> | string | null
    punit?: FloatNullableFilter<"color"> | number | null
    idmar?: IntNullableFilter<"color"> | number | null
    estado?: BoolNullableFilter<"color"> | boolean | null
    des?: StringNullableFilter<"color"> | string | null
    marca?: XOR<MarcaNullableRelationFilter, marcaWhereInput> | null
  }

  export type colorOrderByWithRelationInput = {
    idcolor?: SortOrder
    nom?: SortOrderInput | SortOrder
    punit?: SortOrderInput | SortOrder
    idmar?: SortOrderInput | SortOrder
    estado?: SortOrderInput | SortOrder
    des?: SortOrderInput | SortOrder
    marca?: marcaOrderByWithRelationInput
  }

  export type colorWhereUniqueInput = Prisma.AtLeast<{
    idcolor?: number
    AND?: colorWhereInput | colorWhereInput[]
    OR?: colorWhereInput[]
    NOT?: colorWhereInput | colorWhereInput[]
    nom?: StringNullableFilter<"color"> | string | null
    punit?: FloatNullableFilter<"color"> | number | null
    idmar?: IntNullableFilter<"color"> | number | null
    estado?: BoolNullableFilter<"color"> | boolean | null
    des?: StringNullableFilter<"color"> | string | null
    marca?: XOR<MarcaNullableRelationFilter, marcaWhereInput> | null
  }, "idcolor">

  export type colorOrderByWithAggregationInput = {
    idcolor?: SortOrder
    nom?: SortOrderInput | SortOrder
    punit?: SortOrderInput | SortOrder
    idmar?: SortOrderInput | SortOrder
    estado?: SortOrderInput | SortOrder
    des?: SortOrderInput | SortOrder
    _count?: colorCountOrderByAggregateInput
    _avg?: colorAvgOrderByAggregateInput
    _max?: colorMaxOrderByAggregateInput
    _min?: colorMinOrderByAggregateInput
    _sum?: colorSumOrderByAggregateInput
  }

  export type colorScalarWhereWithAggregatesInput = {
    AND?: colorScalarWhereWithAggregatesInput | colorScalarWhereWithAggregatesInput[]
    OR?: colorScalarWhereWithAggregatesInput[]
    NOT?: colorScalarWhereWithAggregatesInput | colorScalarWhereWithAggregatesInput[]
    idcolor?: IntWithAggregatesFilter<"color"> | number
    nom?: StringNullableWithAggregatesFilter<"color"> | string | null
    punit?: FloatNullableWithAggregatesFilter<"color"> | number | null
    idmar?: IntNullableWithAggregatesFilter<"color"> | number | null
    estado?: BoolNullableWithAggregatesFilter<"color"> | boolean | null
    des?: StringNullableWithAggregatesFilter<"color"> | string | null
  }

  export type configuracionlaboralWhereInput = {
    AND?: configuracionlaboralWhereInput | configuracionlaboralWhereInput[]
    OR?: configuracionlaboralWhereInput[]
    NOT?: configuracionlaboralWhereInput | configuracionlaboralWhereInput[]
    idconf?: IntFilter<"configuracionlaboral"> | number
    entrada?: DateTimeNullableFilter<"configuracionlaboral"> | Date | string | null
    salida?: DateTimeNullableFilter<"configuracionlaboral"> | Date | string | null
    tipo?: StringNullableFilter<"configuracionlaboral"> | string | null
    retrasopermitido?: StringNullableFilter<"configuracionlaboral"> | string | null
    adicional?: DateTimeNullableFilter<"configuracionlaboral"> | Date | string | null
    adicional1?: DateTimeNullableFilter<"configuracionlaboral"> | Date | string | null
  }

  export type configuracionlaboralOrderByWithRelationInput = {
    idconf?: SortOrder
    entrada?: SortOrderInput | SortOrder
    salida?: SortOrderInput | SortOrder
    tipo?: SortOrderInput | SortOrder
    retrasopermitido?: SortOrderInput | SortOrder
    adicional?: SortOrderInput | SortOrder
    adicional1?: SortOrderInput | SortOrder
  }

  export type configuracionlaboralWhereUniqueInput = Prisma.AtLeast<{
    idconf?: number
    AND?: configuracionlaboralWhereInput | configuracionlaboralWhereInput[]
    OR?: configuracionlaboralWhereInput[]
    NOT?: configuracionlaboralWhereInput | configuracionlaboralWhereInput[]
    entrada?: DateTimeNullableFilter<"configuracionlaboral"> | Date | string | null
    salida?: DateTimeNullableFilter<"configuracionlaboral"> | Date | string | null
    tipo?: StringNullableFilter<"configuracionlaboral"> | string | null
    retrasopermitido?: StringNullableFilter<"configuracionlaboral"> | string | null
    adicional?: DateTimeNullableFilter<"configuracionlaboral"> | Date | string | null
    adicional1?: DateTimeNullableFilter<"configuracionlaboral"> | Date | string | null
  }, "idconf">

  export type configuracionlaboralOrderByWithAggregationInput = {
    idconf?: SortOrder
    entrada?: SortOrderInput | SortOrder
    salida?: SortOrderInput | SortOrder
    tipo?: SortOrderInput | SortOrder
    retrasopermitido?: SortOrderInput | SortOrder
    adicional?: SortOrderInput | SortOrder
    adicional1?: SortOrderInput | SortOrder
    _count?: configuracionlaboralCountOrderByAggregateInput
    _avg?: configuracionlaboralAvgOrderByAggregateInput
    _max?: configuracionlaboralMaxOrderByAggregateInput
    _min?: configuracionlaboralMinOrderByAggregateInput
    _sum?: configuracionlaboralSumOrderByAggregateInput
  }

  export type configuracionlaboralScalarWhereWithAggregatesInput = {
    AND?: configuracionlaboralScalarWhereWithAggregatesInput | configuracionlaboralScalarWhereWithAggregatesInput[]
    OR?: configuracionlaboralScalarWhereWithAggregatesInput[]
    NOT?: configuracionlaboralScalarWhereWithAggregatesInput | configuracionlaboralScalarWhereWithAggregatesInput[]
    idconf?: IntWithAggregatesFilter<"configuracionlaboral"> | number
    entrada?: DateTimeNullableWithAggregatesFilter<"configuracionlaboral"> | Date | string | null
    salida?: DateTimeNullableWithAggregatesFilter<"configuracionlaboral"> | Date | string | null
    tipo?: StringNullableWithAggregatesFilter<"configuracionlaboral"> | string | null
    retrasopermitido?: StringNullableWithAggregatesFilter<"configuracionlaboral"> | string | null
    adicional?: DateTimeNullableWithAggregatesFilter<"configuracionlaboral"> | Date | string | null
    adicional1?: DateTimeNullableWithAggregatesFilter<"configuracionlaboral"> | Date | string | null
  }

  export type cotizacionWhereInput = {
    AND?: cotizacionWhereInput | cotizacionWhereInput[]
    OR?: cotizacionWhereInput[]
    NOT?: cotizacionWhereInput | cotizacionWhereInput[]
    idcot?: IntFilter<"cotizacion"> | number
    idu?: IntNullableFilter<"cotizacion"> | number | null
    idcli?: IntNullableFilter<"cotizacion"> | number | null
    fecha?: DateTimeNullableFilter<"cotizacion"> | Date | string | null
    precio?: FloatNullableFilter<"cotizacion"> | number | null
    descuento?: FloatNullableFilter<"cotizacion"> | number | null
    preciofinal?: FloatNullableFilter<"cotizacion"> | number | null
    tiempo?: IntNullableFilter<"cotizacion"> | number | null
    arte?: StringNullableFilter<"cotizacion"> | string | null
    obs?: StringNullableFilter<"cotizacion"> | string | null
    estado?: StringNullableFilter<"cotizacion"> | string | null
    cliente?: XOR<ClienteNullableRelationFilter, clienteWhereInput> | null
    usuario?: XOR<UsuarioNullableRelationFilter, usuarioWhereInput> | null
    detcot?: DetcotListRelationFilter
    ordent?: OrdentListRelationFilter
  }

  export type cotizacionOrderByWithRelationInput = {
    idcot?: SortOrder
    idu?: SortOrderInput | SortOrder
    idcli?: SortOrderInput | SortOrder
    fecha?: SortOrderInput | SortOrder
    precio?: SortOrderInput | SortOrder
    descuento?: SortOrderInput | SortOrder
    preciofinal?: SortOrderInput | SortOrder
    tiempo?: SortOrderInput | SortOrder
    arte?: SortOrderInput | SortOrder
    obs?: SortOrderInput | SortOrder
    estado?: SortOrderInput | SortOrder
    cliente?: clienteOrderByWithRelationInput
    usuario?: usuarioOrderByWithRelationInput
    detcot?: detcotOrderByRelationAggregateInput
    ordent?: ordentOrderByRelationAggregateInput
  }

  export type cotizacionWhereUniqueInput = Prisma.AtLeast<{
    idcot?: number
    AND?: cotizacionWhereInput | cotizacionWhereInput[]
    OR?: cotizacionWhereInput[]
    NOT?: cotizacionWhereInput | cotizacionWhereInput[]
    idu?: IntNullableFilter<"cotizacion"> | number | null
    idcli?: IntNullableFilter<"cotizacion"> | number | null
    fecha?: DateTimeNullableFilter<"cotizacion"> | Date | string | null
    precio?: FloatNullableFilter<"cotizacion"> | number | null
    descuento?: FloatNullableFilter<"cotizacion"> | number | null
    preciofinal?: FloatNullableFilter<"cotizacion"> | number | null
    tiempo?: IntNullableFilter<"cotizacion"> | number | null
    arte?: StringNullableFilter<"cotizacion"> | string | null
    obs?: StringNullableFilter<"cotizacion"> | string | null
    estado?: StringNullableFilter<"cotizacion"> | string | null
    cliente?: XOR<ClienteNullableRelationFilter, clienteWhereInput> | null
    usuario?: XOR<UsuarioNullableRelationFilter, usuarioWhereInput> | null
    detcot?: DetcotListRelationFilter
    ordent?: OrdentListRelationFilter
  }, "idcot">

  export type cotizacionOrderByWithAggregationInput = {
    idcot?: SortOrder
    idu?: SortOrderInput | SortOrder
    idcli?: SortOrderInput | SortOrder
    fecha?: SortOrderInput | SortOrder
    precio?: SortOrderInput | SortOrder
    descuento?: SortOrderInput | SortOrder
    preciofinal?: SortOrderInput | SortOrder
    tiempo?: SortOrderInput | SortOrder
    arte?: SortOrderInput | SortOrder
    obs?: SortOrderInput | SortOrder
    estado?: SortOrderInput | SortOrder
    _count?: cotizacionCountOrderByAggregateInput
    _avg?: cotizacionAvgOrderByAggregateInput
    _max?: cotizacionMaxOrderByAggregateInput
    _min?: cotizacionMinOrderByAggregateInput
    _sum?: cotizacionSumOrderByAggregateInput
  }

  export type cotizacionScalarWhereWithAggregatesInput = {
    AND?: cotizacionScalarWhereWithAggregatesInput | cotizacionScalarWhereWithAggregatesInput[]
    OR?: cotizacionScalarWhereWithAggregatesInput[]
    NOT?: cotizacionScalarWhereWithAggregatesInput | cotizacionScalarWhereWithAggregatesInput[]
    idcot?: IntWithAggregatesFilter<"cotizacion"> | number
    idu?: IntNullableWithAggregatesFilter<"cotizacion"> | number | null
    idcli?: IntNullableWithAggregatesFilter<"cotizacion"> | number | null
    fecha?: DateTimeNullableWithAggregatesFilter<"cotizacion"> | Date | string | null
    precio?: FloatNullableWithAggregatesFilter<"cotizacion"> | number | null
    descuento?: FloatNullableWithAggregatesFilter<"cotizacion"> | number | null
    preciofinal?: FloatNullableWithAggregatesFilter<"cotizacion"> | number | null
    tiempo?: IntNullableWithAggregatesFilter<"cotizacion"> | number | null
    arte?: StringNullableWithAggregatesFilter<"cotizacion"> | string | null
    obs?: StringNullableWithAggregatesFilter<"cotizacion"> | string | null
    estado?: StringNullableWithAggregatesFilter<"cotizacion"> | string | null
  }

  export type datosWhereInput = {
    AND?: datosWhereInput | datosWhereInput[]
    OR?: datosWhereInput[]
    NOT?: datosWhereInput | datosWhereInput[]
    idu?: IntFilter<"datos"> | number
    login?: StringFilter<"datos"> | string
    contrasenia?: StringFilter<"datos"> | string
    usuario?: XOR<UsuarioRelationFilter, usuarioWhereInput>
  }

  export type datosOrderByWithRelationInput = {
    idu?: SortOrder
    login?: SortOrder
    contrasenia?: SortOrder
    usuario?: usuarioOrderByWithRelationInput
  }

  export type datosWhereUniqueInput = Prisma.AtLeast<{
    login?: string
    AND?: datosWhereInput | datosWhereInput[]
    OR?: datosWhereInput[]
    NOT?: datosWhereInput | datosWhereInput[]
    idu?: IntFilter<"datos"> | number
    contrasenia?: StringFilter<"datos"> | string
    usuario?: XOR<UsuarioRelationFilter, usuarioWhereInput>
  }, "login">

  export type datosOrderByWithAggregationInput = {
    idu?: SortOrder
    login?: SortOrder
    contrasenia?: SortOrder
    _count?: datosCountOrderByAggregateInput
    _avg?: datosAvgOrderByAggregateInput
    _max?: datosMaxOrderByAggregateInput
    _min?: datosMinOrderByAggregateInput
    _sum?: datosSumOrderByAggregateInput
  }

  export type datosScalarWhereWithAggregatesInput = {
    AND?: datosScalarWhereWithAggregatesInput | datosScalarWhereWithAggregatesInput[]
    OR?: datosScalarWhereWithAggregatesInput[]
    NOT?: datosScalarWhereWithAggregatesInput | datosScalarWhereWithAggregatesInput[]
    idu?: IntWithAggregatesFilter<"datos"> | number
    login?: StringWithAggregatesFilter<"datos"> | string
    contrasenia?: StringWithAggregatesFilter<"datos"> | string
  }

  export type detcotWhereInput = {
    AND?: detcotWhereInput | detcotWhereInput[]
    OR?: detcotWhereInput[]
    NOT?: detcotWhereInput | detcotWhereInput[]
    iddetcot?: IntFilter<"detcot"> | number
    idcot?: IntNullableFilter<"detcot"> | number | null
    idpro?: IntNullableFilter<"detcot"> | number | null
    cant?: IntNullableFilter<"detcot"> | number | null
    punit?: FloatNullableFilter<"detcot"> | number | null
    stotal?: FloatNullableFilter<"detcot"> | number | null
    material?: StringNullableFilter<"detcot"> | string | null
    gr?: StringNullableFilter<"detcot"> | string | null
    tintas?: StringNullableFilter<"detcot"> | string | null
    estado?: BoolNullableFilter<"detcot"> | boolean | null
    cotizacion?: XOR<CotizacionNullableRelationFilter, cotizacionWhereInput> | null
    producto?: XOR<ProductoNullableRelationFilter, productoWhereInput> | null
  }

  export type detcotOrderByWithRelationInput = {
    iddetcot?: SortOrder
    idcot?: SortOrderInput | SortOrder
    idpro?: SortOrderInput | SortOrder
    cant?: SortOrderInput | SortOrder
    punit?: SortOrderInput | SortOrder
    stotal?: SortOrderInput | SortOrder
    material?: SortOrderInput | SortOrder
    gr?: SortOrderInput | SortOrder
    tintas?: SortOrderInput | SortOrder
    estado?: SortOrderInput | SortOrder
    cotizacion?: cotizacionOrderByWithRelationInput
    producto?: productoOrderByWithRelationInput
  }

  export type detcotWhereUniqueInput = Prisma.AtLeast<{
    iddetcot?: number
    AND?: detcotWhereInput | detcotWhereInput[]
    OR?: detcotWhereInput[]
    NOT?: detcotWhereInput | detcotWhereInput[]
    idcot?: IntNullableFilter<"detcot"> | number | null
    idpro?: IntNullableFilter<"detcot"> | number | null
    cant?: IntNullableFilter<"detcot"> | number | null
    punit?: FloatNullableFilter<"detcot"> | number | null
    stotal?: FloatNullableFilter<"detcot"> | number | null
    material?: StringNullableFilter<"detcot"> | string | null
    gr?: StringNullableFilter<"detcot"> | string | null
    tintas?: StringNullableFilter<"detcot"> | string | null
    estado?: BoolNullableFilter<"detcot"> | boolean | null
    cotizacion?: XOR<CotizacionNullableRelationFilter, cotizacionWhereInput> | null
    producto?: XOR<ProductoNullableRelationFilter, productoWhereInput> | null
  }, "iddetcot">

  export type detcotOrderByWithAggregationInput = {
    iddetcot?: SortOrder
    idcot?: SortOrderInput | SortOrder
    idpro?: SortOrderInput | SortOrder
    cant?: SortOrderInput | SortOrder
    punit?: SortOrderInput | SortOrder
    stotal?: SortOrderInput | SortOrder
    material?: SortOrderInput | SortOrder
    gr?: SortOrderInput | SortOrder
    tintas?: SortOrderInput | SortOrder
    estado?: SortOrderInput | SortOrder
    _count?: detcotCountOrderByAggregateInput
    _avg?: detcotAvgOrderByAggregateInput
    _max?: detcotMaxOrderByAggregateInput
    _min?: detcotMinOrderByAggregateInput
    _sum?: detcotSumOrderByAggregateInput
  }

  export type detcotScalarWhereWithAggregatesInput = {
    AND?: detcotScalarWhereWithAggregatesInput | detcotScalarWhereWithAggregatesInput[]
    OR?: detcotScalarWhereWithAggregatesInput[]
    NOT?: detcotScalarWhereWithAggregatesInput | detcotScalarWhereWithAggregatesInput[]
    iddetcot?: IntWithAggregatesFilter<"detcot"> | number
    idcot?: IntNullableWithAggregatesFilter<"detcot"> | number | null
    idpro?: IntNullableWithAggregatesFilter<"detcot"> | number | null
    cant?: IntNullableWithAggregatesFilter<"detcot"> | number | null
    punit?: FloatNullableWithAggregatesFilter<"detcot"> | number | null
    stotal?: FloatNullableWithAggregatesFilter<"detcot"> | number | null
    material?: StringNullableWithAggregatesFilter<"detcot"> | string | null
    gr?: StringNullableWithAggregatesFilter<"detcot"> | string | null
    tintas?: StringNullableWithAggregatesFilter<"detcot"> | string | null
    estado?: BoolNullableWithAggregatesFilter<"detcot"> | boolean | null
  }

  export type detotWhereInput = {
    AND?: detotWhereInput | detotWhereInput[]
    OR?: detotWhereInput[]
    NOT?: detotWhereInput | detotWhereInput[]
    iddetot?: IntFilter<"detot"> | number
    idot?: IntNullableFilter<"detot"> | number | null
    idpro?: IntNullableFilter<"detot"> | number | null
    cant?: IntNullableFilter<"detot"> | number | null
    punit?: FloatNullableFilter<"detot"> | number | null
    stotal?: FloatNullableFilter<"detot"> | number | null
    material?: StringNullableFilter<"detot"> | string | null
    gr?: StringNullableFilter<"detot"> | string | null
    tintas?: StringNullableFilter<"detot"> | string | null
    estado?: BoolNullableFilter<"detot"> | boolean | null
    ordent?: XOR<OrdentNullableRelationFilter, ordentWhereInput> | null
    producto?: XOR<ProductoNullableRelationFilter, productoWhereInput> | null
  }

  export type detotOrderByWithRelationInput = {
    iddetot?: SortOrder
    idot?: SortOrderInput | SortOrder
    idpro?: SortOrderInput | SortOrder
    cant?: SortOrderInput | SortOrder
    punit?: SortOrderInput | SortOrder
    stotal?: SortOrderInput | SortOrder
    material?: SortOrderInput | SortOrder
    gr?: SortOrderInput | SortOrder
    tintas?: SortOrderInput | SortOrder
    estado?: SortOrderInput | SortOrder
    ordent?: ordentOrderByWithRelationInput
    producto?: productoOrderByWithRelationInput
  }

  export type detotWhereUniqueInput = Prisma.AtLeast<{
    iddetot?: number
    AND?: detotWhereInput | detotWhereInput[]
    OR?: detotWhereInput[]
    NOT?: detotWhereInput | detotWhereInput[]
    idot?: IntNullableFilter<"detot"> | number | null
    idpro?: IntNullableFilter<"detot"> | number | null
    cant?: IntNullableFilter<"detot"> | number | null
    punit?: FloatNullableFilter<"detot"> | number | null
    stotal?: FloatNullableFilter<"detot"> | number | null
    material?: StringNullableFilter<"detot"> | string | null
    gr?: StringNullableFilter<"detot"> | string | null
    tintas?: StringNullableFilter<"detot"> | string | null
    estado?: BoolNullableFilter<"detot"> | boolean | null
    ordent?: XOR<OrdentNullableRelationFilter, ordentWhereInput> | null
    producto?: XOR<ProductoNullableRelationFilter, productoWhereInput> | null
  }, "iddetot">

  export type detotOrderByWithAggregationInput = {
    iddetot?: SortOrder
    idot?: SortOrderInput | SortOrder
    idpro?: SortOrderInput | SortOrder
    cant?: SortOrderInput | SortOrder
    punit?: SortOrderInput | SortOrder
    stotal?: SortOrderInput | SortOrder
    material?: SortOrderInput | SortOrder
    gr?: SortOrderInput | SortOrder
    tintas?: SortOrderInput | SortOrder
    estado?: SortOrderInput | SortOrder
    _count?: detotCountOrderByAggregateInput
    _avg?: detotAvgOrderByAggregateInput
    _max?: detotMaxOrderByAggregateInput
    _min?: detotMinOrderByAggregateInput
    _sum?: detotSumOrderByAggregateInput
  }

  export type detotScalarWhereWithAggregatesInput = {
    AND?: detotScalarWhereWithAggregatesInput | detotScalarWhereWithAggregatesInput[]
    OR?: detotScalarWhereWithAggregatesInput[]
    NOT?: detotScalarWhereWithAggregatesInput | detotScalarWhereWithAggregatesInput[]
    iddetot?: IntWithAggregatesFilter<"detot"> | number
    idot?: IntNullableWithAggregatesFilter<"detot"> | number | null
    idpro?: IntNullableWithAggregatesFilter<"detot"> | number | null
    cant?: IntNullableWithAggregatesFilter<"detot"> | number | null
    punit?: FloatNullableWithAggregatesFilter<"detot"> | number | null
    stotal?: FloatNullableWithAggregatesFilter<"detot"> | number | null
    material?: StringNullableWithAggregatesFilter<"detot"> | string | null
    gr?: StringNullableWithAggregatesFilter<"detot"> | string | null
    tintas?: StringNullableWithAggregatesFilter<"detot"> | string | null
    estado?: BoolNullableWithAggregatesFilter<"detot"> | boolean | null
  }

  export type empresaWhereInput = {
    AND?: empresaWhereInput | empresaWhereInput[]
    OR?: empresaWhereInput[]
    NOT?: empresaWhereInput | empresaWhereInput[]
    idem?: IntFilter<"empresa"> | number
    nom?: StringNullableFilter<"empresa"> | string | null
    dir?: StringNullableFilter<"empresa"> | string | null
    des?: StringNullableFilter<"empresa"> | string | null
    dep?: StringNullableFilter<"empresa"> | string | null
    logo?: BytesNullableFilter<"empresa"> | Buffer | null
    idpe?: IntNullableFilter<"empresa"> | number | null
    nit?: StringNullableFilter<"empresa"> | string | null
    auto?: StringNullableFilter<"empresa"> | string | null
    base64?: StringNullableFilter<"empresa"> | string | null
    persona?: XOR<PersonaNullableRelationFilter, personaWhereInput> | null
    leyenda?: LeyendaListRelationFilter
    usuario?: UsuarioListRelationFilter
  }

  export type empresaOrderByWithRelationInput = {
    idem?: SortOrder
    nom?: SortOrderInput | SortOrder
    dir?: SortOrderInput | SortOrder
    des?: SortOrderInput | SortOrder
    dep?: SortOrderInput | SortOrder
    logo?: SortOrderInput | SortOrder
    idpe?: SortOrderInput | SortOrder
    nit?: SortOrderInput | SortOrder
    auto?: SortOrderInput | SortOrder
    base64?: SortOrderInput | SortOrder
    persona?: personaOrderByWithRelationInput
    leyenda?: leyendaOrderByRelationAggregateInput
    usuario?: usuarioOrderByRelationAggregateInput
  }

  export type empresaWhereUniqueInput = Prisma.AtLeast<{
    idem?: number
    AND?: empresaWhereInput | empresaWhereInput[]
    OR?: empresaWhereInput[]
    NOT?: empresaWhereInput | empresaWhereInput[]
    nom?: StringNullableFilter<"empresa"> | string | null
    dir?: StringNullableFilter<"empresa"> | string | null
    des?: StringNullableFilter<"empresa"> | string | null
    dep?: StringNullableFilter<"empresa"> | string | null
    logo?: BytesNullableFilter<"empresa"> | Buffer | null
    idpe?: IntNullableFilter<"empresa"> | number | null
    nit?: StringNullableFilter<"empresa"> | string | null
    auto?: StringNullableFilter<"empresa"> | string | null
    base64?: StringNullableFilter<"empresa"> | string | null
    persona?: XOR<PersonaNullableRelationFilter, personaWhereInput> | null
    leyenda?: LeyendaListRelationFilter
    usuario?: UsuarioListRelationFilter
  }, "idem">

  export type empresaOrderByWithAggregationInput = {
    idem?: SortOrder
    nom?: SortOrderInput | SortOrder
    dir?: SortOrderInput | SortOrder
    des?: SortOrderInput | SortOrder
    dep?: SortOrderInput | SortOrder
    logo?: SortOrderInput | SortOrder
    idpe?: SortOrderInput | SortOrder
    nit?: SortOrderInput | SortOrder
    auto?: SortOrderInput | SortOrder
    base64?: SortOrderInput | SortOrder
    _count?: empresaCountOrderByAggregateInput
    _avg?: empresaAvgOrderByAggregateInput
    _max?: empresaMaxOrderByAggregateInput
    _min?: empresaMinOrderByAggregateInput
    _sum?: empresaSumOrderByAggregateInput
  }

  export type empresaScalarWhereWithAggregatesInput = {
    AND?: empresaScalarWhereWithAggregatesInput | empresaScalarWhereWithAggregatesInput[]
    OR?: empresaScalarWhereWithAggregatesInput[]
    NOT?: empresaScalarWhereWithAggregatesInput | empresaScalarWhereWithAggregatesInput[]
    idem?: IntWithAggregatesFilter<"empresa"> | number
    nom?: StringNullableWithAggregatesFilter<"empresa"> | string | null
    dir?: StringNullableWithAggregatesFilter<"empresa"> | string | null
    des?: StringNullableWithAggregatesFilter<"empresa"> | string | null
    dep?: StringNullableWithAggregatesFilter<"empresa"> | string | null
    logo?: BytesNullableWithAggregatesFilter<"empresa"> | Buffer | null
    idpe?: IntNullableWithAggregatesFilter<"empresa"> | number | null
    nit?: StringNullableWithAggregatesFilter<"empresa"> | string | null
    auto?: StringNullableWithAggregatesFilter<"empresa"> | string | null
    base64?: StringNullableWithAggregatesFilter<"empresa"> | string | null
  }

  export type eventosWhereInput = {
    AND?: eventosWhereInput | eventosWhereInput[]
    OR?: eventosWhereInput[]
    NOT?: eventosWhereInput | eventosWhereInput[]
    idev?: IntFilter<"eventos"> | number
    fechainicio?: DateTimeNullableFilter<"eventos"> | Date | string | null
    fechafin?: DateTimeNullableFilter<"eventos"> | Date | string | null
    tipo?: StringNullableFilter<"eventos"> | string | null
    evento?: StringNullableFilter<"eventos"> | string | null
    adicional?: StringNullableFilter<"eventos"> | string | null
    adicional1?: StringNullableFilter<"eventos"> | string | null
    estado?: StringNullableFilter<"eventos"> | string | null
  }

  export type eventosOrderByWithRelationInput = {
    idev?: SortOrder
    fechainicio?: SortOrderInput | SortOrder
    fechafin?: SortOrderInput | SortOrder
    tipo?: SortOrderInput | SortOrder
    evento?: SortOrderInput | SortOrder
    adicional?: SortOrderInput | SortOrder
    adicional1?: SortOrderInput | SortOrder
    estado?: SortOrderInput | SortOrder
  }

  export type eventosWhereUniqueInput = Prisma.AtLeast<{
    idev?: number
    AND?: eventosWhereInput | eventosWhereInput[]
    OR?: eventosWhereInput[]
    NOT?: eventosWhereInput | eventosWhereInput[]
    fechainicio?: DateTimeNullableFilter<"eventos"> | Date | string | null
    fechafin?: DateTimeNullableFilter<"eventos"> | Date | string | null
    tipo?: StringNullableFilter<"eventos"> | string | null
    evento?: StringNullableFilter<"eventos"> | string | null
    adicional?: StringNullableFilter<"eventos"> | string | null
    adicional1?: StringNullableFilter<"eventos"> | string | null
    estado?: StringNullableFilter<"eventos"> | string | null
  }, "idev">

  export type eventosOrderByWithAggregationInput = {
    idev?: SortOrder
    fechainicio?: SortOrderInput | SortOrder
    fechafin?: SortOrderInput | SortOrder
    tipo?: SortOrderInput | SortOrder
    evento?: SortOrderInput | SortOrder
    adicional?: SortOrderInput | SortOrder
    adicional1?: SortOrderInput | SortOrder
    estado?: SortOrderInput | SortOrder
    _count?: eventosCountOrderByAggregateInput
    _avg?: eventosAvgOrderByAggregateInput
    _max?: eventosMaxOrderByAggregateInput
    _min?: eventosMinOrderByAggregateInput
    _sum?: eventosSumOrderByAggregateInput
  }

  export type eventosScalarWhereWithAggregatesInput = {
    AND?: eventosScalarWhereWithAggregatesInput | eventosScalarWhereWithAggregatesInput[]
    OR?: eventosScalarWhereWithAggregatesInput[]
    NOT?: eventosScalarWhereWithAggregatesInput | eventosScalarWhereWithAggregatesInput[]
    idev?: IntWithAggregatesFilter<"eventos"> | number
    fechainicio?: DateTimeNullableWithAggregatesFilter<"eventos"> | Date | string | null
    fechafin?: DateTimeNullableWithAggregatesFilter<"eventos"> | Date | string | null
    tipo?: StringNullableWithAggregatesFilter<"eventos"> | string | null
    evento?: StringNullableWithAggregatesFilter<"eventos"> | string | null
    adicional?: StringNullableWithAggregatesFilter<"eventos"> | string | null
    adicional1?: StringNullableWithAggregatesFilter<"eventos"> | string | null
    estado?: StringNullableWithAggregatesFilter<"eventos"> | string | null
  }

  export type facturaWhereInput = {
    AND?: facturaWhereInput | facturaWhereInput[]
    OR?: facturaWhereInput[]
    NOT?: facturaWhereInput | facturaWhereInput[]
    idfac?: IntFilter<"factura"> | number
    idot?: IntNullableFilter<"factura"> | number | null
    idu?: IntNullableFilter<"factura"> | number | null
    monto?: FloatNullableFilter<"factura"> | number | null
    fecha?: DateTimeNullableFilter<"factura"> | Date | string | null
    aux?: StringNullableFilter<"factura"> | string | null
    aux1?: StringNullableFilter<"factura"> | string | null
    ordent?: XOR<OrdentNullableRelationFilter, ordentWhereInput> | null
    usuario?: XOR<UsuarioNullableRelationFilter, usuarioWhereInput> | null
  }

  export type facturaOrderByWithRelationInput = {
    idfac?: SortOrder
    idot?: SortOrderInput | SortOrder
    idu?: SortOrderInput | SortOrder
    monto?: SortOrderInput | SortOrder
    fecha?: SortOrderInput | SortOrder
    aux?: SortOrderInput | SortOrder
    aux1?: SortOrderInput | SortOrder
    ordent?: ordentOrderByWithRelationInput
    usuario?: usuarioOrderByWithRelationInput
  }

  export type facturaWhereUniqueInput = Prisma.AtLeast<{
    idfac?: number
    AND?: facturaWhereInput | facturaWhereInput[]
    OR?: facturaWhereInput[]
    NOT?: facturaWhereInput | facturaWhereInput[]
    idot?: IntNullableFilter<"factura"> | number | null
    idu?: IntNullableFilter<"factura"> | number | null
    monto?: FloatNullableFilter<"factura"> | number | null
    fecha?: DateTimeNullableFilter<"factura"> | Date | string | null
    aux?: StringNullableFilter<"factura"> | string | null
    aux1?: StringNullableFilter<"factura"> | string | null
    ordent?: XOR<OrdentNullableRelationFilter, ordentWhereInput> | null
    usuario?: XOR<UsuarioNullableRelationFilter, usuarioWhereInput> | null
  }, "idfac">

  export type facturaOrderByWithAggregationInput = {
    idfac?: SortOrder
    idot?: SortOrderInput | SortOrder
    idu?: SortOrderInput | SortOrder
    monto?: SortOrderInput | SortOrder
    fecha?: SortOrderInput | SortOrder
    aux?: SortOrderInput | SortOrder
    aux1?: SortOrderInput | SortOrder
    _count?: facturaCountOrderByAggregateInput
    _avg?: facturaAvgOrderByAggregateInput
    _max?: facturaMaxOrderByAggregateInput
    _min?: facturaMinOrderByAggregateInput
    _sum?: facturaSumOrderByAggregateInput
  }

  export type facturaScalarWhereWithAggregatesInput = {
    AND?: facturaScalarWhereWithAggregatesInput | facturaScalarWhereWithAggregatesInput[]
    OR?: facturaScalarWhereWithAggregatesInput[]
    NOT?: facturaScalarWhereWithAggregatesInput | facturaScalarWhereWithAggregatesInput[]
    idfac?: IntWithAggregatesFilter<"factura"> | number
    idot?: IntNullableWithAggregatesFilter<"factura"> | number | null
    idu?: IntNullableWithAggregatesFilter<"factura"> | number | null
    monto?: FloatNullableWithAggregatesFilter<"factura"> | number | null
    fecha?: DateTimeNullableWithAggregatesFilter<"factura"> | Date | string | null
    aux?: StringNullableWithAggregatesFilter<"factura"> | string | null
    aux1?: StringNullableWithAggregatesFilter<"factura"> | string | null
  }

  export type inventarioWhereInput = {
    AND?: inventarioWhereInput | inventarioWhereInput[]
    OR?: inventarioWhereInput[]
    NOT?: inventarioWhereInput | inventarioWhereInput[]
    idin?: IntFilter<"inventario"> | number
    idprov?: IntNullableFilter<"inventario"> | number | null
    codigo?: StringNullableFilter<"inventario"> | string | null
    nom?: StringNullableFilter<"inventario"> | string | null
    precio?: FloatNullableFilter<"inventario"> | number | null
    gr?: FloatNullableFilter<"inventario"> | number | null
    tam?: StringNullableFilter<"inventario"> | string | null
    des?: StringNullableFilter<"inventario"> | string | null
    cant?: IntNullableFilter<"inventario"> | number | null
    estado?: BoolNullableFilter<"inventario"> | boolean | null
    proveedor?: XOR<ProveedorNullableRelationFilter, proveedorWhereInput> | null
  }

  export type inventarioOrderByWithRelationInput = {
    idin?: SortOrder
    idprov?: SortOrderInput | SortOrder
    codigo?: SortOrderInput | SortOrder
    nom?: SortOrderInput | SortOrder
    precio?: SortOrderInput | SortOrder
    gr?: SortOrderInput | SortOrder
    tam?: SortOrderInput | SortOrder
    des?: SortOrderInput | SortOrder
    cant?: SortOrderInput | SortOrder
    estado?: SortOrderInput | SortOrder
    proveedor?: proveedorOrderByWithRelationInput
  }

  export type inventarioWhereUniqueInput = Prisma.AtLeast<{
    idin?: number
    AND?: inventarioWhereInput | inventarioWhereInput[]
    OR?: inventarioWhereInput[]
    NOT?: inventarioWhereInput | inventarioWhereInput[]
    idprov?: IntNullableFilter<"inventario"> | number | null
    codigo?: StringNullableFilter<"inventario"> | string | null
    nom?: StringNullableFilter<"inventario"> | string | null
    precio?: FloatNullableFilter<"inventario"> | number | null
    gr?: FloatNullableFilter<"inventario"> | number | null
    tam?: StringNullableFilter<"inventario"> | string | null
    des?: StringNullableFilter<"inventario"> | string | null
    cant?: IntNullableFilter<"inventario"> | number | null
    estado?: BoolNullableFilter<"inventario"> | boolean | null
    proveedor?: XOR<ProveedorNullableRelationFilter, proveedorWhereInput> | null
  }, "idin">

  export type inventarioOrderByWithAggregationInput = {
    idin?: SortOrder
    idprov?: SortOrderInput | SortOrder
    codigo?: SortOrderInput | SortOrder
    nom?: SortOrderInput | SortOrder
    precio?: SortOrderInput | SortOrder
    gr?: SortOrderInput | SortOrder
    tam?: SortOrderInput | SortOrder
    des?: SortOrderInput | SortOrder
    cant?: SortOrderInput | SortOrder
    estado?: SortOrderInput | SortOrder
    _count?: inventarioCountOrderByAggregateInput
    _avg?: inventarioAvgOrderByAggregateInput
    _max?: inventarioMaxOrderByAggregateInput
    _min?: inventarioMinOrderByAggregateInput
    _sum?: inventarioSumOrderByAggregateInput
  }

  export type inventarioScalarWhereWithAggregatesInput = {
    AND?: inventarioScalarWhereWithAggregatesInput | inventarioScalarWhereWithAggregatesInput[]
    OR?: inventarioScalarWhereWithAggregatesInput[]
    NOT?: inventarioScalarWhereWithAggregatesInput | inventarioScalarWhereWithAggregatesInput[]
    idin?: IntWithAggregatesFilter<"inventario"> | number
    idprov?: IntNullableWithAggregatesFilter<"inventario"> | number | null
    codigo?: StringNullableWithAggregatesFilter<"inventario"> | string | null
    nom?: StringNullableWithAggregatesFilter<"inventario"> | string | null
    precio?: FloatNullableWithAggregatesFilter<"inventario"> | number | null
    gr?: FloatNullableWithAggregatesFilter<"inventario"> | number | null
    tam?: StringNullableWithAggregatesFilter<"inventario"> | string | null
    des?: StringNullableWithAggregatesFilter<"inventario"> | string | null
    cant?: IntNullableWithAggregatesFilter<"inventario"> | number | null
    estado?: BoolNullableWithAggregatesFilter<"inventario"> | boolean | null
  }

  export type leyendaWhereInput = {
    AND?: leyendaWhereInput | leyendaWhereInput[]
    OR?: leyendaWhereInput[]
    NOT?: leyendaWhereInput | leyendaWhereInput[]
    idle?: IntFilter<"leyenda"> | number
    des?: StringNullableFilter<"leyenda"> | string | null
    orden?: IntNullableFilter<"leyenda"> | number | null
    idem?: IntNullableFilter<"leyenda"> | number | null
    empresa?: XOR<EmpresaNullableRelationFilter, empresaWhereInput> | null
  }

  export type leyendaOrderByWithRelationInput = {
    idle?: SortOrder
    des?: SortOrderInput | SortOrder
    orden?: SortOrderInput | SortOrder
    idem?: SortOrderInput | SortOrder
    empresa?: empresaOrderByWithRelationInput
  }

  export type leyendaWhereUniqueInput = Prisma.AtLeast<{
    idle?: number
    AND?: leyendaWhereInput | leyendaWhereInput[]
    OR?: leyendaWhereInput[]
    NOT?: leyendaWhereInput | leyendaWhereInput[]
    des?: StringNullableFilter<"leyenda"> | string | null
    orden?: IntNullableFilter<"leyenda"> | number | null
    idem?: IntNullableFilter<"leyenda"> | number | null
    empresa?: XOR<EmpresaNullableRelationFilter, empresaWhereInput> | null
  }, "idle">

  export type leyendaOrderByWithAggregationInput = {
    idle?: SortOrder
    des?: SortOrderInput | SortOrder
    orden?: SortOrderInput | SortOrder
    idem?: SortOrderInput | SortOrder
    _count?: leyendaCountOrderByAggregateInput
    _avg?: leyendaAvgOrderByAggregateInput
    _max?: leyendaMaxOrderByAggregateInput
    _min?: leyendaMinOrderByAggregateInput
    _sum?: leyendaSumOrderByAggregateInput
  }

  export type leyendaScalarWhereWithAggregatesInput = {
    AND?: leyendaScalarWhereWithAggregatesInput | leyendaScalarWhereWithAggregatesInput[]
    OR?: leyendaScalarWhereWithAggregatesInput[]
    NOT?: leyendaScalarWhereWithAggregatesInput | leyendaScalarWhereWithAggregatesInput[]
    idle?: IntWithAggregatesFilter<"leyenda"> | number
    des?: StringNullableWithAggregatesFilter<"leyenda"> | string | null
    orden?: IntNullableWithAggregatesFilter<"leyenda"> | number | null
    idem?: IntNullableWithAggregatesFilter<"leyenda"> | number | null
  }

  export type marcaWhereInput = {
    AND?: marcaWhereInput | marcaWhereInput[]
    OR?: marcaWhereInput[]
    NOT?: marcaWhereInput | marcaWhereInput[]
    idmar?: IntFilter<"marca"> | number
    nom?: StringNullableFilter<"marca"> | string | null
    des?: StringNullableFilter<"marca"> | string | null
    estado?: BoolNullableFilter<"marca"> | boolean | null
    color?: ColorListRelationFilter
    producto?: ProductoListRelationFilter
    terminado?: TerminadoListRelationFilter
  }

  export type marcaOrderByWithRelationInput = {
    idmar?: SortOrder
    nom?: SortOrderInput | SortOrder
    des?: SortOrderInput | SortOrder
    estado?: SortOrderInput | SortOrder
    color?: colorOrderByRelationAggregateInput
    producto?: productoOrderByRelationAggregateInput
    terminado?: terminadoOrderByRelationAggregateInput
  }

  export type marcaWhereUniqueInput = Prisma.AtLeast<{
    idmar?: number
    AND?: marcaWhereInput | marcaWhereInput[]
    OR?: marcaWhereInput[]
    NOT?: marcaWhereInput | marcaWhereInput[]
    nom?: StringNullableFilter<"marca"> | string | null
    des?: StringNullableFilter<"marca"> | string | null
    estado?: BoolNullableFilter<"marca"> | boolean | null
    color?: ColorListRelationFilter
    producto?: ProductoListRelationFilter
    terminado?: TerminadoListRelationFilter
  }, "idmar">

  export type marcaOrderByWithAggregationInput = {
    idmar?: SortOrder
    nom?: SortOrderInput | SortOrder
    des?: SortOrderInput | SortOrder
    estado?: SortOrderInput | SortOrder
    _count?: marcaCountOrderByAggregateInput
    _avg?: marcaAvgOrderByAggregateInput
    _max?: marcaMaxOrderByAggregateInput
    _min?: marcaMinOrderByAggregateInput
    _sum?: marcaSumOrderByAggregateInput
  }

  export type marcaScalarWhereWithAggregatesInput = {
    AND?: marcaScalarWhereWithAggregatesInput | marcaScalarWhereWithAggregatesInput[]
    OR?: marcaScalarWhereWithAggregatesInput[]
    NOT?: marcaScalarWhereWithAggregatesInput | marcaScalarWhereWithAggregatesInput[]
    idmar?: IntWithAggregatesFilter<"marca"> | number
    nom?: StringNullableWithAggregatesFilter<"marca"> | string | null
    des?: StringNullableWithAggregatesFilter<"marca"> | string | null
    estado?: BoolNullableWithAggregatesFilter<"marca"> | boolean | null
  }

  export type menuWhereInput = {
    AND?: menuWhereInput | menuWhereInput[]
    OR?: menuWhereInput[]
    NOT?: menuWhereInput | menuWhereInput[]
    idm?: IntFilter<"menu"> | number
    nom?: StringFilter<"menu"> | string
    url?: StringFilter<"menu"> | string
    estado?: BoolNullableFilter<"menu"> | boolean | null
    rolmenu?: RolmenuListRelationFilter
  }

  export type menuOrderByWithRelationInput = {
    idm?: SortOrder
    nom?: SortOrder
    url?: SortOrder
    estado?: SortOrderInput | SortOrder
    rolmenu?: rolmenuOrderByRelationAggregateInput
  }

  export type menuWhereUniqueInput = Prisma.AtLeast<{
    idm?: number
    AND?: menuWhereInput | menuWhereInput[]
    OR?: menuWhereInput[]
    NOT?: menuWhereInput | menuWhereInput[]
    nom?: StringFilter<"menu"> | string
    url?: StringFilter<"menu"> | string
    estado?: BoolNullableFilter<"menu"> | boolean | null
    rolmenu?: RolmenuListRelationFilter
  }, "idm">

  export type menuOrderByWithAggregationInput = {
    idm?: SortOrder
    nom?: SortOrder
    url?: SortOrder
    estado?: SortOrderInput | SortOrder
    _count?: menuCountOrderByAggregateInput
    _avg?: menuAvgOrderByAggregateInput
    _max?: menuMaxOrderByAggregateInput
    _min?: menuMinOrderByAggregateInput
    _sum?: menuSumOrderByAggregateInput
  }

  export type menuScalarWhereWithAggregatesInput = {
    AND?: menuScalarWhereWithAggregatesInput | menuScalarWhereWithAggregatesInput[]
    OR?: menuScalarWhereWithAggregatesInput[]
    NOT?: menuScalarWhereWithAggregatesInput | menuScalarWhereWithAggregatesInput[]
    idm?: IntWithAggregatesFilter<"menu"> | number
    nom?: StringWithAggregatesFilter<"menu"> | string
    url?: StringWithAggregatesFilter<"menu"> | string
    estado?: BoolNullableWithAggregatesFilter<"menu"> | boolean | null
  }

  export type ordentWhereInput = {
    AND?: ordentWhereInput | ordentWhereInput[]
    OR?: ordentWhereInput[]
    NOT?: ordentWhereInput | ordentWhereInput[]
    idot?: IntFilter<"ordent"> | number
    idu?: IntNullableFilter<"ordent"> | number | null
    idcli?: IntNullableFilter<"ordent"> | number | null
    idcot?: IntNullableFilter<"ordent"> | number | null
    fecha?: DateTimeNullableFilter<"ordent"> | Date | string | null
    precio?: FloatNullableFilter<"ordent"> | number | null
    descuento?: FloatNullableFilter<"ordent"> | number | null
    preciofinal?: FloatNullableFilter<"ordent"> | number | null
    tiempo?: IntNullableFilter<"ordent"> | number | null
    arte?: StringNullableFilter<"ordent"> | string | null
    obs?: StringNullableFilter<"ordent"> | string | null
    estado?: StringNullableFilter<"ordent"> | string | null
    factura?: StringNullableFilter<"ordent"> | string | null
    arte1?: ArteListRelationFilter
    detot?: DetotListRelationFilter
    factura1?: FacturaListRelationFilter
    cliente?: XOR<ClienteNullableRelationFilter, clienteWhereInput> | null
    cotizacion?: XOR<CotizacionNullableRelationFilter, cotizacionWhereInput> | null
    usuario?: XOR<UsuarioNullableRelationFilter, usuarioWhereInput> | null
    pago?: PagoListRelationFilter
  }

  export type ordentOrderByWithRelationInput = {
    idot?: SortOrder
    idu?: SortOrderInput | SortOrder
    idcli?: SortOrderInput | SortOrder
    idcot?: SortOrderInput | SortOrder
    fecha?: SortOrderInput | SortOrder
    precio?: SortOrderInput | SortOrder
    descuento?: SortOrderInput | SortOrder
    preciofinal?: SortOrderInput | SortOrder
    tiempo?: SortOrderInput | SortOrder
    arte?: SortOrderInput | SortOrder
    obs?: SortOrderInput | SortOrder
    estado?: SortOrderInput | SortOrder
    factura?: SortOrderInput | SortOrder
    arte1?: arteOrderByRelationAggregateInput
    detot?: detotOrderByRelationAggregateInput
    factura1?: facturaOrderByRelationAggregateInput
    cliente?: clienteOrderByWithRelationInput
    cotizacion?: cotizacionOrderByWithRelationInput
    usuario?: usuarioOrderByWithRelationInput
    pago?: pagoOrderByRelationAggregateInput
  }

  export type ordentWhereUniqueInput = Prisma.AtLeast<{
    idot?: number
    AND?: ordentWhereInput | ordentWhereInput[]
    OR?: ordentWhereInput[]
    NOT?: ordentWhereInput | ordentWhereInput[]
    idu?: IntNullableFilter<"ordent"> | number | null
    idcli?: IntNullableFilter<"ordent"> | number | null
    idcot?: IntNullableFilter<"ordent"> | number | null
    fecha?: DateTimeNullableFilter<"ordent"> | Date | string | null
    precio?: FloatNullableFilter<"ordent"> | number | null
    descuento?: FloatNullableFilter<"ordent"> | number | null
    preciofinal?: FloatNullableFilter<"ordent"> | number | null
    tiempo?: IntNullableFilter<"ordent"> | number | null
    arte?: StringNullableFilter<"ordent"> | string | null
    obs?: StringNullableFilter<"ordent"> | string | null
    estado?: StringNullableFilter<"ordent"> | string | null
    factura?: StringNullableFilter<"ordent"> | string | null
    arte1?: ArteListRelationFilter
    detot?: DetotListRelationFilter
    factura1?: FacturaListRelationFilter
    cliente?: XOR<ClienteNullableRelationFilter, clienteWhereInput> | null
    cotizacion?: XOR<CotizacionNullableRelationFilter, cotizacionWhereInput> | null
    usuario?: XOR<UsuarioNullableRelationFilter, usuarioWhereInput> | null
    pago?: PagoListRelationFilter
  }, "idot">

  export type ordentOrderByWithAggregationInput = {
    idot?: SortOrder
    idu?: SortOrderInput | SortOrder
    idcli?: SortOrderInput | SortOrder
    idcot?: SortOrderInput | SortOrder
    fecha?: SortOrderInput | SortOrder
    precio?: SortOrderInput | SortOrder
    descuento?: SortOrderInput | SortOrder
    preciofinal?: SortOrderInput | SortOrder
    tiempo?: SortOrderInput | SortOrder
    arte?: SortOrderInput | SortOrder
    obs?: SortOrderInput | SortOrder
    estado?: SortOrderInput | SortOrder
    factura?: SortOrderInput | SortOrder
    _count?: ordentCountOrderByAggregateInput
    _avg?: ordentAvgOrderByAggregateInput
    _max?: ordentMaxOrderByAggregateInput
    _min?: ordentMinOrderByAggregateInput
    _sum?: ordentSumOrderByAggregateInput
  }

  export type ordentScalarWhereWithAggregatesInput = {
    AND?: ordentScalarWhereWithAggregatesInput | ordentScalarWhereWithAggregatesInput[]
    OR?: ordentScalarWhereWithAggregatesInput[]
    NOT?: ordentScalarWhereWithAggregatesInput | ordentScalarWhereWithAggregatesInput[]
    idot?: IntWithAggregatesFilter<"ordent"> | number
    idu?: IntNullableWithAggregatesFilter<"ordent"> | number | null
    idcli?: IntNullableWithAggregatesFilter<"ordent"> | number | null
    idcot?: IntNullableWithAggregatesFilter<"ordent"> | number | null
    fecha?: DateTimeNullableWithAggregatesFilter<"ordent"> | Date | string | null
    precio?: FloatNullableWithAggregatesFilter<"ordent"> | number | null
    descuento?: FloatNullableWithAggregatesFilter<"ordent"> | number | null
    preciofinal?: FloatNullableWithAggregatesFilter<"ordent"> | number | null
    tiempo?: IntNullableWithAggregatesFilter<"ordent"> | number | null
    arte?: StringNullableWithAggregatesFilter<"ordent"> | string | null
    obs?: StringNullableWithAggregatesFilter<"ordent"> | string | null
    estado?: StringNullableWithAggregatesFilter<"ordent"> | string | null
    factura?: StringNullableWithAggregatesFilter<"ordent"> | string | null
  }

  export type pagoWhereInput = {
    AND?: pagoWhereInput | pagoWhereInput[]
    OR?: pagoWhereInput[]
    NOT?: pagoWhereInput | pagoWhereInput[]
    idpagp?: IntFilter<"pago"> | number
    idot?: IntNullableFilter<"pago"> | number | null
    fecha?: DateTimeNullableFilter<"pago"> | Date | string | null
    preciof?: FloatNullableFilter<"pago"> | number | null
    pago?: FloatNullableFilter<"pago"> | number | null
    saldo?: FloatNullableFilter<"pago"> | number | null
    des?: StringNullableFilter<"pago"> | string | null
    comprobante?: BytesNullableFilter<"pago"> | Buffer | null
    ordent?: XOR<OrdentNullableRelationFilter, ordentWhereInput> | null
  }

  export type pagoOrderByWithRelationInput = {
    idpagp?: SortOrder
    idot?: SortOrderInput | SortOrder
    fecha?: SortOrderInput | SortOrder
    preciof?: SortOrderInput | SortOrder
    pago?: SortOrderInput | SortOrder
    saldo?: SortOrderInput | SortOrder
    des?: SortOrderInput | SortOrder
    comprobante?: SortOrderInput | SortOrder
    ordent?: ordentOrderByWithRelationInput
  }

  export type pagoWhereUniqueInput = Prisma.AtLeast<{
    idpagp?: number
    AND?: pagoWhereInput | pagoWhereInput[]
    OR?: pagoWhereInput[]
    NOT?: pagoWhereInput | pagoWhereInput[]
    idot?: IntNullableFilter<"pago"> | number | null
    fecha?: DateTimeNullableFilter<"pago"> | Date | string | null
    preciof?: FloatNullableFilter<"pago"> | number | null
    pago?: FloatNullableFilter<"pago"> | number | null
    saldo?: FloatNullableFilter<"pago"> | number | null
    des?: StringNullableFilter<"pago"> | string | null
    comprobante?: BytesNullableFilter<"pago"> | Buffer | null
    ordent?: XOR<OrdentNullableRelationFilter, ordentWhereInput> | null
  }, "idpagp">

  export type pagoOrderByWithAggregationInput = {
    idpagp?: SortOrder
    idot?: SortOrderInput | SortOrder
    fecha?: SortOrderInput | SortOrder
    preciof?: SortOrderInput | SortOrder
    pago?: SortOrderInput | SortOrder
    saldo?: SortOrderInput | SortOrder
    des?: SortOrderInput | SortOrder
    comprobante?: SortOrderInput | SortOrder
    _count?: pagoCountOrderByAggregateInput
    _avg?: pagoAvgOrderByAggregateInput
    _max?: pagoMaxOrderByAggregateInput
    _min?: pagoMinOrderByAggregateInput
    _sum?: pagoSumOrderByAggregateInput
  }

  export type pagoScalarWhereWithAggregatesInput = {
    AND?: pagoScalarWhereWithAggregatesInput | pagoScalarWhereWithAggregatesInput[]
    OR?: pagoScalarWhereWithAggregatesInput[]
    NOT?: pagoScalarWhereWithAggregatesInput | pagoScalarWhereWithAggregatesInput[]
    idpagp?: IntWithAggregatesFilter<"pago"> | number
    idot?: IntNullableWithAggregatesFilter<"pago"> | number | null
    fecha?: DateTimeNullableWithAggregatesFilter<"pago"> | Date | string | null
    preciof?: FloatNullableWithAggregatesFilter<"pago"> | number | null
    pago?: FloatNullableWithAggregatesFilter<"pago"> | number | null
    saldo?: FloatNullableWithAggregatesFilter<"pago"> | number | null
    des?: StringNullableWithAggregatesFilter<"pago"> | string | null
    comprobante?: BytesNullableWithAggregatesFilter<"pago"> | Buffer | null
  }

  export type personaWhereInput = {
    AND?: personaWhereInput | personaWhereInput[]
    OR?: personaWhereInput[]
    NOT?: personaWhereInput | personaWhereInput[]
    idpe?: IntFilter<"persona"> | number
    ci?: StringFilter<"persona"> | string
    nombre?: StringFilter<"persona"> | string
    ap?: StringFilter<"persona"> | string
    am?: StringNullableFilter<"persona"> | string | null
    direccion?: StringNullableFilter<"persona"> | string | null
    email?: StringNullableFilter<"persona"> | string | null
    estado?: BoolNullableFilter<"persona"> | boolean | null
    base64?: StringNullableFilter<"persona"> | string | null
    cliente?: ClienteListRelationFilter
    empresa?: EmpresaListRelationFilter
    proveedor?: ProveedorListRelationFilter
    telefono?: TelefonoListRelationFilter
    usuario?: UsuarioListRelationFilter
  }

  export type personaOrderByWithRelationInput = {
    idpe?: SortOrder
    ci?: SortOrder
    nombre?: SortOrder
    ap?: SortOrder
    am?: SortOrderInput | SortOrder
    direccion?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    estado?: SortOrderInput | SortOrder
    base64?: SortOrderInput | SortOrder
    cliente?: clienteOrderByRelationAggregateInput
    empresa?: empresaOrderByRelationAggregateInput
    proveedor?: proveedorOrderByRelationAggregateInput
    telefono?: telefonoOrderByRelationAggregateInput
    usuario?: usuarioOrderByRelationAggregateInput
  }

  export type personaWhereUniqueInput = Prisma.AtLeast<{
    idpe?: number
    AND?: personaWhereInput | personaWhereInput[]
    OR?: personaWhereInput[]
    NOT?: personaWhereInput | personaWhereInput[]
    ci?: StringFilter<"persona"> | string
    nombre?: StringFilter<"persona"> | string
    ap?: StringFilter<"persona"> | string
    am?: StringNullableFilter<"persona"> | string | null
    direccion?: StringNullableFilter<"persona"> | string | null
    email?: StringNullableFilter<"persona"> | string | null
    estado?: BoolNullableFilter<"persona"> | boolean | null
    base64?: StringNullableFilter<"persona"> | string | null
    cliente?: ClienteListRelationFilter
    empresa?: EmpresaListRelationFilter
    proveedor?: ProveedorListRelationFilter
    telefono?: TelefonoListRelationFilter
    usuario?: UsuarioListRelationFilter
  }, "idpe">

  export type personaOrderByWithAggregationInput = {
    idpe?: SortOrder
    ci?: SortOrder
    nombre?: SortOrder
    ap?: SortOrder
    am?: SortOrderInput | SortOrder
    direccion?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    estado?: SortOrderInput | SortOrder
    base64?: SortOrderInput | SortOrder
    _count?: personaCountOrderByAggregateInput
    _avg?: personaAvgOrderByAggregateInput
    _max?: personaMaxOrderByAggregateInput
    _min?: personaMinOrderByAggregateInput
    _sum?: personaSumOrderByAggregateInput
  }

  export type personaScalarWhereWithAggregatesInput = {
    AND?: personaScalarWhereWithAggregatesInput | personaScalarWhereWithAggregatesInput[]
    OR?: personaScalarWhereWithAggregatesInput[]
    NOT?: personaScalarWhereWithAggregatesInput | personaScalarWhereWithAggregatesInput[]
    idpe?: IntWithAggregatesFilter<"persona"> | number
    ci?: StringWithAggregatesFilter<"persona"> | string
    nombre?: StringWithAggregatesFilter<"persona"> | string
    ap?: StringWithAggregatesFilter<"persona"> | string
    am?: StringNullableWithAggregatesFilter<"persona"> | string | null
    direccion?: StringNullableWithAggregatesFilter<"persona"> | string | null
    email?: StringNullableWithAggregatesFilter<"persona"> | string | null
    estado?: BoolNullableWithAggregatesFilter<"persona"> | boolean | null
    base64?: StringNullableWithAggregatesFilter<"persona"> | string | null
  }

  export type productoWhereInput = {
    AND?: productoWhereInput | productoWhereInput[]
    OR?: productoWhereInput[]
    NOT?: productoWhereInput | productoWhereInput[]
    idpro?: IntFilter<"producto"> | number
    nom?: StringNullableFilter<"producto"> | string | null
    tam?: StringNullableFilter<"producto"> | string | null
    des?: StringNullableFilter<"producto"> | string | null
    preciov?: FloatNullableFilter<"producto"> | number | null
    precioc?: FloatNullableFilter<"producto"> | number | null
    cantidad?: IntNullableFilter<"producto"> | number | null
    foto?: BytesNullableFilter<"producto"> | Buffer | null
    idmar?: IntNullableFilter<"producto"> | number | null
    estado?: BoolNullableFilter<"producto"> | boolean | null
    base64?: StringNullableFilter<"producto"> | string | null
    ranking?: IntNullableFilter<"producto"> | number | null
    detcot?: DetcotListRelationFilter
    detot?: DetotListRelationFilter
    marca?: XOR<MarcaNullableRelationFilter, marcaWhereInput> | null
  }

  export type productoOrderByWithRelationInput = {
    idpro?: SortOrder
    nom?: SortOrderInput | SortOrder
    tam?: SortOrderInput | SortOrder
    des?: SortOrderInput | SortOrder
    preciov?: SortOrderInput | SortOrder
    precioc?: SortOrderInput | SortOrder
    cantidad?: SortOrderInput | SortOrder
    foto?: SortOrderInput | SortOrder
    idmar?: SortOrderInput | SortOrder
    estado?: SortOrderInput | SortOrder
    base64?: SortOrderInput | SortOrder
    ranking?: SortOrderInput | SortOrder
    detcot?: detcotOrderByRelationAggregateInput
    detot?: detotOrderByRelationAggregateInput
    marca?: marcaOrderByWithRelationInput
  }

  export type productoWhereUniqueInput = Prisma.AtLeast<{
    idpro?: number
    AND?: productoWhereInput | productoWhereInput[]
    OR?: productoWhereInput[]
    NOT?: productoWhereInput | productoWhereInput[]
    nom?: StringNullableFilter<"producto"> | string | null
    tam?: StringNullableFilter<"producto"> | string | null
    des?: StringNullableFilter<"producto"> | string | null
    preciov?: FloatNullableFilter<"producto"> | number | null
    precioc?: FloatNullableFilter<"producto"> | number | null
    cantidad?: IntNullableFilter<"producto"> | number | null
    foto?: BytesNullableFilter<"producto"> | Buffer | null
    idmar?: IntNullableFilter<"producto"> | number | null
    estado?: BoolNullableFilter<"producto"> | boolean | null
    base64?: StringNullableFilter<"producto"> | string | null
    ranking?: IntNullableFilter<"producto"> | number | null
    detcot?: DetcotListRelationFilter
    detot?: DetotListRelationFilter
    marca?: XOR<MarcaNullableRelationFilter, marcaWhereInput> | null
  }, "idpro">

  export type productoOrderByWithAggregationInput = {
    idpro?: SortOrder
    nom?: SortOrderInput | SortOrder
    tam?: SortOrderInput | SortOrder
    des?: SortOrderInput | SortOrder
    preciov?: SortOrderInput | SortOrder
    precioc?: SortOrderInput | SortOrder
    cantidad?: SortOrderInput | SortOrder
    foto?: SortOrderInput | SortOrder
    idmar?: SortOrderInput | SortOrder
    estado?: SortOrderInput | SortOrder
    base64?: SortOrderInput | SortOrder
    ranking?: SortOrderInput | SortOrder
    _count?: productoCountOrderByAggregateInput
    _avg?: productoAvgOrderByAggregateInput
    _max?: productoMaxOrderByAggregateInput
    _min?: productoMinOrderByAggregateInput
    _sum?: productoSumOrderByAggregateInput
  }

  export type productoScalarWhereWithAggregatesInput = {
    AND?: productoScalarWhereWithAggregatesInput | productoScalarWhereWithAggregatesInput[]
    OR?: productoScalarWhereWithAggregatesInput[]
    NOT?: productoScalarWhereWithAggregatesInput | productoScalarWhereWithAggregatesInput[]
    idpro?: IntWithAggregatesFilter<"producto"> | number
    nom?: StringNullableWithAggregatesFilter<"producto"> | string | null
    tam?: StringNullableWithAggregatesFilter<"producto"> | string | null
    des?: StringNullableWithAggregatesFilter<"producto"> | string | null
    preciov?: FloatNullableWithAggregatesFilter<"producto"> | number | null
    precioc?: FloatNullableWithAggregatesFilter<"producto"> | number | null
    cantidad?: IntNullableWithAggregatesFilter<"producto"> | number | null
    foto?: BytesNullableWithAggregatesFilter<"producto"> | Buffer | null
    idmar?: IntNullableWithAggregatesFilter<"producto"> | number | null
    estado?: BoolNullableWithAggregatesFilter<"producto"> | boolean | null
    base64?: StringNullableWithAggregatesFilter<"producto"> | string | null
    ranking?: IntNullableWithAggregatesFilter<"producto"> | number | null
  }

  export type proveedorWhereInput = {
    AND?: proveedorWhereInput | proveedorWhereInput[]
    OR?: proveedorWhereInput[]
    NOT?: proveedorWhereInput | proveedorWhereInput[]
    idprov?: IntFilter<"proveedor"> | number
    nom?: StringNullableFilter<"proveedor"> | string | null
    dir?: StringNullableFilter<"proveedor"> | string | null
    dep?: StringNullableFilter<"proveedor"> | string | null
    logo?: BytesNullableFilter<"proveedor"> | Buffer | null
    idpe?: IntNullableFilter<"proveedor"> | number | null
    estado?: BoolNullableFilter<"proveedor"> | boolean | null
    nit?: StringNullableFilter<"proveedor"> | string | null
    inventario?: InventarioListRelationFilter
    persona?: XOR<PersonaNullableRelationFilter, personaWhereInput> | null
  }

  export type proveedorOrderByWithRelationInput = {
    idprov?: SortOrder
    nom?: SortOrderInput | SortOrder
    dir?: SortOrderInput | SortOrder
    dep?: SortOrderInput | SortOrder
    logo?: SortOrderInput | SortOrder
    idpe?: SortOrderInput | SortOrder
    estado?: SortOrderInput | SortOrder
    nit?: SortOrderInput | SortOrder
    inventario?: inventarioOrderByRelationAggregateInput
    persona?: personaOrderByWithRelationInput
  }

  export type proveedorWhereUniqueInput = Prisma.AtLeast<{
    idprov?: number
    AND?: proveedorWhereInput | proveedorWhereInput[]
    OR?: proveedorWhereInput[]
    NOT?: proveedorWhereInput | proveedorWhereInput[]
    nom?: StringNullableFilter<"proveedor"> | string | null
    dir?: StringNullableFilter<"proveedor"> | string | null
    dep?: StringNullableFilter<"proveedor"> | string | null
    logo?: BytesNullableFilter<"proveedor"> | Buffer | null
    idpe?: IntNullableFilter<"proveedor"> | number | null
    estado?: BoolNullableFilter<"proveedor"> | boolean | null
    nit?: StringNullableFilter<"proveedor"> | string | null
    inventario?: InventarioListRelationFilter
    persona?: XOR<PersonaNullableRelationFilter, personaWhereInput> | null
  }, "idprov">

  export type proveedorOrderByWithAggregationInput = {
    idprov?: SortOrder
    nom?: SortOrderInput | SortOrder
    dir?: SortOrderInput | SortOrder
    dep?: SortOrderInput | SortOrder
    logo?: SortOrderInput | SortOrder
    idpe?: SortOrderInput | SortOrder
    estado?: SortOrderInput | SortOrder
    nit?: SortOrderInput | SortOrder
    _count?: proveedorCountOrderByAggregateInput
    _avg?: proveedorAvgOrderByAggregateInput
    _max?: proveedorMaxOrderByAggregateInput
    _min?: proveedorMinOrderByAggregateInput
    _sum?: proveedorSumOrderByAggregateInput
  }

  export type proveedorScalarWhereWithAggregatesInput = {
    AND?: proveedorScalarWhereWithAggregatesInput | proveedorScalarWhereWithAggregatesInput[]
    OR?: proveedorScalarWhereWithAggregatesInput[]
    NOT?: proveedorScalarWhereWithAggregatesInput | proveedorScalarWhereWithAggregatesInput[]
    idprov?: IntWithAggregatesFilter<"proveedor"> | number
    nom?: StringNullableWithAggregatesFilter<"proveedor"> | string | null
    dir?: StringNullableWithAggregatesFilter<"proveedor"> | string | null
    dep?: StringNullableWithAggregatesFilter<"proveedor"> | string | null
    logo?: BytesNullableWithAggregatesFilter<"proveedor"> | Buffer | null
    idpe?: IntNullableWithAggregatesFilter<"proveedor"> | number | null
    estado?: BoolNullableWithAggregatesFilter<"proveedor"> | boolean | null
    nit?: StringNullableWithAggregatesFilter<"proveedor"> | string | null
  }

  export type registrolaboralWhereInput = {
    AND?: registrolaboralWhereInput | registrolaboralWhereInput[]
    OR?: registrolaboralWhereInput[]
    NOT?: registrolaboralWhereInput | registrolaboralWhereInput[]
    idre?: IntFilter<"registrolaboral"> | number
    idu?: IntNullableFilter<"registrolaboral"> | number | null
    tiporegistro?: StringNullableFilter<"registrolaboral"> | string | null
    fecha?: DateTimeNullableFilter<"registrolaboral"> | Date | string | null
    hora?: DateTimeNullableFilter<"registrolaboral"> | Date | string | null
    mes?: StringNullableFilter<"registrolaboral"> | string | null
    estado?: StringNullableFilter<"registrolaboral"> | string | null
    adicional?: StringNullableFilter<"registrolaboral"> | string | null
    adicional2?: StringNullableFilter<"registrolaboral"> | string | null
    atraso?: DateTimeNullableFilter<"registrolaboral"> | Date | string | null
    usuario?: XOR<UsuarioNullableRelationFilter, usuarioWhereInput> | null
  }

  export type registrolaboralOrderByWithRelationInput = {
    idre?: SortOrder
    idu?: SortOrderInput | SortOrder
    tiporegistro?: SortOrderInput | SortOrder
    fecha?: SortOrderInput | SortOrder
    hora?: SortOrderInput | SortOrder
    mes?: SortOrderInput | SortOrder
    estado?: SortOrderInput | SortOrder
    adicional?: SortOrderInput | SortOrder
    adicional2?: SortOrderInput | SortOrder
    atraso?: SortOrderInput | SortOrder
    usuario?: usuarioOrderByWithRelationInput
  }

  export type registrolaboralWhereUniqueInput = Prisma.AtLeast<{
    idre?: number
    AND?: registrolaboralWhereInput | registrolaboralWhereInput[]
    OR?: registrolaboralWhereInput[]
    NOT?: registrolaboralWhereInput | registrolaboralWhereInput[]
    idu?: IntNullableFilter<"registrolaboral"> | number | null
    tiporegistro?: StringNullableFilter<"registrolaboral"> | string | null
    fecha?: DateTimeNullableFilter<"registrolaboral"> | Date | string | null
    hora?: DateTimeNullableFilter<"registrolaboral"> | Date | string | null
    mes?: StringNullableFilter<"registrolaboral"> | string | null
    estado?: StringNullableFilter<"registrolaboral"> | string | null
    adicional?: StringNullableFilter<"registrolaboral"> | string | null
    adicional2?: StringNullableFilter<"registrolaboral"> | string | null
    atraso?: DateTimeNullableFilter<"registrolaboral"> | Date | string | null
    usuario?: XOR<UsuarioNullableRelationFilter, usuarioWhereInput> | null
  }, "idre">

  export type registrolaboralOrderByWithAggregationInput = {
    idre?: SortOrder
    idu?: SortOrderInput | SortOrder
    tiporegistro?: SortOrderInput | SortOrder
    fecha?: SortOrderInput | SortOrder
    hora?: SortOrderInput | SortOrder
    mes?: SortOrderInput | SortOrder
    estado?: SortOrderInput | SortOrder
    adicional?: SortOrderInput | SortOrder
    adicional2?: SortOrderInput | SortOrder
    atraso?: SortOrderInput | SortOrder
    _count?: registrolaboralCountOrderByAggregateInput
    _avg?: registrolaboralAvgOrderByAggregateInput
    _max?: registrolaboralMaxOrderByAggregateInput
    _min?: registrolaboralMinOrderByAggregateInput
    _sum?: registrolaboralSumOrderByAggregateInput
  }

  export type registrolaboralScalarWhereWithAggregatesInput = {
    AND?: registrolaboralScalarWhereWithAggregatesInput | registrolaboralScalarWhereWithAggregatesInput[]
    OR?: registrolaboralScalarWhereWithAggregatesInput[]
    NOT?: registrolaboralScalarWhereWithAggregatesInput | registrolaboralScalarWhereWithAggregatesInput[]
    idre?: IntWithAggregatesFilter<"registrolaboral"> | number
    idu?: IntNullableWithAggregatesFilter<"registrolaboral"> | number | null
    tiporegistro?: StringNullableWithAggregatesFilter<"registrolaboral"> | string | null
    fecha?: DateTimeNullableWithAggregatesFilter<"registrolaboral"> | Date | string | null
    hora?: DateTimeNullableWithAggregatesFilter<"registrolaboral"> | Date | string | null
    mes?: StringNullableWithAggregatesFilter<"registrolaboral"> | string | null
    estado?: StringNullableWithAggregatesFilter<"registrolaboral"> | string | null
    adicional?: StringNullableWithAggregatesFilter<"registrolaboral"> | string | null
    adicional2?: StringNullableWithAggregatesFilter<"registrolaboral"> | string | null
    atraso?: DateTimeNullableWithAggregatesFilter<"registrolaboral"> | Date | string | null
  }

  export type rolesWhereInput = {
    AND?: rolesWhereInput | rolesWhereInput[]
    OR?: rolesWhereInput[]
    NOT?: rolesWhereInput | rolesWhereInput[]
    idr?: IntFilter<"roles"> | number
    nombre?: StringFilter<"roles"> | string
    descrip?: StringFilter<"roles"> | string
    jerarquia?: IntFilter<"roles"> | number
    estado?: BoolFilter<"roles"> | boolean
    rolmenu?: RolmenuListRelationFilter
    usurol?: UsurolListRelationFilter
  }

  export type rolesOrderByWithRelationInput = {
    idr?: SortOrder
    nombre?: SortOrder
    descrip?: SortOrder
    jerarquia?: SortOrder
    estado?: SortOrder
    rolmenu?: rolmenuOrderByRelationAggregateInput
    usurol?: usurolOrderByRelationAggregateInput
  }

  export type rolesWhereUniqueInput = Prisma.AtLeast<{
    idr?: number
    AND?: rolesWhereInput | rolesWhereInput[]
    OR?: rolesWhereInput[]
    NOT?: rolesWhereInput | rolesWhereInput[]
    nombre?: StringFilter<"roles"> | string
    descrip?: StringFilter<"roles"> | string
    jerarquia?: IntFilter<"roles"> | number
    estado?: BoolFilter<"roles"> | boolean
    rolmenu?: RolmenuListRelationFilter
    usurol?: UsurolListRelationFilter
  }, "idr">

  export type rolesOrderByWithAggregationInput = {
    idr?: SortOrder
    nombre?: SortOrder
    descrip?: SortOrder
    jerarquia?: SortOrder
    estado?: SortOrder
    _count?: rolesCountOrderByAggregateInput
    _avg?: rolesAvgOrderByAggregateInput
    _max?: rolesMaxOrderByAggregateInput
    _min?: rolesMinOrderByAggregateInput
    _sum?: rolesSumOrderByAggregateInput
  }

  export type rolesScalarWhereWithAggregatesInput = {
    AND?: rolesScalarWhereWithAggregatesInput | rolesScalarWhereWithAggregatesInput[]
    OR?: rolesScalarWhereWithAggregatesInput[]
    NOT?: rolesScalarWhereWithAggregatesInput | rolesScalarWhereWithAggregatesInput[]
    idr?: IntWithAggregatesFilter<"roles"> | number
    nombre?: StringWithAggregatesFilter<"roles"> | string
    descrip?: StringWithAggregatesFilter<"roles"> | string
    jerarquia?: IntWithAggregatesFilter<"roles"> | number
    estado?: BoolWithAggregatesFilter<"roles"> | boolean
  }

  export type rolmenuWhereInput = {
    AND?: rolmenuWhereInput | rolmenuWhereInput[]
    OR?: rolmenuWhereInput[]
    NOT?: rolmenuWhereInput | rolmenuWhereInput[]
    idr?: IntFilter<"rolmenu"> | number
    idm?: IntFilter<"rolmenu"> | number
    menu?: XOR<MenuRelationFilter, menuWhereInput>
    roles?: XOR<RolesRelationFilter, rolesWhereInput>
  }

  export type rolmenuOrderByWithRelationInput = {
    idr?: SortOrder
    idm?: SortOrder
    menu?: menuOrderByWithRelationInput
    roles?: rolesOrderByWithRelationInput
  }

  export type rolmenuWhereUniqueInput = Prisma.AtLeast<{
    idr_idm?: rolmenuIdrIdmCompoundUniqueInput
    AND?: rolmenuWhereInput | rolmenuWhereInput[]
    OR?: rolmenuWhereInput[]
    NOT?: rolmenuWhereInput | rolmenuWhereInput[]
    idr?: IntFilter<"rolmenu"> | number
    idm?: IntFilter<"rolmenu"> | number
    menu?: XOR<MenuRelationFilter, menuWhereInput>
    roles?: XOR<RolesRelationFilter, rolesWhereInput>
  }, "idr_idm">

  export type rolmenuOrderByWithAggregationInput = {
    idr?: SortOrder
    idm?: SortOrder
    _count?: rolmenuCountOrderByAggregateInput
    _avg?: rolmenuAvgOrderByAggregateInput
    _max?: rolmenuMaxOrderByAggregateInput
    _min?: rolmenuMinOrderByAggregateInput
    _sum?: rolmenuSumOrderByAggregateInput
  }

  export type rolmenuScalarWhereWithAggregatesInput = {
    AND?: rolmenuScalarWhereWithAggregatesInput | rolmenuScalarWhereWithAggregatesInput[]
    OR?: rolmenuScalarWhereWithAggregatesInput[]
    NOT?: rolmenuScalarWhereWithAggregatesInput | rolmenuScalarWhereWithAggregatesInput[]
    idr?: IntWithAggregatesFilter<"rolmenu"> | number
    idm?: IntWithAggregatesFilter<"rolmenu"> | number
  }

  export type telefonoWhereInput = {
    AND?: telefonoWhereInput | telefonoWhereInput[]
    OR?: telefonoWhereInput[]
    NOT?: telefonoWhereInput | telefonoWhereInput[]
    idtel?: IntFilter<"telefono"> | number
    idpe?: IntFilter<"telefono"> | number
    numero?: StringFilter<"telefono"> | string
    estado?: BoolNullableFilter<"telefono"> | boolean | null
    persona?: XOR<PersonaRelationFilter, personaWhereInput>
  }

  export type telefonoOrderByWithRelationInput = {
    idtel?: SortOrder
    idpe?: SortOrder
    numero?: SortOrder
    estado?: SortOrderInput | SortOrder
    persona?: personaOrderByWithRelationInput
  }

  export type telefonoWhereUniqueInput = Prisma.AtLeast<{
    idtel?: number
    AND?: telefonoWhereInput | telefonoWhereInput[]
    OR?: telefonoWhereInput[]
    NOT?: telefonoWhereInput | telefonoWhereInput[]
    idpe?: IntFilter<"telefono"> | number
    numero?: StringFilter<"telefono"> | string
    estado?: BoolNullableFilter<"telefono"> | boolean | null
    persona?: XOR<PersonaRelationFilter, personaWhereInput>
  }, "idtel">

  export type telefonoOrderByWithAggregationInput = {
    idtel?: SortOrder
    idpe?: SortOrder
    numero?: SortOrder
    estado?: SortOrderInput | SortOrder
    _count?: telefonoCountOrderByAggregateInput
    _avg?: telefonoAvgOrderByAggregateInput
    _max?: telefonoMaxOrderByAggregateInput
    _min?: telefonoMinOrderByAggregateInput
    _sum?: telefonoSumOrderByAggregateInput
  }

  export type telefonoScalarWhereWithAggregatesInput = {
    AND?: telefonoScalarWhereWithAggregatesInput | telefonoScalarWhereWithAggregatesInput[]
    OR?: telefonoScalarWhereWithAggregatesInput[]
    NOT?: telefonoScalarWhereWithAggregatesInput | telefonoScalarWhereWithAggregatesInput[]
    idtel?: IntWithAggregatesFilter<"telefono"> | number
    idpe?: IntWithAggregatesFilter<"telefono"> | number
    numero?: StringWithAggregatesFilter<"telefono"> | string
    estado?: BoolNullableWithAggregatesFilter<"telefono"> | boolean | null
  }

  export type terminadoWhereInput = {
    AND?: terminadoWhereInput | terminadoWhereInput[]
    OR?: terminadoWhereInput[]
    NOT?: terminadoWhereInput | terminadoWhereInput[]
    idter?: IntFilter<"terminado"> | number
    nom?: StringNullableFilter<"terminado"> | string | null
    punit?: FloatNullableFilter<"terminado"> | number | null
    idmar?: IntNullableFilter<"terminado"> | number | null
    estado?: BoolNullableFilter<"terminado"> | boolean | null
    marca?: XOR<MarcaNullableRelationFilter, marcaWhereInput> | null
  }

  export type terminadoOrderByWithRelationInput = {
    idter?: SortOrder
    nom?: SortOrderInput | SortOrder
    punit?: SortOrderInput | SortOrder
    idmar?: SortOrderInput | SortOrder
    estado?: SortOrderInput | SortOrder
    marca?: marcaOrderByWithRelationInput
  }

  export type terminadoWhereUniqueInput = Prisma.AtLeast<{
    idter?: number
    AND?: terminadoWhereInput | terminadoWhereInput[]
    OR?: terminadoWhereInput[]
    NOT?: terminadoWhereInput | terminadoWhereInput[]
    nom?: StringNullableFilter<"terminado"> | string | null
    punit?: FloatNullableFilter<"terminado"> | number | null
    idmar?: IntNullableFilter<"terminado"> | number | null
    estado?: BoolNullableFilter<"terminado"> | boolean | null
    marca?: XOR<MarcaNullableRelationFilter, marcaWhereInput> | null
  }, "idter">

  export type terminadoOrderByWithAggregationInput = {
    idter?: SortOrder
    nom?: SortOrderInput | SortOrder
    punit?: SortOrderInput | SortOrder
    idmar?: SortOrderInput | SortOrder
    estado?: SortOrderInput | SortOrder
    _count?: terminadoCountOrderByAggregateInput
    _avg?: terminadoAvgOrderByAggregateInput
    _max?: terminadoMaxOrderByAggregateInput
    _min?: terminadoMinOrderByAggregateInput
    _sum?: terminadoSumOrderByAggregateInput
  }

  export type terminadoScalarWhereWithAggregatesInput = {
    AND?: terminadoScalarWhereWithAggregatesInput | terminadoScalarWhereWithAggregatesInput[]
    OR?: terminadoScalarWhereWithAggregatesInput[]
    NOT?: terminadoScalarWhereWithAggregatesInput | terminadoScalarWhereWithAggregatesInput[]
    idter?: IntWithAggregatesFilter<"terminado"> | number
    nom?: StringNullableWithAggregatesFilter<"terminado"> | string | null
    punit?: FloatNullableWithAggregatesFilter<"terminado"> | number | null
    idmar?: IntNullableWithAggregatesFilter<"terminado"> | number | null
    estado?: BoolNullableWithAggregatesFilter<"terminado"> | boolean | null
  }

  export type usuarioWhereInput = {
    AND?: usuarioWhereInput | usuarioWhereInput[]
    OR?: usuarioWhereInput[]
    NOT?: usuarioWhereInput | usuarioWhereInput[]
    idu?: IntFilter<"usuario"> | number
    sexo?: StringFilter<"usuario"> | string
    foto?: BytesNullableFilter<"usuario"> | Buffer | null
    fecnac?: DateTimeFilter<"usuario"> | Date | string
    idpe?: IntFilter<"usuario"> | number
    estado?: BoolNullableFilter<"usuario"> | boolean | null
    idem?: IntNullableFilter<"usuario"> | number | null
    base64?: StringNullableFilter<"usuario"> | string | null
    arte_arte_iduTousuario?: ArteListRelationFilter
    arte_arte_iduaTousuario?: ArteListRelationFilter
    cotizacion?: CotizacionListRelationFilter
    datos?: DatosListRelationFilter
    factura?: FacturaListRelationFilter
    ordent?: OrdentListRelationFilter
    registrolaboral?: RegistrolaboralListRelationFilter
    empresa?: XOR<EmpresaNullableRelationFilter, empresaWhereInput> | null
    persona?: XOR<PersonaRelationFilter, personaWhereInput>
    usurol?: UsurolListRelationFilter
  }

  export type usuarioOrderByWithRelationInput = {
    idu?: SortOrder
    sexo?: SortOrder
    foto?: SortOrderInput | SortOrder
    fecnac?: SortOrder
    idpe?: SortOrder
    estado?: SortOrderInput | SortOrder
    idem?: SortOrderInput | SortOrder
    base64?: SortOrderInput | SortOrder
    arte_arte_iduTousuario?: arteOrderByRelationAggregateInput
    arte_arte_iduaTousuario?: arteOrderByRelationAggregateInput
    cotizacion?: cotizacionOrderByRelationAggregateInput
    datos?: datosOrderByRelationAggregateInput
    factura?: facturaOrderByRelationAggregateInput
    ordent?: ordentOrderByRelationAggregateInput
    registrolaboral?: registrolaboralOrderByRelationAggregateInput
    empresa?: empresaOrderByWithRelationInput
    persona?: personaOrderByWithRelationInput
    usurol?: usurolOrderByRelationAggregateInput
  }

  export type usuarioWhereUniqueInput = Prisma.AtLeast<{
    idu?: number
    AND?: usuarioWhereInput | usuarioWhereInput[]
    OR?: usuarioWhereInput[]
    NOT?: usuarioWhereInput | usuarioWhereInput[]
    sexo?: StringFilter<"usuario"> | string
    foto?: BytesNullableFilter<"usuario"> | Buffer | null
    fecnac?: DateTimeFilter<"usuario"> | Date | string
    idpe?: IntFilter<"usuario"> | number
    estado?: BoolNullableFilter<"usuario"> | boolean | null
    idem?: IntNullableFilter<"usuario"> | number | null
    base64?: StringNullableFilter<"usuario"> | string | null
    arte_arte_iduTousuario?: ArteListRelationFilter
    arte_arte_iduaTousuario?: ArteListRelationFilter
    cotizacion?: CotizacionListRelationFilter
    datos?: DatosListRelationFilter
    factura?: FacturaListRelationFilter
    ordent?: OrdentListRelationFilter
    registrolaboral?: RegistrolaboralListRelationFilter
    empresa?: XOR<EmpresaNullableRelationFilter, empresaWhereInput> | null
    persona?: XOR<PersonaRelationFilter, personaWhereInput>
    usurol?: UsurolListRelationFilter
  }, "idu">

  export type usuarioOrderByWithAggregationInput = {
    idu?: SortOrder
    sexo?: SortOrder
    foto?: SortOrderInput | SortOrder
    fecnac?: SortOrder
    idpe?: SortOrder
    estado?: SortOrderInput | SortOrder
    idem?: SortOrderInput | SortOrder
    base64?: SortOrderInput | SortOrder
    _count?: usuarioCountOrderByAggregateInput
    _avg?: usuarioAvgOrderByAggregateInput
    _max?: usuarioMaxOrderByAggregateInput
    _min?: usuarioMinOrderByAggregateInput
    _sum?: usuarioSumOrderByAggregateInput
  }

  export type usuarioScalarWhereWithAggregatesInput = {
    AND?: usuarioScalarWhereWithAggregatesInput | usuarioScalarWhereWithAggregatesInput[]
    OR?: usuarioScalarWhereWithAggregatesInput[]
    NOT?: usuarioScalarWhereWithAggregatesInput | usuarioScalarWhereWithAggregatesInput[]
    idu?: IntWithAggregatesFilter<"usuario"> | number
    sexo?: StringWithAggregatesFilter<"usuario"> | string
    foto?: BytesNullableWithAggregatesFilter<"usuario"> | Buffer | null
    fecnac?: DateTimeWithAggregatesFilter<"usuario"> | Date | string
    idpe?: IntWithAggregatesFilter<"usuario"> | number
    estado?: BoolNullableWithAggregatesFilter<"usuario"> | boolean | null
    idem?: IntNullableWithAggregatesFilter<"usuario"> | number | null
    base64?: StringNullableWithAggregatesFilter<"usuario"> | string | null
  }

  export type usurolWhereInput = {
    AND?: usurolWhereInput | usurolWhereInput[]
    OR?: usurolWhereInput[]
    NOT?: usurolWhereInput | usurolWhereInput[]
    idr?: IntFilter<"usurol"> | number
    idu?: IntFilter<"usurol"> | number
    roles?: XOR<RolesRelationFilter, rolesWhereInput>
    usuario?: XOR<UsuarioRelationFilter, usuarioWhereInput>
  }

  export type usurolOrderByWithRelationInput = {
    idr?: SortOrder
    idu?: SortOrder
    roles?: rolesOrderByWithRelationInput
    usuario?: usuarioOrderByWithRelationInput
  }

  export type usurolWhereUniqueInput = Prisma.AtLeast<{
    idr_idu?: usurolIdrIduCompoundUniqueInput
    AND?: usurolWhereInput | usurolWhereInput[]
    OR?: usurolWhereInput[]
    NOT?: usurolWhereInput | usurolWhereInput[]
    idr?: IntFilter<"usurol"> | number
    idu?: IntFilter<"usurol"> | number
    roles?: XOR<RolesRelationFilter, rolesWhereInput>
    usuario?: XOR<UsuarioRelationFilter, usuarioWhereInput>
  }, "idr_idu">

  export type usurolOrderByWithAggregationInput = {
    idr?: SortOrder
    idu?: SortOrder
    _count?: usurolCountOrderByAggregateInput
    _avg?: usurolAvgOrderByAggregateInput
    _max?: usurolMaxOrderByAggregateInput
    _min?: usurolMinOrderByAggregateInput
    _sum?: usurolSumOrderByAggregateInput
  }

  export type usurolScalarWhereWithAggregatesInput = {
    AND?: usurolScalarWhereWithAggregatesInput | usurolScalarWhereWithAggregatesInput[]
    OR?: usurolScalarWhereWithAggregatesInput[]
    NOT?: usurolScalarWhereWithAggregatesInput | usurolScalarWhereWithAggregatesInput[]
    idr?: IntWithAggregatesFilter<"usurol"> | number
    idu?: IntWithAggregatesFilter<"usurol"> | number
  }

  export type arteCreateInput = {
    fechar?: Date | string | null
    fechaa?: Date | string | null
    estado?: string | null
    obs?: string | null
    precio?: number | null
    ordent?: ordentCreateNestedOneWithoutArte1Input
    usuario_arte_iduTousuario?: usuarioCreateNestedOneWithoutArte_arte_iduTousuarioInput
    usuario_arte_iduaTousuario?: usuarioCreateNestedOneWithoutArte_arte_iduaTousuarioInput
  }

  export type arteUncheckedCreateInput = {
    idar?: number
    idu?: number | null
    idot?: number | null
    fechar?: Date | string | null
    fechaa?: Date | string | null
    idua?: number | null
    estado?: string | null
    obs?: string | null
    precio?: number | null
  }

  export type arteUpdateInput = {
    fechar?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fechaa?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estado?: NullableStringFieldUpdateOperationsInput | string | null
    obs?: NullableStringFieldUpdateOperationsInput | string | null
    precio?: NullableFloatFieldUpdateOperationsInput | number | null
    ordent?: ordentUpdateOneWithoutArte1NestedInput
    usuario_arte_iduTousuario?: usuarioUpdateOneWithoutArte_arte_iduTousuarioNestedInput
    usuario_arte_iduaTousuario?: usuarioUpdateOneWithoutArte_arte_iduaTousuarioNestedInput
  }

  export type arteUncheckedUpdateInput = {
    idar?: IntFieldUpdateOperationsInput | number
    idu?: NullableIntFieldUpdateOperationsInput | number | null
    idot?: NullableIntFieldUpdateOperationsInput | number | null
    fechar?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fechaa?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    idua?: NullableIntFieldUpdateOperationsInput | number | null
    estado?: NullableStringFieldUpdateOperationsInput | string | null
    obs?: NullableStringFieldUpdateOperationsInput | string | null
    precio?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type arteCreateManyInput = {
    idar?: number
    idu?: number | null
    idot?: number | null
    fechar?: Date | string | null
    fechaa?: Date | string | null
    idua?: number | null
    estado?: string | null
    obs?: string | null
    precio?: number | null
  }

  export type arteUpdateManyMutationInput = {
    fechar?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fechaa?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estado?: NullableStringFieldUpdateOperationsInput | string | null
    obs?: NullableStringFieldUpdateOperationsInput | string | null
    precio?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type arteUncheckedUpdateManyInput = {
    idar?: IntFieldUpdateOperationsInput | number
    idu?: NullableIntFieldUpdateOperationsInput | number | null
    idot?: NullableIntFieldUpdateOperationsInput | number | null
    fechar?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fechaa?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    idua?: NullableIntFieldUpdateOperationsInput | number | null
    estado?: NullableStringFieldUpdateOperationsInput | string | null
    obs?: NullableStringFieldUpdateOperationsInput | string | null
    precio?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type clienteCreateInput = {
    estado?: boolean | null
    persona: personaCreateNestedOneWithoutClienteInput
    cotizacion?: cotizacionCreateNestedManyWithoutClienteInput
    ordent?: ordentCreateNestedManyWithoutClienteInput
  }

  export type clienteUncheckedCreateInput = {
    idcli?: number
    idpe: number
    estado?: boolean | null
    cotizacion?: cotizacionUncheckedCreateNestedManyWithoutClienteInput
    ordent?: ordentUncheckedCreateNestedManyWithoutClienteInput
  }

  export type clienteUpdateInput = {
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    persona?: personaUpdateOneRequiredWithoutClienteNestedInput
    cotizacion?: cotizacionUpdateManyWithoutClienteNestedInput
    ordent?: ordentUpdateManyWithoutClienteNestedInput
  }

  export type clienteUncheckedUpdateInput = {
    idcli?: IntFieldUpdateOperationsInput | number
    idpe?: IntFieldUpdateOperationsInput | number
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    cotizacion?: cotizacionUncheckedUpdateManyWithoutClienteNestedInput
    ordent?: ordentUncheckedUpdateManyWithoutClienteNestedInput
  }

  export type clienteCreateManyInput = {
    idcli?: number
    idpe: number
    estado?: boolean | null
  }

  export type clienteUpdateManyMutationInput = {
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type clienteUncheckedUpdateManyInput = {
    idcli?: IntFieldUpdateOperationsInput | number
    idpe?: IntFieldUpdateOperationsInput | number
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type colorCreateInput = {
    nom?: string | null
    punit?: number | null
    estado?: boolean | null
    des?: string | null
    marca?: marcaCreateNestedOneWithoutColorInput
  }

  export type colorUncheckedCreateInput = {
    idcolor?: number
    nom?: string | null
    punit?: number | null
    idmar?: number | null
    estado?: boolean | null
    des?: string | null
  }

  export type colorUpdateInput = {
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    punit?: NullableFloatFieldUpdateOperationsInput | number | null
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    des?: NullableStringFieldUpdateOperationsInput | string | null
    marca?: marcaUpdateOneWithoutColorNestedInput
  }

  export type colorUncheckedUpdateInput = {
    idcolor?: IntFieldUpdateOperationsInput | number
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    punit?: NullableFloatFieldUpdateOperationsInput | number | null
    idmar?: NullableIntFieldUpdateOperationsInput | number | null
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    des?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type colorCreateManyInput = {
    idcolor?: number
    nom?: string | null
    punit?: number | null
    idmar?: number | null
    estado?: boolean | null
    des?: string | null
  }

  export type colorUpdateManyMutationInput = {
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    punit?: NullableFloatFieldUpdateOperationsInput | number | null
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    des?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type colorUncheckedUpdateManyInput = {
    idcolor?: IntFieldUpdateOperationsInput | number
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    punit?: NullableFloatFieldUpdateOperationsInput | number | null
    idmar?: NullableIntFieldUpdateOperationsInput | number | null
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    des?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type configuracionlaboralCreateInput = {
    entrada?: Date | string | null
    salida?: Date | string | null
    tipo?: string | null
    retrasopermitido?: string | null
    adicional?: Date | string | null
    adicional1?: Date | string | null
  }

  export type configuracionlaboralUncheckedCreateInput = {
    idconf?: number
    entrada?: Date | string | null
    salida?: Date | string | null
    tipo?: string | null
    retrasopermitido?: string | null
    adicional?: Date | string | null
    adicional1?: Date | string | null
  }

  export type configuracionlaboralUpdateInput = {
    entrada?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    salida?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tipo?: NullableStringFieldUpdateOperationsInput | string | null
    retrasopermitido?: NullableStringFieldUpdateOperationsInput | string | null
    adicional?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    adicional1?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type configuracionlaboralUncheckedUpdateInput = {
    idconf?: IntFieldUpdateOperationsInput | number
    entrada?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    salida?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tipo?: NullableStringFieldUpdateOperationsInput | string | null
    retrasopermitido?: NullableStringFieldUpdateOperationsInput | string | null
    adicional?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    adicional1?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type configuracionlaboralCreateManyInput = {
    idconf?: number
    entrada?: Date | string | null
    salida?: Date | string | null
    tipo?: string | null
    retrasopermitido?: string | null
    adicional?: Date | string | null
    adicional1?: Date | string | null
  }

  export type configuracionlaboralUpdateManyMutationInput = {
    entrada?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    salida?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tipo?: NullableStringFieldUpdateOperationsInput | string | null
    retrasopermitido?: NullableStringFieldUpdateOperationsInput | string | null
    adicional?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    adicional1?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type configuracionlaboralUncheckedUpdateManyInput = {
    idconf?: IntFieldUpdateOperationsInput | number
    entrada?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    salida?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tipo?: NullableStringFieldUpdateOperationsInput | string | null
    retrasopermitido?: NullableStringFieldUpdateOperationsInput | string | null
    adicional?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    adicional1?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type cotizacionCreateInput = {
    fecha?: Date | string | null
    precio?: number | null
    descuento?: number | null
    preciofinal?: number | null
    tiempo?: number | null
    arte?: string | null
    obs?: string | null
    estado?: string | null
    cliente?: clienteCreateNestedOneWithoutCotizacionInput
    usuario?: usuarioCreateNestedOneWithoutCotizacionInput
    detcot?: detcotCreateNestedManyWithoutCotizacionInput
    ordent?: ordentCreateNestedManyWithoutCotizacionInput
  }

  export type cotizacionUncheckedCreateInput = {
    idcot?: number
    idu?: number | null
    idcli?: number | null
    fecha?: Date | string | null
    precio?: number | null
    descuento?: number | null
    preciofinal?: number | null
    tiempo?: number | null
    arte?: string | null
    obs?: string | null
    estado?: string | null
    detcot?: detcotUncheckedCreateNestedManyWithoutCotizacionInput
    ordent?: ordentUncheckedCreateNestedManyWithoutCotizacionInput
  }

  export type cotizacionUpdateInput = {
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    precio?: NullableFloatFieldUpdateOperationsInput | number | null
    descuento?: NullableFloatFieldUpdateOperationsInput | number | null
    preciofinal?: NullableFloatFieldUpdateOperationsInput | number | null
    tiempo?: NullableIntFieldUpdateOperationsInput | number | null
    arte?: NullableStringFieldUpdateOperationsInput | string | null
    obs?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableStringFieldUpdateOperationsInput | string | null
    cliente?: clienteUpdateOneWithoutCotizacionNestedInput
    usuario?: usuarioUpdateOneWithoutCotizacionNestedInput
    detcot?: detcotUpdateManyWithoutCotizacionNestedInput
    ordent?: ordentUpdateManyWithoutCotizacionNestedInput
  }

  export type cotizacionUncheckedUpdateInput = {
    idcot?: IntFieldUpdateOperationsInput | number
    idu?: NullableIntFieldUpdateOperationsInput | number | null
    idcli?: NullableIntFieldUpdateOperationsInput | number | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    precio?: NullableFloatFieldUpdateOperationsInput | number | null
    descuento?: NullableFloatFieldUpdateOperationsInput | number | null
    preciofinal?: NullableFloatFieldUpdateOperationsInput | number | null
    tiempo?: NullableIntFieldUpdateOperationsInput | number | null
    arte?: NullableStringFieldUpdateOperationsInput | string | null
    obs?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableStringFieldUpdateOperationsInput | string | null
    detcot?: detcotUncheckedUpdateManyWithoutCotizacionNestedInput
    ordent?: ordentUncheckedUpdateManyWithoutCotizacionNestedInput
  }

  export type cotizacionCreateManyInput = {
    idcot?: number
    idu?: number | null
    idcli?: number | null
    fecha?: Date | string | null
    precio?: number | null
    descuento?: number | null
    preciofinal?: number | null
    tiempo?: number | null
    arte?: string | null
    obs?: string | null
    estado?: string | null
  }

  export type cotizacionUpdateManyMutationInput = {
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    precio?: NullableFloatFieldUpdateOperationsInput | number | null
    descuento?: NullableFloatFieldUpdateOperationsInput | number | null
    preciofinal?: NullableFloatFieldUpdateOperationsInput | number | null
    tiempo?: NullableIntFieldUpdateOperationsInput | number | null
    arte?: NullableStringFieldUpdateOperationsInput | string | null
    obs?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type cotizacionUncheckedUpdateManyInput = {
    idcot?: IntFieldUpdateOperationsInput | number
    idu?: NullableIntFieldUpdateOperationsInput | number | null
    idcli?: NullableIntFieldUpdateOperationsInput | number | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    precio?: NullableFloatFieldUpdateOperationsInput | number | null
    descuento?: NullableFloatFieldUpdateOperationsInput | number | null
    preciofinal?: NullableFloatFieldUpdateOperationsInput | number | null
    tiempo?: NullableIntFieldUpdateOperationsInput | number | null
    arte?: NullableStringFieldUpdateOperationsInput | string | null
    obs?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type datosCreateInput = {
    login: string
    contrasenia: string
    usuario: usuarioCreateNestedOneWithoutDatosInput
  }

  export type datosUncheckedCreateInput = {
    idu: number
    login: string
    contrasenia: string
  }

  export type datosUpdateInput = {
    login?: StringFieldUpdateOperationsInput | string
    contrasenia?: StringFieldUpdateOperationsInput | string
    usuario?: usuarioUpdateOneRequiredWithoutDatosNestedInput
  }

  export type datosUncheckedUpdateInput = {
    idu?: IntFieldUpdateOperationsInput | number
    login?: StringFieldUpdateOperationsInput | string
    contrasenia?: StringFieldUpdateOperationsInput | string
  }

  export type datosCreateManyInput = {
    idu: number
    login: string
    contrasenia: string
  }

  export type datosUpdateManyMutationInput = {
    login?: StringFieldUpdateOperationsInput | string
    contrasenia?: StringFieldUpdateOperationsInput | string
  }

  export type datosUncheckedUpdateManyInput = {
    idu?: IntFieldUpdateOperationsInput | number
    login?: StringFieldUpdateOperationsInput | string
    contrasenia?: StringFieldUpdateOperationsInput | string
  }

  export type detcotCreateInput = {
    cant?: number | null
    punit?: number | null
    stotal?: number | null
    material?: string | null
    gr?: string | null
    tintas?: string | null
    estado?: boolean | null
    cotizacion?: cotizacionCreateNestedOneWithoutDetcotInput
    producto?: productoCreateNestedOneWithoutDetcotInput
  }

  export type detcotUncheckedCreateInput = {
    iddetcot?: number
    idcot?: number | null
    idpro?: number | null
    cant?: number | null
    punit?: number | null
    stotal?: number | null
    material?: string | null
    gr?: string | null
    tintas?: string | null
    estado?: boolean | null
  }

  export type detcotUpdateInput = {
    cant?: NullableIntFieldUpdateOperationsInput | number | null
    punit?: NullableFloatFieldUpdateOperationsInput | number | null
    stotal?: NullableFloatFieldUpdateOperationsInput | number | null
    material?: NullableStringFieldUpdateOperationsInput | string | null
    gr?: NullableStringFieldUpdateOperationsInput | string | null
    tintas?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    cotizacion?: cotizacionUpdateOneWithoutDetcotNestedInput
    producto?: productoUpdateOneWithoutDetcotNestedInput
  }

  export type detcotUncheckedUpdateInput = {
    iddetcot?: IntFieldUpdateOperationsInput | number
    idcot?: NullableIntFieldUpdateOperationsInput | number | null
    idpro?: NullableIntFieldUpdateOperationsInput | number | null
    cant?: NullableIntFieldUpdateOperationsInput | number | null
    punit?: NullableFloatFieldUpdateOperationsInput | number | null
    stotal?: NullableFloatFieldUpdateOperationsInput | number | null
    material?: NullableStringFieldUpdateOperationsInput | string | null
    gr?: NullableStringFieldUpdateOperationsInput | string | null
    tintas?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type detcotCreateManyInput = {
    iddetcot?: number
    idcot?: number | null
    idpro?: number | null
    cant?: number | null
    punit?: number | null
    stotal?: number | null
    material?: string | null
    gr?: string | null
    tintas?: string | null
    estado?: boolean | null
  }

  export type detcotUpdateManyMutationInput = {
    cant?: NullableIntFieldUpdateOperationsInput | number | null
    punit?: NullableFloatFieldUpdateOperationsInput | number | null
    stotal?: NullableFloatFieldUpdateOperationsInput | number | null
    material?: NullableStringFieldUpdateOperationsInput | string | null
    gr?: NullableStringFieldUpdateOperationsInput | string | null
    tintas?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type detcotUncheckedUpdateManyInput = {
    iddetcot?: IntFieldUpdateOperationsInput | number
    idcot?: NullableIntFieldUpdateOperationsInput | number | null
    idpro?: NullableIntFieldUpdateOperationsInput | number | null
    cant?: NullableIntFieldUpdateOperationsInput | number | null
    punit?: NullableFloatFieldUpdateOperationsInput | number | null
    stotal?: NullableFloatFieldUpdateOperationsInput | number | null
    material?: NullableStringFieldUpdateOperationsInput | string | null
    gr?: NullableStringFieldUpdateOperationsInput | string | null
    tintas?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type detotCreateInput = {
    cant?: number | null
    punit?: number | null
    stotal?: number | null
    material?: string | null
    gr?: string | null
    tintas?: string | null
    estado?: boolean | null
    ordent?: ordentCreateNestedOneWithoutDetotInput
    producto?: productoCreateNestedOneWithoutDetotInput
  }

  export type detotUncheckedCreateInput = {
    iddetot?: number
    idot?: number | null
    idpro?: number | null
    cant?: number | null
    punit?: number | null
    stotal?: number | null
    material?: string | null
    gr?: string | null
    tintas?: string | null
    estado?: boolean | null
  }

  export type detotUpdateInput = {
    cant?: NullableIntFieldUpdateOperationsInput | number | null
    punit?: NullableFloatFieldUpdateOperationsInput | number | null
    stotal?: NullableFloatFieldUpdateOperationsInput | number | null
    material?: NullableStringFieldUpdateOperationsInput | string | null
    gr?: NullableStringFieldUpdateOperationsInput | string | null
    tintas?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    ordent?: ordentUpdateOneWithoutDetotNestedInput
    producto?: productoUpdateOneWithoutDetotNestedInput
  }

  export type detotUncheckedUpdateInput = {
    iddetot?: IntFieldUpdateOperationsInput | number
    idot?: NullableIntFieldUpdateOperationsInput | number | null
    idpro?: NullableIntFieldUpdateOperationsInput | number | null
    cant?: NullableIntFieldUpdateOperationsInput | number | null
    punit?: NullableFloatFieldUpdateOperationsInput | number | null
    stotal?: NullableFloatFieldUpdateOperationsInput | number | null
    material?: NullableStringFieldUpdateOperationsInput | string | null
    gr?: NullableStringFieldUpdateOperationsInput | string | null
    tintas?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type detotCreateManyInput = {
    iddetot?: number
    idot?: number | null
    idpro?: number | null
    cant?: number | null
    punit?: number | null
    stotal?: number | null
    material?: string | null
    gr?: string | null
    tintas?: string | null
    estado?: boolean | null
  }

  export type detotUpdateManyMutationInput = {
    cant?: NullableIntFieldUpdateOperationsInput | number | null
    punit?: NullableFloatFieldUpdateOperationsInput | number | null
    stotal?: NullableFloatFieldUpdateOperationsInput | number | null
    material?: NullableStringFieldUpdateOperationsInput | string | null
    gr?: NullableStringFieldUpdateOperationsInput | string | null
    tintas?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type detotUncheckedUpdateManyInput = {
    iddetot?: IntFieldUpdateOperationsInput | number
    idot?: NullableIntFieldUpdateOperationsInput | number | null
    idpro?: NullableIntFieldUpdateOperationsInput | number | null
    cant?: NullableIntFieldUpdateOperationsInput | number | null
    punit?: NullableFloatFieldUpdateOperationsInput | number | null
    stotal?: NullableFloatFieldUpdateOperationsInput | number | null
    material?: NullableStringFieldUpdateOperationsInput | string | null
    gr?: NullableStringFieldUpdateOperationsInput | string | null
    tintas?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type empresaCreateInput = {
    nom?: string | null
    dir?: string | null
    des?: string | null
    dep?: string | null
    logo?: Buffer | null
    nit?: string | null
    auto?: string | null
    base64?: string | null
    persona?: personaCreateNestedOneWithoutEmpresaInput
    leyenda?: leyendaCreateNestedManyWithoutEmpresaInput
    usuario?: usuarioCreateNestedManyWithoutEmpresaInput
  }

  export type empresaUncheckedCreateInput = {
    idem?: number
    nom?: string | null
    dir?: string | null
    des?: string | null
    dep?: string | null
    logo?: Buffer | null
    idpe?: number | null
    nit?: string | null
    auto?: string | null
    base64?: string | null
    leyenda?: leyendaUncheckedCreateNestedManyWithoutEmpresaInput
    usuario?: usuarioUncheckedCreateNestedManyWithoutEmpresaInput
  }

  export type empresaUpdateInput = {
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    dir?: NullableStringFieldUpdateOperationsInput | string | null
    des?: NullableStringFieldUpdateOperationsInput | string | null
    dep?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    nit?: NullableStringFieldUpdateOperationsInput | string | null
    auto?: NullableStringFieldUpdateOperationsInput | string | null
    base64?: NullableStringFieldUpdateOperationsInput | string | null
    persona?: personaUpdateOneWithoutEmpresaNestedInput
    leyenda?: leyendaUpdateManyWithoutEmpresaNestedInput
    usuario?: usuarioUpdateManyWithoutEmpresaNestedInput
  }

  export type empresaUncheckedUpdateInput = {
    idem?: IntFieldUpdateOperationsInput | number
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    dir?: NullableStringFieldUpdateOperationsInput | string | null
    des?: NullableStringFieldUpdateOperationsInput | string | null
    dep?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    idpe?: NullableIntFieldUpdateOperationsInput | number | null
    nit?: NullableStringFieldUpdateOperationsInput | string | null
    auto?: NullableStringFieldUpdateOperationsInput | string | null
    base64?: NullableStringFieldUpdateOperationsInput | string | null
    leyenda?: leyendaUncheckedUpdateManyWithoutEmpresaNestedInput
    usuario?: usuarioUncheckedUpdateManyWithoutEmpresaNestedInput
  }

  export type empresaCreateManyInput = {
    idem?: number
    nom?: string | null
    dir?: string | null
    des?: string | null
    dep?: string | null
    logo?: Buffer | null
    idpe?: number | null
    nit?: string | null
    auto?: string | null
    base64?: string | null
  }

  export type empresaUpdateManyMutationInput = {
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    dir?: NullableStringFieldUpdateOperationsInput | string | null
    des?: NullableStringFieldUpdateOperationsInput | string | null
    dep?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    nit?: NullableStringFieldUpdateOperationsInput | string | null
    auto?: NullableStringFieldUpdateOperationsInput | string | null
    base64?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type empresaUncheckedUpdateManyInput = {
    idem?: IntFieldUpdateOperationsInput | number
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    dir?: NullableStringFieldUpdateOperationsInput | string | null
    des?: NullableStringFieldUpdateOperationsInput | string | null
    dep?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    idpe?: NullableIntFieldUpdateOperationsInput | number | null
    nit?: NullableStringFieldUpdateOperationsInput | string | null
    auto?: NullableStringFieldUpdateOperationsInput | string | null
    base64?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type eventosCreateInput = {
    fechainicio?: Date | string | null
    fechafin?: Date | string | null
    tipo?: string | null
    evento?: string | null
    adicional?: string | null
    adicional1?: string | null
    estado?: string | null
  }

  export type eventosUncheckedCreateInput = {
    idev?: number
    fechainicio?: Date | string | null
    fechafin?: Date | string | null
    tipo?: string | null
    evento?: string | null
    adicional?: string | null
    adicional1?: string | null
    estado?: string | null
  }

  export type eventosUpdateInput = {
    fechainicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fechafin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tipo?: NullableStringFieldUpdateOperationsInput | string | null
    evento?: NullableStringFieldUpdateOperationsInput | string | null
    adicional?: NullableStringFieldUpdateOperationsInput | string | null
    adicional1?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type eventosUncheckedUpdateInput = {
    idev?: IntFieldUpdateOperationsInput | number
    fechainicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fechafin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tipo?: NullableStringFieldUpdateOperationsInput | string | null
    evento?: NullableStringFieldUpdateOperationsInput | string | null
    adicional?: NullableStringFieldUpdateOperationsInput | string | null
    adicional1?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type eventosCreateManyInput = {
    idev?: number
    fechainicio?: Date | string | null
    fechafin?: Date | string | null
    tipo?: string | null
    evento?: string | null
    adicional?: string | null
    adicional1?: string | null
    estado?: string | null
  }

  export type eventosUpdateManyMutationInput = {
    fechainicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fechafin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tipo?: NullableStringFieldUpdateOperationsInput | string | null
    evento?: NullableStringFieldUpdateOperationsInput | string | null
    adicional?: NullableStringFieldUpdateOperationsInput | string | null
    adicional1?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type eventosUncheckedUpdateManyInput = {
    idev?: IntFieldUpdateOperationsInput | number
    fechainicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fechafin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tipo?: NullableStringFieldUpdateOperationsInput | string | null
    evento?: NullableStringFieldUpdateOperationsInput | string | null
    adicional?: NullableStringFieldUpdateOperationsInput | string | null
    adicional1?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type facturaCreateInput = {
    monto?: number | null
    fecha?: Date | string | null
    aux?: string | null
    aux1?: string | null
    ordent?: ordentCreateNestedOneWithoutFactura1Input
    usuario?: usuarioCreateNestedOneWithoutFacturaInput
  }

  export type facturaUncheckedCreateInput = {
    idfac?: number
    idot?: number | null
    idu?: number | null
    monto?: number | null
    fecha?: Date | string | null
    aux?: string | null
    aux1?: string | null
  }

  export type facturaUpdateInput = {
    monto?: NullableFloatFieldUpdateOperationsInput | number | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    aux?: NullableStringFieldUpdateOperationsInput | string | null
    aux1?: NullableStringFieldUpdateOperationsInput | string | null
    ordent?: ordentUpdateOneWithoutFactura1NestedInput
    usuario?: usuarioUpdateOneWithoutFacturaNestedInput
  }

  export type facturaUncheckedUpdateInput = {
    idfac?: IntFieldUpdateOperationsInput | number
    idot?: NullableIntFieldUpdateOperationsInput | number | null
    idu?: NullableIntFieldUpdateOperationsInput | number | null
    monto?: NullableFloatFieldUpdateOperationsInput | number | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    aux?: NullableStringFieldUpdateOperationsInput | string | null
    aux1?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type facturaCreateManyInput = {
    idfac?: number
    idot?: number | null
    idu?: number | null
    monto?: number | null
    fecha?: Date | string | null
    aux?: string | null
    aux1?: string | null
  }

  export type facturaUpdateManyMutationInput = {
    monto?: NullableFloatFieldUpdateOperationsInput | number | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    aux?: NullableStringFieldUpdateOperationsInput | string | null
    aux1?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type facturaUncheckedUpdateManyInput = {
    idfac?: IntFieldUpdateOperationsInput | number
    idot?: NullableIntFieldUpdateOperationsInput | number | null
    idu?: NullableIntFieldUpdateOperationsInput | number | null
    monto?: NullableFloatFieldUpdateOperationsInput | number | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    aux?: NullableStringFieldUpdateOperationsInput | string | null
    aux1?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type inventarioCreateInput = {
    codigo?: string | null
    nom?: string | null
    precio?: number | null
    gr?: number | null
    tam?: string | null
    des?: string | null
    cant?: number | null
    estado?: boolean | null
    proveedor?: proveedorCreateNestedOneWithoutInventarioInput
  }

  export type inventarioUncheckedCreateInput = {
    idin?: number
    idprov?: number | null
    codigo?: string | null
    nom?: string | null
    precio?: number | null
    gr?: number | null
    tam?: string | null
    des?: string | null
    cant?: number | null
    estado?: boolean | null
  }

  export type inventarioUpdateInput = {
    codigo?: NullableStringFieldUpdateOperationsInput | string | null
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    precio?: NullableFloatFieldUpdateOperationsInput | number | null
    gr?: NullableFloatFieldUpdateOperationsInput | number | null
    tam?: NullableStringFieldUpdateOperationsInput | string | null
    des?: NullableStringFieldUpdateOperationsInput | string | null
    cant?: NullableIntFieldUpdateOperationsInput | number | null
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    proveedor?: proveedorUpdateOneWithoutInventarioNestedInput
  }

  export type inventarioUncheckedUpdateInput = {
    idin?: IntFieldUpdateOperationsInput | number
    idprov?: NullableIntFieldUpdateOperationsInput | number | null
    codigo?: NullableStringFieldUpdateOperationsInput | string | null
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    precio?: NullableFloatFieldUpdateOperationsInput | number | null
    gr?: NullableFloatFieldUpdateOperationsInput | number | null
    tam?: NullableStringFieldUpdateOperationsInput | string | null
    des?: NullableStringFieldUpdateOperationsInput | string | null
    cant?: NullableIntFieldUpdateOperationsInput | number | null
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type inventarioCreateManyInput = {
    idin?: number
    idprov?: number | null
    codigo?: string | null
    nom?: string | null
    precio?: number | null
    gr?: number | null
    tam?: string | null
    des?: string | null
    cant?: number | null
    estado?: boolean | null
  }

  export type inventarioUpdateManyMutationInput = {
    codigo?: NullableStringFieldUpdateOperationsInput | string | null
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    precio?: NullableFloatFieldUpdateOperationsInput | number | null
    gr?: NullableFloatFieldUpdateOperationsInput | number | null
    tam?: NullableStringFieldUpdateOperationsInput | string | null
    des?: NullableStringFieldUpdateOperationsInput | string | null
    cant?: NullableIntFieldUpdateOperationsInput | number | null
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type inventarioUncheckedUpdateManyInput = {
    idin?: IntFieldUpdateOperationsInput | number
    idprov?: NullableIntFieldUpdateOperationsInput | number | null
    codigo?: NullableStringFieldUpdateOperationsInput | string | null
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    precio?: NullableFloatFieldUpdateOperationsInput | number | null
    gr?: NullableFloatFieldUpdateOperationsInput | number | null
    tam?: NullableStringFieldUpdateOperationsInput | string | null
    des?: NullableStringFieldUpdateOperationsInput | string | null
    cant?: NullableIntFieldUpdateOperationsInput | number | null
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type leyendaCreateInput = {
    des?: string | null
    orden?: number | null
    empresa?: empresaCreateNestedOneWithoutLeyendaInput
  }

  export type leyendaUncheckedCreateInput = {
    idle?: number
    des?: string | null
    orden?: number | null
    idem?: number | null
  }

  export type leyendaUpdateInput = {
    des?: NullableStringFieldUpdateOperationsInput | string | null
    orden?: NullableIntFieldUpdateOperationsInput | number | null
    empresa?: empresaUpdateOneWithoutLeyendaNestedInput
  }

  export type leyendaUncheckedUpdateInput = {
    idle?: IntFieldUpdateOperationsInput | number
    des?: NullableStringFieldUpdateOperationsInput | string | null
    orden?: NullableIntFieldUpdateOperationsInput | number | null
    idem?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type leyendaCreateManyInput = {
    idle?: number
    des?: string | null
    orden?: number | null
    idem?: number | null
  }

  export type leyendaUpdateManyMutationInput = {
    des?: NullableStringFieldUpdateOperationsInput | string | null
    orden?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type leyendaUncheckedUpdateManyInput = {
    idle?: IntFieldUpdateOperationsInput | number
    des?: NullableStringFieldUpdateOperationsInput | string | null
    orden?: NullableIntFieldUpdateOperationsInput | number | null
    idem?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type marcaCreateInput = {
    nom?: string | null
    des?: string | null
    estado?: boolean | null
    color?: colorCreateNestedManyWithoutMarcaInput
    producto?: productoCreateNestedManyWithoutMarcaInput
    terminado?: terminadoCreateNestedManyWithoutMarcaInput
  }

  export type marcaUncheckedCreateInput = {
    idmar?: number
    nom?: string | null
    des?: string | null
    estado?: boolean | null
    color?: colorUncheckedCreateNestedManyWithoutMarcaInput
    producto?: productoUncheckedCreateNestedManyWithoutMarcaInput
    terminado?: terminadoUncheckedCreateNestedManyWithoutMarcaInput
  }

  export type marcaUpdateInput = {
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    des?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    color?: colorUpdateManyWithoutMarcaNestedInput
    producto?: productoUpdateManyWithoutMarcaNestedInput
    terminado?: terminadoUpdateManyWithoutMarcaNestedInput
  }

  export type marcaUncheckedUpdateInput = {
    idmar?: IntFieldUpdateOperationsInput | number
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    des?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    color?: colorUncheckedUpdateManyWithoutMarcaNestedInput
    producto?: productoUncheckedUpdateManyWithoutMarcaNestedInput
    terminado?: terminadoUncheckedUpdateManyWithoutMarcaNestedInput
  }

  export type marcaCreateManyInput = {
    idmar?: number
    nom?: string | null
    des?: string | null
    estado?: boolean | null
  }

  export type marcaUpdateManyMutationInput = {
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    des?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type marcaUncheckedUpdateManyInput = {
    idmar?: IntFieldUpdateOperationsInput | number
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    des?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type menuCreateInput = {
    nom: string
    url: string
    estado?: boolean | null
    rolmenu?: rolmenuCreateNestedManyWithoutMenuInput
  }

  export type menuUncheckedCreateInput = {
    idm?: number
    nom: string
    url: string
    estado?: boolean | null
    rolmenu?: rolmenuUncheckedCreateNestedManyWithoutMenuInput
  }

  export type menuUpdateInput = {
    nom?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    rolmenu?: rolmenuUpdateManyWithoutMenuNestedInput
  }

  export type menuUncheckedUpdateInput = {
    idm?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    rolmenu?: rolmenuUncheckedUpdateManyWithoutMenuNestedInput
  }

  export type menuCreateManyInput = {
    idm?: number
    nom: string
    url: string
    estado?: boolean | null
  }

  export type menuUpdateManyMutationInput = {
    nom?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type menuUncheckedUpdateManyInput = {
    idm?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type ordentCreateInput = {
    fecha?: Date | string | null
    precio?: number | null
    descuento?: number | null
    preciofinal?: number | null
    tiempo?: number | null
    arte?: string | null
    obs?: string | null
    estado?: string | null
    factura?: string | null
    arte1?: arteCreateNestedManyWithoutOrdentInput
    detot?: detotCreateNestedManyWithoutOrdentInput
    factura1?: facturaCreateNestedManyWithoutOrdentInput
    cliente?: clienteCreateNestedOneWithoutOrdentInput
    cotizacion?: cotizacionCreateNestedOneWithoutOrdentInput
    usuario?: usuarioCreateNestedOneWithoutOrdentInput
    pago?: pagoCreateNestedManyWithoutOrdentInput
  }

  export type ordentUncheckedCreateInput = {
    idot?: number
    idu?: number | null
    idcli?: number | null
    idcot?: number | null
    fecha?: Date | string | null
    precio?: number | null
    descuento?: number | null
    preciofinal?: number | null
    tiempo?: number | null
    arte?: string | null
    obs?: string | null
    estado?: string | null
    factura?: string | null
    arte1?: arteUncheckedCreateNestedManyWithoutOrdentInput
    detot?: detotUncheckedCreateNestedManyWithoutOrdentInput
    factura1?: facturaUncheckedCreateNestedManyWithoutOrdentInput
    pago?: pagoUncheckedCreateNestedManyWithoutOrdentInput
  }

  export type ordentUpdateInput = {
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    precio?: NullableFloatFieldUpdateOperationsInput | number | null
    descuento?: NullableFloatFieldUpdateOperationsInput | number | null
    preciofinal?: NullableFloatFieldUpdateOperationsInput | number | null
    tiempo?: NullableIntFieldUpdateOperationsInput | number | null
    arte?: NullableStringFieldUpdateOperationsInput | string | null
    obs?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableStringFieldUpdateOperationsInput | string | null
    factura?: NullableStringFieldUpdateOperationsInput | string | null
    arte1?: arteUpdateManyWithoutOrdentNestedInput
    detot?: detotUpdateManyWithoutOrdentNestedInput
    factura1?: facturaUpdateManyWithoutOrdentNestedInput
    cliente?: clienteUpdateOneWithoutOrdentNestedInput
    cotizacion?: cotizacionUpdateOneWithoutOrdentNestedInput
    usuario?: usuarioUpdateOneWithoutOrdentNestedInput
    pago?: pagoUpdateManyWithoutOrdentNestedInput
  }

  export type ordentUncheckedUpdateInput = {
    idot?: IntFieldUpdateOperationsInput | number
    idu?: NullableIntFieldUpdateOperationsInput | number | null
    idcli?: NullableIntFieldUpdateOperationsInput | number | null
    idcot?: NullableIntFieldUpdateOperationsInput | number | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    precio?: NullableFloatFieldUpdateOperationsInput | number | null
    descuento?: NullableFloatFieldUpdateOperationsInput | number | null
    preciofinal?: NullableFloatFieldUpdateOperationsInput | number | null
    tiempo?: NullableIntFieldUpdateOperationsInput | number | null
    arte?: NullableStringFieldUpdateOperationsInput | string | null
    obs?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableStringFieldUpdateOperationsInput | string | null
    factura?: NullableStringFieldUpdateOperationsInput | string | null
    arte1?: arteUncheckedUpdateManyWithoutOrdentNestedInput
    detot?: detotUncheckedUpdateManyWithoutOrdentNestedInput
    factura1?: facturaUncheckedUpdateManyWithoutOrdentNestedInput
    pago?: pagoUncheckedUpdateManyWithoutOrdentNestedInput
  }

  export type ordentCreateManyInput = {
    idot?: number
    idu?: number | null
    idcli?: number | null
    idcot?: number | null
    fecha?: Date | string | null
    precio?: number | null
    descuento?: number | null
    preciofinal?: number | null
    tiempo?: number | null
    arte?: string | null
    obs?: string | null
    estado?: string | null
    factura?: string | null
  }

  export type ordentUpdateManyMutationInput = {
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    precio?: NullableFloatFieldUpdateOperationsInput | number | null
    descuento?: NullableFloatFieldUpdateOperationsInput | number | null
    preciofinal?: NullableFloatFieldUpdateOperationsInput | number | null
    tiempo?: NullableIntFieldUpdateOperationsInput | number | null
    arte?: NullableStringFieldUpdateOperationsInput | string | null
    obs?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableStringFieldUpdateOperationsInput | string | null
    factura?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ordentUncheckedUpdateManyInput = {
    idot?: IntFieldUpdateOperationsInput | number
    idu?: NullableIntFieldUpdateOperationsInput | number | null
    idcli?: NullableIntFieldUpdateOperationsInput | number | null
    idcot?: NullableIntFieldUpdateOperationsInput | number | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    precio?: NullableFloatFieldUpdateOperationsInput | number | null
    descuento?: NullableFloatFieldUpdateOperationsInput | number | null
    preciofinal?: NullableFloatFieldUpdateOperationsInput | number | null
    tiempo?: NullableIntFieldUpdateOperationsInput | number | null
    arte?: NullableStringFieldUpdateOperationsInput | string | null
    obs?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableStringFieldUpdateOperationsInput | string | null
    factura?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type pagoCreateInput = {
    fecha?: Date | string | null
    preciof?: number | null
    pago?: number | null
    saldo?: number | null
    des?: string | null
    comprobante?: Buffer | null
    ordent?: ordentCreateNestedOneWithoutPagoInput
  }

  export type pagoUncheckedCreateInput = {
    idpagp?: number
    idot?: number | null
    fecha?: Date | string | null
    preciof?: number | null
    pago?: number | null
    saldo?: number | null
    des?: string | null
    comprobante?: Buffer | null
  }

  export type pagoUpdateInput = {
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preciof?: NullableFloatFieldUpdateOperationsInput | number | null
    pago?: NullableFloatFieldUpdateOperationsInput | number | null
    saldo?: NullableFloatFieldUpdateOperationsInput | number | null
    des?: NullableStringFieldUpdateOperationsInput | string | null
    comprobante?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    ordent?: ordentUpdateOneWithoutPagoNestedInput
  }

  export type pagoUncheckedUpdateInput = {
    idpagp?: IntFieldUpdateOperationsInput | number
    idot?: NullableIntFieldUpdateOperationsInput | number | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preciof?: NullableFloatFieldUpdateOperationsInput | number | null
    pago?: NullableFloatFieldUpdateOperationsInput | number | null
    saldo?: NullableFloatFieldUpdateOperationsInput | number | null
    des?: NullableStringFieldUpdateOperationsInput | string | null
    comprobante?: NullableBytesFieldUpdateOperationsInput | Buffer | null
  }

  export type pagoCreateManyInput = {
    idpagp?: number
    idot?: number | null
    fecha?: Date | string | null
    preciof?: number | null
    pago?: number | null
    saldo?: number | null
    des?: string | null
    comprobante?: Buffer | null
  }

  export type pagoUpdateManyMutationInput = {
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preciof?: NullableFloatFieldUpdateOperationsInput | number | null
    pago?: NullableFloatFieldUpdateOperationsInput | number | null
    saldo?: NullableFloatFieldUpdateOperationsInput | number | null
    des?: NullableStringFieldUpdateOperationsInput | string | null
    comprobante?: NullableBytesFieldUpdateOperationsInput | Buffer | null
  }

  export type pagoUncheckedUpdateManyInput = {
    idpagp?: IntFieldUpdateOperationsInput | number
    idot?: NullableIntFieldUpdateOperationsInput | number | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preciof?: NullableFloatFieldUpdateOperationsInput | number | null
    pago?: NullableFloatFieldUpdateOperationsInput | number | null
    saldo?: NullableFloatFieldUpdateOperationsInput | number | null
    des?: NullableStringFieldUpdateOperationsInput | string | null
    comprobante?: NullableBytesFieldUpdateOperationsInput | Buffer | null
  }

  export type personaCreateInput = {
    ci: string
    nombre: string
    ap: string
    am?: string | null
    direccion?: string | null
    email?: string | null
    estado?: boolean | null
    base64?: string | null
    cliente?: clienteCreateNestedManyWithoutPersonaInput
    empresa?: empresaCreateNestedManyWithoutPersonaInput
    proveedor?: proveedorCreateNestedManyWithoutPersonaInput
    telefono?: telefonoCreateNestedManyWithoutPersonaInput
    usuario?: usuarioCreateNestedManyWithoutPersonaInput
  }

  export type personaUncheckedCreateInput = {
    idpe?: number
    ci: string
    nombre: string
    ap: string
    am?: string | null
    direccion?: string | null
    email?: string | null
    estado?: boolean | null
    base64?: string | null
    cliente?: clienteUncheckedCreateNestedManyWithoutPersonaInput
    empresa?: empresaUncheckedCreateNestedManyWithoutPersonaInput
    proveedor?: proveedorUncheckedCreateNestedManyWithoutPersonaInput
    telefono?: telefonoUncheckedCreateNestedManyWithoutPersonaInput
    usuario?: usuarioUncheckedCreateNestedManyWithoutPersonaInput
  }

  export type personaUpdateInput = {
    ci?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    ap?: StringFieldUpdateOperationsInput | string
    am?: NullableStringFieldUpdateOperationsInput | string | null
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    base64?: NullableStringFieldUpdateOperationsInput | string | null
    cliente?: clienteUpdateManyWithoutPersonaNestedInput
    empresa?: empresaUpdateManyWithoutPersonaNestedInput
    proveedor?: proveedorUpdateManyWithoutPersonaNestedInput
    telefono?: telefonoUpdateManyWithoutPersonaNestedInput
    usuario?: usuarioUpdateManyWithoutPersonaNestedInput
  }

  export type personaUncheckedUpdateInput = {
    idpe?: IntFieldUpdateOperationsInput | number
    ci?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    ap?: StringFieldUpdateOperationsInput | string
    am?: NullableStringFieldUpdateOperationsInput | string | null
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    base64?: NullableStringFieldUpdateOperationsInput | string | null
    cliente?: clienteUncheckedUpdateManyWithoutPersonaNestedInput
    empresa?: empresaUncheckedUpdateManyWithoutPersonaNestedInput
    proveedor?: proveedorUncheckedUpdateManyWithoutPersonaNestedInput
    telefono?: telefonoUncheckedUpdateManyWithoutPersonaNestedInput
    usuario?: usuarioUncheckedUpdateManyWithoutPersonaNestedInput
  }

  export type personaCreateManyInput = {
    idpe?: number
    ci: string
    nombre: string
    ap: string
    am?: string | null
    direccion?: string | null
    email?: string | null
    estado?: boolean | null
    base64?: string | null
  }

  export type personaUpdateManyMutationInput = {
    ci?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    ap?: StringFieldUpdateOperationsInput | string
    am?: NullableStringFieldUpdateOperationsInput | string | null
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    base64?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type personaUncheckedUpdateManyInput = {
    idpe?: IntFieldUpdateOperationsInput | number
    ci?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    ap?: StringFieldUpdateOperationsInput | string
    am?: NullableStringFieldUpdateOperationsInput | string | null
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    base64?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type productoCreateInput = {
    nom?: string | null
    tam?: string | null
    des?: string | null
    preciov?: number | null
    precioc?: number | null
    cantidad?: number | null
    foto?: Buffer | null
    estado?: boolean | null
    base64?: string | null
    ranking?: number | null
    detcot?: detcotCreateNestedManyWithoutProductoInput
    detot?: detotCreateNestedManyWithoutProductoInput
    marca?: marcaCreateNestedOneWithoutProductoInput
  }

  export type productoUncheckedCreateInput = {
    idpro?: number
    nom?: string | null
    tam?: string | null
    des?: string | null
    preciov?: number | null
    precioc?: number | null
    cantidad?: number | null
    foto?: Buffer | null
    idmar?: number | null
    estado?: boolean | null
    base64?: string | null
    ranking?: number | null
    detcot?: detcotUncheckedCreateNestedManyWithoutProductoInput
    detot?: detotUncheckedCreateNestedManyWithoutProductoInput
  }

  export type productoUpdateInput = {
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    tam?: NullableStringFieldUpdateOperationsInput | string | null
    des?: NullableStringFieldUpdateOperationsInput | string | null
    preciov?: NullableFloatFieldUpdateOperationsInput | number | null
    precioc?: NullableFloatFieldUpdateOperationsInput | number | null
    cantidad?: NullableIntFieldUpdateOperationsInput | number | null
    foto?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    base64?: NullableStringFieldUpdateOperationsInput | string | null
    ranking?: NullableIntFieldUpdateOperationsInput | number | null
    detcot?: detcotUpdateManyWithoutProductoNestedInput
    detot?: detotUpdateManyWithoutProductoNestedInput
    marca?: marcaUpdateOneWithoutProductoNestedInput
  }

  export type productoUncheckedUpdateInput = {
    idpro?: IntFieldUpdateOperationsInput | number
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    tam?: NullableStringFieldUpdateOperationsInput | string | null
    des?: NullableStringFieldUpdateOperationsInput | string | null
    preciov?: NullableFloatFieldUpdateOperationsInput | number | null
    precioc?: NullableFloatFieldUpdateOperationsInput | number | null
    cantidad?: NullableIntFieldUpdateOperationsInput | number | null
    foto?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    idmar?: NullableIntFieldUpdateOperationsInput | number | null
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    base64?: NullableStringFieldUpdateOperationsInput | string | null
    ranking?: NullableIntFieldUpdateOperationsInput | number | null
    detcot?: detcotUncheckedUpdateManyWithoutProductoNestedInput
    detot?: detotUncheckedUpdateManyWithoutProductoNestedInput
  }

  export type productoCreateManyInput = {
    idpro?: number
    nom?: string | null
    tam?: string | null
    des?: string | null
    preciov?: number | null
    precioc?: number | null
    cantidad?: number | null
    foto?: Buffer | null
    idmar?: number | null
    estado?: boolean | null
    base64?: string | null
    ranking?: number | null
  }

  export type productoUpdateManyMutationInput = {
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    tam?: NullableStringFieldUpdateOperationsInput | string | null
    des?: NullableStringFieldUpdateOperationsInput | string | null
    preciov?: NullableFloatFieldUpdateOperationsInput | number | null
    precioc?: NullableFloatFieldUpdateOperationsInput | number | null
    cantidad?: NullableIntFieldUpdateOperationsInput | number | null
    foto?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    base64?: NullableStringFieldUpdateOperationsInput | string | null
    ranking?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type productoUncheckedUpdateManyInput = {
    idpro?: IntFieldUpdateOperationsInput | number
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    tam?: NullableStringFieldUpdateOperationsInput | string | null
    des?: NullableStringFieldUpdateOperationsInput | string | null
    preciov?: NullableFloatFieldUpdateOperationsInput | number | null
    precioc?: NullableFloatFieldUpdateOperationsInput | number | null
    cantidad?: NullableIntFieldUpdateOperationsInput | number | null
    foto?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    idmar?: NullableIntFieldUpdateOperationsInput | number | null
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    base64?: NullableStringFieldUpdateOperationsInput | string | null
    ranking?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type proveedorCreateInput = {
    nom?: string | null
    dir?: string | null
    dep?: string | null
    logo?: Buffer | null
    estado?: boolean | null
    nit?: string | null
    inventario?: inventarioCreateNestedManyWithoutProveedorInput
    persona?: personaCreateNestedOneWithoutProveedorInput
  }

  export type proveedorUncheckedCreateInput = {
    idprov?: number
    nom?: string | null
    dir?: string | null
    dep?: string | null
    logo?: Buffer | null
    idpe?: number | null
    estado?: boolean | null
    nit?: string | null
    inventario?: inventarioUncheckedCreateNestedManyWithoutProveedorInput
  }

  export type proveedorUpdateInput = {
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    dir?: NullableStringFieldUpdateOperationsInput | string | null
    dep?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    nit?: NullableStringFieldUpdateOperationsInput | string | null
    inventario?: inventarioUpdateManyWithoutProveedorNestedInput
    persona?: personaUpdateOneWithoutProveedorNestedInput
  }

  export type proveedorUncheckedUpdateInput = {
    idprov?: IntFieldUpdateOperationsInput | number
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    dir?: NullableStringFieldUpdateOperationsInput | string | null
    dep?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    idpe?: NullableIntFieldUpdateOperationsInput | number | null
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    nit?: NullableStringFieldUpdateOperationsInput | string | null
    inventario?: inventarioUncheckedUpdateManyWithoutProveedorNestedInput
  }

  export type proveedorCreateManyInput = {
    idprov?: number
    nom?: string | null
    dir?: string | null
    dep?: string | null
    logo?: Buffer | null
    idpe?: number | null
    estado?: boolean | null
    nit?: string | null
  }

  export type proveedorUpdateManyMutationInput = {
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    dir?: NullableStringFieldUpdateOperationsInput | string | null
    dep?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    nit?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type proveedorUncheckedUpdateManyInput = {
    idprov?: IntFieldUpdateOperationsInput | number
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    dir?: NullableStringFieldUpdateOperationsInput | string | null
    dep?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    idpe?: NullableIntFieldUpdateOperationsInput | number | null
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    nit?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type registrolaboralCreateInput = {
    tiporegistro?: string | null
    fecha?: Date | string | null
    hora?: Date | string | null
    mes?: string | null
    estado?: string | null
    adicional?: string | null
    adicional2?: string | null
    atraso?: Date | string | null
    usuario?: usuarioCreateNestedOneWithoutRegistrolaboralInput
  }

  export type registrolaboralUncheckedCreateInput = {
    idre?: number
    idu?: number | null
    tiporegistro?: string | null
    fecha?: Date | string | null
    hora?: Date | string | null
    mes?: string | null
    estado?: string | null
    adicional?: string | null
    adicional2?: string | null
    atraso?: Date | string | null
  }

  export type registrolaboralUpdateInput = {
    tiporegistro?: NullableStringFieldUpdateOperationsInput | string | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hora?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    mes?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableStringFieldUpdateOperationsInput | string | null
    adicional?: NullableStringFieldUpdateOperationsInput | string | null
    adicional2?: NullableStringFieldUpdateOperationsInput | string | null
    atraso?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    usuario?: usuarioUpdateOneWithoutRegistrolaboralNestedInput
  }

  export type registrolaboralUncheckedUpdateInput = {
    idre?: IntFieldUpdateOperationsInput | number
    idu?: NullableIntFieldUpdateOperationsInput | number | null
    tiporegistro?: NullableStringFieldUpdateOperationsInput | string | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hora?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    mes?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableStringFieldUpdateOperationsInput | string | null
    adicional?: NullableStringFieldUpdateOperationsInput | string | null
    adicional2?: NullableStringFieldUpdateOperationsInput | string | null
    atraso?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type registrolaboralCreateManyInput = {
    idre?: number
    idu?: number | null
    tiporegistro?: string | null
    fecha?: Date | string | null
    hora?: Date | string | null
    mes?: string | null
    estado?: string | null
    adicional?: string | null
    adicional2?: string | null
    atraso?: Date | string | null
  }

  export type registrolaboralUpdateManyMutationInput = {
    tiporegistro?: NullableStringFieldUpdateOperationsInput | string | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hora?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    mes?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableStringFieldUpdateOperationsInput | string | null
    adicional?: NullableStringFieldUpdateOperationsInput | string | null
    adicional2?: NullableStringFieldUpdateOperationsInput | string | null
    atraso?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type registrolaboralUncheckedUpdateManyInput = {
    idre?: IntFieldUpdateOperationsInput | number
    idu?: NullableIntFieldUpdateOperationsInput | number | null
    tiporegistro?: NullableStringFieldUpdateOperationsInput | string | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hora?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    mes?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableStringFieldUpdateOperationsInput | string | null
    adicional?: NullableStringFieldUpdateOperationsInput | string | null
    adicional2?: NullableStringFieldUpdateOperationsInput | string | null
    atraso?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type rolesCreateInput = {
    nombre: string
    descrip: string
    jerarquia: number
    estado?: boolean
    rolmenu?: rolmenuCreateNestedManyWithoutRolesInput
    usurol?: usurolCreateNestedManyWithoutRolesInput
  }

  export type rolesUncheckedCreateInput = {
    idr?: number
    nombre: string
    descrip: string
    jerarquia: number
    estado?: boolean
    rolmenu?: rolmenuUncheckedCreateNestedManyWithoutRolesInput
    usurol?: usurolUncheckedCreateNestedManyWithoutRolesInput
  }

  export type rolesUpdateInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    descrip?: StringFieldUpdateOperationsInput | string
    jerarquia?: IntFieldUpdateOperationsInput | number
    estado?: BoolFieldUpdateOperationsInput | boolean
    rolmenu?: rolmenuUpdateManyWithoutRolesNestedInput
    usurol?: usurolUpdateManyWithoutRolesNestedInput
  }

  export type rolesUncheckedUpdateInput = {
    idr?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    descrip?: StringFieldUpdateOperationsInput | string
    jerarquia?: IntFieldUpdateOperationsInput | number
    estado?: BoolFieldUpdateOperationsInput | boolean
    rolmenu?: rolmenuUncheckedUpdateManyWithoutRolesNestedInput
    usurol?: usurolUncheckedUpdateManyWithoutRolesNestedInput
  }

  export type rolesCreateManyInput = {
    idr?: number
    nombre: string
    descrip: string
    jerarquia: number
    estado?: boolean
  }

  export type rolesUpdateManyMutationInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    descrip?: StringFieldUpdateOperationsInput | string
    jerarquia?: IntFieldUpdateOperationsInput | number
    estado?: BoolFieldUpdateOperationsInput | boolean
  }

  export type rolesUncheckedUpdateManyInput = {
    idr?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    descrip?: StringFieldUpdateOperationsInput | string
    jerarquia?: IntFieldUpdateOperationsInput | number
    estado?: BoolFieldUpdateOperationsInput | boolean
  }

  export type rolmenuCreateInput = {
    menu: menuCreateNestedOneWithoutRolmenuInput
    roles: rolesCreateNestedOneWithoutRolmenuInput
  }

  export type rolmenuUncheckedCreateInput = {
    idr: number
    idm: number
  }

  export type rolmenuUpdateInput = {
    menu?: menuUpdateOneRequiredWithoutRolmenuNestedInput
    roles?: rolesUpdateOneRequiredWithoutRolmenuNestedInput
  }

  export type rolmenuUncheckedUpdateInput = {
    idr?: IntFieldUpdateOperationsInput | number
    idm?: IntFieldUpdateOperationsInput | number
  }

  export type rolmenuCreateManyInput = {
    idr: number
    idm: number
  }

  export type rolmenuUpdateManyMutationInput = {

  }

  export type rolmenuUncheckedUpdateManyInput = {
    idr?: IntFieldUpdateOperationsInput | number
    idm?: IntFieldUpdateOperationsInput | number
  }

  export type telefonoCreateInput = {
    numero: string
    estado?: boolean | null
    persona: personaCreateNestedOneWithoutTelefonoInput
  }

  export type telefonoUncheckedCreateInput = {
    idtel?: number
    idpe: number
    numero: string
    estado?: boolean | null
  }

  export type telefonoUpdateInput = {
    numero?: StringFieldUpdateOperationsInput | string
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    persona?: personaUpdateOneRequiredWithoutTelefonoNestedInput
  }

  export type telefonoUncheckedUpdateInput = {
    idtel?: IntFieldUpdateOperationsInput | number
    idpe?: IntFieldUpdateOperationsInput | number
    numero?: StringFieldUpdateOperationsInput | string
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type telefonoCreateManyInput = {
    idtel?: number
    idpe: number
    numero: string
    estado?: boolean | null
  }

  export type telefonoUpdateManyMutationInput = {
    numero?: StringFieldUpdateOperationsInput | string
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type telefonoUncheckedUpdateManyInput = {
    idtel?: IntFieldUpdateOperationsInput | number
    idpe?: IntFieldUpdateOperationsInput | number
    numero?: StringFieldUpdateOperationsInput | string
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type terminadoCreateInput = {
    nom?: string | null
    punit?: number | null
    estado?: boolean | null
    marca?: marcaCreateNestedOneWithoutTerminadoInput
  }

  export type terminadoUncheckedCreateInput = {
    idter?: number
    nom?: string | null
    punit?: number | null
    idmar?: number | null
    estado?: boolean | null
  }

  export type terminadoUpdateInput = {
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    punit?: NullableFloatFieldUpdateOperationsInput | number | null
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    marca?: marcaUpdateOneWithoutTerminadoNestedInput
  }

  export type terminadoUncheckedUpdateInput = {
    idter?: IntFieldUpdateOperationsInput | number
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    punit?: NullableFloatFieldUpdateOperationsInput | number | null
    idmar?: NullableIntFieldUpdateOperationsInput | number | null
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type terminadoCreateManyInput = {
    idter?: number
    nom?: string | null
    punit?: number | null
    idmar?: number | null
    estado?: boolean | null
  }

  export type terminadoUpdateManyMutationInput = {
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    punit?: NullableFloatFieldUpdateOperationsInput | number | null
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type terminadoUncheckedUpdateManyInput = {
    idter?: IntFieldUpdateOperationsInput | number
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    punit?: NullableFloatFieldUpdateOperationsInput | number | null
    idmar?: NullableIntFieldUpdateOperationsInput | number | null
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type usuarioCreateInput = {
    sexo: string
    foto?: Buffer | null
    fecnac: Date | string
    estado?: boolean | null
    base64?: string | null
    arte_arte_iduTousuario?: arteCreateNestedManyWithoutUsuario_arte_iduTousuarioInput
    arte_arte_iduaTousuario?: arteCreateNestedManyWithoutUsuario_arte_iduaTousuarioInput
    cotizacion?: cotizacionCreateNestedManyWithoutUsuarioInput
    datos?: datosCreateNestedManyWithoutUsuarioInput
    factura?: facturaCreateNestedManyWithoutUsuarioInput
    ordent?: ordentCreateNestedManyWithoutUsuarioInput
    registrolaboral?: registrolaboralCreateNestedManyWithoutUsuarioInput
    empresa?: empresaCreateNestedOneWithoutUsuarioInput
    persona: personaCreateNestedOneWithoutUsuarioInput
    usurol?: usurolCreateNestedManyWithoutUsuarioInput
  }

  export type usuarioUncheckedCreateInput = {
    idu?: number
    sexo: string
    foto?: Buffer | null
    fecnac: Date | string
    idpe: number
    estado?: boolean | null
    idem?: number | null
    base64?: string | null
    arte_arte_iduTousuario?: arteUncheckedCreateNestedManyWithoutUsuario_arte_iduTousuarioInput
    arte_arte_iduaTousuario?: arteUncheckedCreateNestedManyWithoutUsuario_arte_iduaTousuarioInput
    cotizacion?: cotizacionUncheckedCreateNestedManyWithoutUsuarioInput
    datos?: datosUncheckedCreateNestedManyWithoutUsuarioInput
    factura?: facturaUncheckedCreateNestedManyWithoutUsuarioInput
    ordent?: ordentUncheckedCreateNestedManyWithoutUsuarioInput
    registrolaboral?: registrolaboralUncheckedCreateNestedManyWithoutUsuarioInput
    usurol?: usurolUncheckedCreateNestedManyWithoutUsuarioInput
  }

  export type usuarioUpdateInput = {
    sexo?: StringFieldUpdateOperationsInput | string
    foto?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    fecnac?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    base64?: NullableStringFieldUpdateOperationsInput | string | null
    arte_arte_iduTousuario?: arteUpdateManyWithoutUsuario_arte_iduTousuarioNestedInput
    arte_arte_iduaTousuario?: arteUpdateManyWithoutUsuario_arte_iduaTousuarioNestedInput
    cotizacion?: cotizacionUpdateManyWithoutUsuarioNestedInput
    datos?: datosUpdateManyWithoutUsuarioNestedInput
    factura?: facturaUpdateManyWithoutUsuarioNestedInput
    ordent?: ordentUpdateManyWithoutUsuarioNestedInput
    registrolaboral?: registrolaboralUpdateManyWithoutUsuarioNestedInput
    empresa?: empresaUpdateOneWithoutUsuarioNestedInput
    persona?: personaUpdateOneRequiredWithoutUsuarioNestedInput
    usurol?: usurolUpdateManyWithoutUsuarioNestedInput
  }

  export type usuarioUncheckedUpdateInput = {
    idu?: IntFieldUpdateOperationsInput | number
    sexo?: StringFieldUpdateOperationsInput | string
    foto?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    fecnac?: DateTimeFieldUpdateOperationsInput | Date | string
    idpe?: IntFieldUpdateOperationsInput | number
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    idem?: NullableIntFieldUpdateOperationsInput | number | null
    base64?: NullableStringFieldUpdateOperationsInput | string | null
    arte_arte_iduTousuario?: arteUncheckedUpdateManyWithoutUsuario_arte_iduTousuarioNestedInput
    arte_arte_iduaTousuario?: arteUncheckedUpdateManyWithoutUsuario_arte_iduaTousuarioNestedInput
    cotizacion?: cotizacionUncheckedUpdateManyWithoutUsuarioNestedInput
    datos?: datosUncheckedUpdateManyWithoutUsuarioNestedInput
    factura?: facturaUncheckedUpdateManyWithoutUsuarioNestedInput
    ordent?: ordentUncheckedUpdateManyWithoutUsuarioNestedInput
    registrolaboral?: registrolaboralUncheckedUpdateManyWithoutUsuarioNestedInput
    usurol?: usurolUncheckedUpdateManyWithoutUsuarioNestedInput
  }

  export type usuarioCreateManyInput = {
    idu?: number
    sexo: string
    foto?: Buffer | null
    fecnac: Date | string
    idpe: number
    estado?: boolean | null
    idem?: number | null
    base64?: string | null
  }

  export type usuarioUpdateManyMutationInput = {
    sexo?: StringFieldUpdateOperationsInput | string
    foto?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    fecnac?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    base64?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type usuarioUncheckedUpdateManyInput = {
    idu?: IntFieldUpdateOperationsInput | number
    sexo?: StringFieldUpdateOperationsInput | string
    foto?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    fecnac?: DateTimeFieldUpdateOperationsInput | Date | string
    idpe?: IntFieldUpdateOperationsInput | number
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    idem?: NullableIntFieldUpdateOperationsInput | number | null
    base64?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type usurolCreateInput = {
    roles: rolesCreateNestedOneWithoutUsurolInput
    usuario: usuarioCreateNestedOneWithoutUsurolInput
  }

  export type usurolUncheckedCreateInput = {
    idr: number
    idu: number
  }

  export type usurolUpdateInput = {
    roles?: rolesUpdateOneRequiredWithoutUsurolNestedInput
    usuario?: usuarioUpdateOneRequiredWithoutUsurolNestedInput
  }

  export type usurolUncheckedUpdateInput = {
    idr?: IntFieldUpdateOperationsInput | number
    idu?: IntFieldUpdateOperationsInput | number
  }

  export type usurolCreateManyInput = {
    idr: number
    idu: number
  }

  export type usurolUpdateManyMutationInput = {

  }

  export type usurolUncheckedUpdateManyInput = {
    idr?: IntFieldUpdateOperationsInput | number
    idu?: IntFieldUpdateOperationsInput | number
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type OrdentNullableRelationFilter = {
    is?: ordentWhereInput | null
    isNot?: ordentWhereInput | null
  }

  export type UsuarioNullableRelationFilter = {
    is?: usuarioWhereInput | null
    isNot?: usuarioWhereInput | null
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type arteCountOrderByAggregateInput = {
    idar?: SortOrder
    idu?: SortOrder
    idot?: SortOrder
    fechar?: SortOrder
    fechaa?: SortOrder
    idua?: SortOrder
    estado?: SortOrder
    obs?: SortOrder
    precio?: SortOrder
  }

  export type arteAvgOrderByAggregateInput = {
    idar?: SortOrder
    idu?: SortOrder
    idot?: SortOrder
    idua?: SortOrder
    precio?: SortOrder
  }

  export type arteMaxOrderByAggregateInput = {
    idar?: SortOrder
    idu?: SortOrder
    idot?: SortOrder
    fechar?: SortOrder
    fechaa?: SortOrder
    idua?: SortOrder
    estado?: SortOrder
    obs?: SortOrder
    precio?: SortOrder
  }

  export type arteMinOrderByAggregateInput = {
    idar?: SortOrder
    idu?: SortOrder
    idot?: SortOrder
    fechar?: SortOrder
    fechaa?: SortOrder
    idua?: SortOrder
    estado?: SortOrder
    obs?: SortOrder
    precio?: SortOrder
  }

  export type arteSumOrderByAggregateInput = {
    idar?: SortOrder
    idu?: SortOrder
    idot?: SortOrder
    idua?: SortOrder
    precio?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type PersonaRelationFilter = {
    is?: personaWhereInput
    isNot?: personaWhereInput
  }

  export type CotizacionListRelationFilter = {
    every?: cotizacionWhereInput
    some?: cotizacionWhereInput
    none?: cotizacionWhereInput
  }

  export type OrdentListRelationFilter = {
    every?: ordentWhereInput
    some?: ordentWhereInput
    none?: ordentWhereInput
  }

  export type cotizacionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ordentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type clienteCountOrderByAggregateInput = {
    idcli?: SortOrder
    idpe?: SortOrder
    estado?: SortOrder
  }

  export type clienteAvgOrderByAggregateInput = {
    idcli?: SortOrder
    idpe?: SortOrder
  }

  export type clienteMaxOrderByAggregateInput = {
    idcli?: SortOrder
    idpe?: SortOrder
    estado?: SortOrder
  }

  export type clienteMinOrderByAggregateInput = {
    idcli?: SortOrder
    idpe?: SortOrder
    estado?: SortOrder
  }

  export type clienteSumOrderByAggregateInput = {
    idcli?: SortOrder
    idpe?: SortOrder
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type MarcaNullableRelationFilter = {
    is?: marcaWhereInput | null
    isNot?: marcaWhereInput | null
  }

  export type colorCountOrderByAggregateInput = {
    idcolor?: SortOrder
    nom?: SortOrder
    punit?: SortOrder
    idmar?: SortOrder
    estado?: SortOrder
    des?: SortOrder
  }

  export type colorAvgOrderByAggregateInput = {
    idcolor?: SortOrder
    punit?: SortOrder
    idmar?: SortOrder
  }

  export type colorMaxOrderByAggregateInput = {
    idcolor?: SortOrder
    nom?: SortOrder
    punit?: SortOrder
    idmar?: SortOrder
    estado?: SortOrder
    des?: SortOrder
  }

  export type colorMinOrderByAggregateInput = {
    idcolor?: SortOrder
    nom?: SortOrder
    punit?: SortOrder
    idmar?: SortOrder
    estado?: SortOrder
    des?: SortOrder
  }

  export type colorSumOrderByAggregateInput = {
    idcolor?: SortOrder
    punit?: SortOrder
    idmar?: SortOrder
  }

  export type configuracionlaboralCountOrderByAggregateInput = {
    idconf?: SortOrder
    entrada?: SortOrder
    salida?: SortOrder
    tipo?: SortOrder
    retrasopermitido?: SortOrder
    adicional?: SortOrder
    adicional1?: SortOrder
  }

  export type configuracionlaboralAvgOrderByAggregateInput = {
    idconf?: SortOrder
  }

  export type configuracionlaboralMaxOrderByAggregateInput = {
    idconf?: SortOrder
    entrada?: SortOrder
    salida?: SortOrder
    tipo?: SortOrder
    retrasopermitido?: SortOrder
    adicional?: SortOrder
    adicional1?: SortOrder
  }

  export type configuracionlaboralMinOrderByAggregateInput = {
    idconf?: SortOrder
    entrada?: SortOrder
    salida?: SortOrder
    tipo?: SortOrder
    retrasopermitido?: SortOrder
    adicional?: SortOrder
    adicional1?: SortOrder
  }

  export type configuracionlaboralSumOrderByAggregateInput = {
    idconf?: SortOrder
  }

  export type ClienteNullableRelationFilter = {
    is?: clienteWhereInput | null
    isNot?: clienteWhereInput | null
  }

  export type DetcotListRelationFilter = {
    every?: detcotWhereInput
    some?: detcotWhereInput
    none?: detcotWhereInput
  }

  export type detcotOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type cotizacionCountOrderByAggregateInput = {
    idcot?: SortOrder
    idu?: SortOrder
    idcli?: SortOrder
    fecha?: SortOrder
    precio?: SortOrder
    descuento?: SortOrder
    preciofinal?: SortOrder
    tiempo?: SortOrder
    arte?: SortOrder
    obs?: SortOrder
    estado?: SortOrder
  }

  export type cotizacionAvgOrderByAggregateInput = {
    idcot?: SortOrder
    idu?: SortOrder
    idcli?: SortOrder
    precio?: SortOrder
    descuento?: SortOrder
    preciofinal?: SortOrder
    tiempo?: SortOrder
  }

  export type cotizacionMaxOrderByAggregateInput = {
    idcot?: SortOrder
    idu?: SortOrder
    idcli?: SortOrder
    fecha?: SortOrder
    precio?: SortOrder
    descuento?: SortOrder
    preciofinal?: SortOrder
    tiempo?: SortOrder
    arte?: SortOrder
    obs?: SortOrder
    estado?: SortOrder
  }

  export type cotizacionMinOrderByAggregateInput = {
    idcot?: SortOrder
    idu?: SortOrder
    idcli?: SortOrder
    fecha?: SortOrder
    precio?: SortOrder
    descuento?: SortOrder
    preciofinal?: SortOrder
    tiempo?: SortOrder
    arte?: SortOrder
    obs?: SortOrder
    estado?: SortOrder
  }

  export type cotizacionSumOrderByAggregateInput = {
    idcot?: SortOrder
    idu?: SortOrder
    idcli?: SortOrder
    precio?: SortOrder
    descuento?: SortOrder
    preciofinal?: SortOrder
    tiempo?: SortOrder
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type UsuarioRelationFilter = {
    is?: usuarioWhereInput
    isNot?: usuarioWhereInput
  }

  export type datosCountOrderByAggregateInput = {
    idu?: SortOrder
    login?: SortOrder
    contrasenia?: SortOrder
  }

  export type datosAvgOrderByAggregateInput = {
    idu?: SortOrder
  }

  export type datosMaxOrderByAggregateInput = {
    idu?: SortOrder
    login?: SortOrder
    contrasenia?: SortOrder
  }

  export type datosMinOrderByAggregateInput = {
    idu?: SortOrder
    login?: SortOrder
    contrasenia?: SortOrder
  }

  export type datosSumOrderByAggregateInput = {
    idu?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type CotizacionNullableRelationFilter = {
    is?: cotizacionWhereInput | null
    isNot?: cotizacionWhereInput | null
  }

  export type ProductoNullableRelationFilter = {
    is?: productoWhereInput | null
    isNot?: productoWhereInput | null
  }

  export type detcotCountOrderByAggregateInput = {
    iddetcot?: SortOrder
    idcot?: SortOrder
    idpro?: SortOrder
    cant?: SortOrder
    punit?: SortOrder
    stotal?: SortOrder
    material?: SortOrder
    gr?: SortOrder
    tintas?: SortOrder
    estado?: SortOrder
  }

  export type detcotAvgOrderByAggregateInput = {
    iddetcot?: SortOrder
    idcot?: SortOrder
    idpro?: SortOrder
    cant?: SortOrder
    punit?: SortOrder
    stotal?: SortOrder
  }

  export type detcotMaxOrderByAggregateInput = {
    iddetcot?: SortOrder
    idcot?: SortOrder
    idpro?: SortOrder
    cant?: SortOrder
    punit?: SortOrder
    stotal?: SortOrder
    material?: SortOrder
    gr?: SortOrder
    tintas?: SortOrder
    estado?: SortOrder
  }

  export type detcotMinOrderByAggregateInput = {
    iddetcot?: SortOrder
    idcot?: SortOrder
    idpro?: SortOrder
    cant?: SortOrder
    punit?: SortOrder
    stotal?: SortOrder
    material?: SortOrder
    gr?: SortOrder
    tintas?: SortOrder
    estado?: SortOrder
  }

  export type detcotSumOrderByAggregateInput = {
    iddetcot?: SortOrder
    idcot?: SortOrder
    idpro?: SortOrder
    cant?: SortOrder
    punit?: SortOrder
    stotal?: SortOrder
  }

  export type detotCountOrderByAggregateInput = {
    iddetot?: SortOrder
    idot?: SortOrder
    idpro?: SortOrder
    cant?: SortOrder
    punit?: SortOrder
    stotal?: SortOrder
    material?: SortOrder
    gr?: SortOrder
    tintas?: SortOrder
    estado?: SortOrder
  }

  export type detotAvgOrderByAggregateInput = {
    iddetot?: SortOrder
    idot?: SortOrder
    idpro?: SortOrder
    cant?: SortOrder
    punit?: SortOrder
    stotal?: SortOrder
  }

  export type detotMaxOrderByAggregateInput = {
    iddetot?: SortOrder
    idot?: SortOrder
    idpro?: SortOrder
    cant?: SortOrder
    punit?: SortOrder
    stotal?: SortOrder
    material?: SortOrder
    gr?: SortOrder
    tintas?: SortOrder
    estado?: SortOrder
  }

  export type detotMinOrderByAggregateInput = {
    iddetot?: SortOrder
    idot?: SortOrder
    idpro?: SortOrder
    cant?: SortOrder
    punit?: SortOrder
    stotal?: SortOrder
    material?: SortOrder
    gr?: SortOrder
    tintas?: SortOrder
    estado?: SortOrder
  }

  export type detotSumOrderByAggregateInput = {
    iddetot?: SortOrder
    idot?: SortOrder
    idpro?: SortOrder
    cant?: SortOrder
    punit?: SortOrder
    stotal?: SortOrder
  }

  export type BytesNullableFilter<$PrismaModel = never> = {
    equals?: Buffer | BytesFieldRefInput<$PrismaModel> | null
    in?: Buffer[] | ListBytesFieldRefInput<$PrismaModel> | null
    notIn?: Buffer[] | ListBytesFieldRefInput<$PrismaModel> | null
    not?: NestedBytesNullableFilter<$PrismaModel> | Buffer | null
  }

  export type PersonaNullableRelationFilter = {
    is?: personaWhereInput | null
    isNot?: personaWhereInput | null
  }

  export type LeyendaListRelationFilter = {
    every?: leyendaWhereInput
    some?: leyendaWhereInput
    none?: leyendaWhereInput
  }

  export type UsuarioListRelationFilter = {
    every?: usuarioWhereInput
    some?: usuarioWhereInput
    none?: usuarioWhereInput
  }

  export type leyendaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type usuarioOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type empresaCountOrderByAggregateInput = {
    idem?: SortOrder
    nom?: SortOrder
    dir?: SortOrder
    des?: SortOrder
    dep?: SortOrder
    logo?: SortOrder
    idpe?: SortOrder
    nit?: SortOrder
    auto?: SortOrder
    base64?: SortOrder
  }

  export type empresaAvgOrderByAggregateInput = {
    idem?: SortOrder
    idpe?: SortOrder
  }

  export type empresaMaxOrderByAggregateInput = {
    idem?: SortOrder
    nom?: SortOrder
    dir?: SortOrder
    des?: SortOrder
    dep?: SortOrder
    logo?: SortOrder
    idpe?: SortOrder
    nit?: SortOrder
    auto?: SortOrder
    base64?: SortOrder
  }

  export type empresaMinOrderByAggregateInput = {
    idem?: SortOrder
    nom?: SortOrder
    dir?: SortOrder
    des?: SortOrder
    dep?: SortOrder
    logo?: SortOrder
    idpe?: SortOrder
    nit?: SortOrder
    auto?: SortOrder
    base64?: SortOrder
  }

  export type empresaSumOrderByAggregateInput = {
    idem?: SortOrder
    idpe?: SortOrder
  }

  export type BytesNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Buffer | BytesFieldRefInput<$PrismaModel> | null
    in?: Buffer[] | ListBytesFieldRefInput<$PrismaModel> | null
    notIn?: Buffer[] | ListBytesFieldRefInput<$PrismaModel> | null
    not?: NestedBytesNullableWithAggregatesFilter<$PrismaModel> | Buffer | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBytesNullableFilter<$PrismaModel>
    _max?: NestedBytesNullableFilter<$PrismaModel>
  }

  export type eventosCountOrderByAggregateInput = {
    idev?: SortOrder
    fechainicio?: SortOrder
    fechafin?: SortOrder
    tipo?: SortOrder
    evento?: SortOrder
    adicional?: SortOrder
    adicional1?: SortOrder
    estado?: SortOrder
  }

  export type eventosAvgOrderByAggregateInput = {
    idev?: SortOrder
  }

  export type eventosMaxOrderByAggregateInput = {
    idev?: SortOrder
    fechainicio?: SortOrder
    fechafin?: SortOrder
    tipo?: SortOrder
    evento?: SortOrder
    adicional?: SortOrder
    adicional1?: SortOrder
    estado?: SortOrder
  }

  export type eventosMinOrderByAggregateInput = {
    idev?: SortOrder
    fechainicio?: SortOrder
    fechafin?: SortOrder
    tipo?: SortOrder
    evento?: SortOrder
    adicional?: SortOrder
    adicional1?: SortOrder
    estado?: SortOrder
  }

  export type eventosSumOrderByAggregateInput = {
    idev?: SortOrder
  }

  export type facturaCountOrderByAggregateInput = {
    idfac?: SortOrder
    idot?: SortOrder
    idu?: SortOrder
    monto?: SortOrder
    fecha?: SortOrder
    aux?: SortOrder
    aux1?: SortOrder
  }

  export type facturaAvgOrderByAggregateInput = {
    idfac?: SortOrder
    idot?: SortOrder
    idu?: SortOrder
    monto?: SortOrder
  }

  export type facturaMaxOrderByAggregateInput = {
    idfac?: SortOrder
    idot?: SortOrder
    idu?: SortOrder
    monto?: SortOrder
    fecha?: SortOrder
    aux?: SortOrder
    aux1?: SortOrder
  }

  export type facturaMinOrderByAggregateInput = {
    idfac?: SortOrder
    idot?: SortOrder
    idu?: SortOrder
    monto?: SortOrder
    fecha?: SortOrder
    aux?: SortOrder
    aux1?: SortOrder
  }

  export type facturaSumOrderByAggregateInput = {
    idfac?: SortOrder
    idot?: SortOrder
    idu?: SortOrder
    monto?: SortOrder
  }

  export type ProveedorNullableRelationFilter = {
    is?: proveedorWhereInput | null
    isNot?: proveedorWhereInput | null
  }

  export type inventarioCountOrderByAggregateInput = {
    idin?: SortOrder
    idprov?: SortOrder
    codigo?: SortOrder
    nom?: SortOrder
    precio?: SortOrder
    gr?: SortOrder
    tam?: SortOrder
    des?: SortOrder
    cant?: SortOrder
    estado?: SortOrder
  }

  export type inventarioAvgOrderByAggregateInput = {
    idin?: SortOrder
    idprov?: SortOrder
    precio?: SortOrder
    gr?: SortOrder
    cant?: SortOrder
  }

  export type inventarioMaxOrderByAggregateInput = {
    idin?: SortOrder
    idprov?: SortOrder
    codigo?: SortOrder
    nom?: SortOrder
    precio?: SortOrder
    gr?: SortOrder
    tam?: SortOrder
    des?: SortOrder
    cant?: SortOrder
    estado?: SortOrder
  }

  export type inventarioMinOrderByAggregateInput = {
    idin?: SortOrder
    idprov?: SortOrder
    codigo?: SortOrder
    nom?: SortOrder
    precio?: SortOrder
    gr?: SortOrder
    tam?: SortOrder
    des?: SortOrder
    cant?: SortOrder
    estado?: SortOrder
  }

  export type inventarioSumOrderByAggregateInput = {
    idin?: SortOrder
    idprov?: SortOrder
    precio?: SortOrder
    gr?: SortOrder
    cant?: SortOrder
  }

  export type EmpresaNullableRelationFilter = {
    is?: empresaWhereInput | null
    isNot?: empresaWhereInput | null
  }

  export type leyendaCountOrderByAggregateInput = {
    idle?: SortOrder
    des?: SortOrder
    orden?: SortOrder
    idem?: SortOrder
  }

  export type leyendaAvgOrderByAggregateInput = {
    idle?: SortOrder
    orden?: SortOrder
    idem?: SortOrder
  }

  export type leyendaMaxOrderByAggregateInput = {
    idle?: SortOrder
    des?: SortOrder
    orden?: SortOrder
    idem?: SortOrder
  }

  export type leyendaMinOrderByAggregateInput = {
    idle?: SortOrder
    des?: SortOrder
    orden?: SortOrder
    idem?: SortOrder
  }

  export type leyendaSumOrderByAggregateInput = {
    idle?: SortOrder
    orden?: SortOrder
    idem?: SortOrder
  }

  export type ColorListRelationFilter = {
    every?: colorWhereInput
    some?: colorWhereInput
    none?: colorWhereInput
  }

  export type ProductoListRelationFilter = {
    every?: productoWhereInput
    some?: productoWhereInput
    none?: productoWhereInput
  }

  export type TerminadoListRelationFilter = {
    every?: terminadoWhereInput
    some?: terminadoWhereInput
    none?: terminadoWhereInput
  }

  export type colorOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type productoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type terminadoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type marcaCountOrderByAggregateInput = {
    idmar?: SortOrder
    nom?: SortOrder
    des?: SortOrder
    estado?: SortOrder
  }

  export type marcaAvgOrderByAggregateInput = {
    idmar?: SortOrder
  }

  export type marcaMaxOrderByAggregateInput = {
    idmar?: SortOrder
    nom?: SortOrder
    des?: SortOrder
    estado?: SortOrder
  }

  export type marcaMinOrderByAggregateInput = {
    idmar?: SortOrder
    nom?: SortOrder
    des?: SortOrder
    estado?: SortOrder
  }

  export type marcaSumOrderByAggregateInput = {
    idmar?: SortOrder
  }

  export type RolmenuListRelationFilter = {
    every?: rolmenuWhereInput
    some?: rolmenuWhereInput
    none?: rolmenuWhereInput
  }

  export type rolmenuOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type menuCountOrderByAggregateInput = {
    idm?: SortOrder
    nom?: SortOrder
    url?: SortOrder
    estado?: SortOrder
  }

  export type menuAvgOrderByAggregateInput = {
    idm?: SortOrder
  }

  export type menuMaxOrderByAggregateInput = {
    idm?: SortOrder
    nom?: SortOrder
    url?: SortOrder
    estado?: SortOrder
  }

  export type menuMinOrderByAggregateInput = {
    idm?: SortOrder
    nom?: SortOrder
    url?: SortOrder
    estado?: SortOrder
  }

  export type menuSumOrderByAggregateInput = {
    idm?: SortOrder
  }

  export type ArteListRelationFilter = {
    every?: arteWhereInput
    some?: arteWhereInput
    none?: arteWhereInput
  }

  export type DetotListRelationFilter = {
    every?: detotWhereInput
    some?: detotWhereInput
    none?: detotWhereInput
  }

  export type FacturaListRelationFilter = {
    every?: facturaWhereInput
    some?: facturaWhereInput
    none?: facturaWhereInput
  }

  export type PagoListRelationFilter = {
    every?: pagoWhereInput
    some?: pagoWhereInput
    none?: pagoWhereInput
  }

  export type arteOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type detotOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type facturaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type pagoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ordentCountOrderByAggregateInput = {
    idot?: SortOrder
    idu?: SortOrder
    idcli?: SortOrder
    idcot?: SortOrder
    fecha?: SortOrder
    precio?: SortOrder
    descuento?: SortOrder
    preciofinal?: SortOrder
    tiempo?: SortOrder
    arte?: SortOrder
    obs?: SortOrder
    estado?: SortOrder
    factura?: SortOrder
  }

  export type ordentAvgOrderByAggregateInput = {
    idot?: SortOrder
    idu?: SortOrder
    idcli?: SortOrder
    idcot?: SortOrder
    precio?: SortOrder
    descuento?: SortOrder
    preciofinal?: SortOrder
    tiempo?: SortOrder
  }

  export type ordentMaxOrderByAggregateInput = {
    idot?: SortOrder
    idu?: SortOrder
    idcli?: SortOrder
    idcot?: SortOrder
    fecha?: SortOrder
    precio?: SortOrder
    descuento?: SortOrder
    preciofinal?: SortOrder
    tiempo?: SortOrder
    arte?: SortOrder
    obs?: SortOrder
    estado?: SortOrder
    factura?: SortOrder
  }

  export type ordentMinOrderByAggregateInput = {
    idot?: SortOrder
    idu?: SortOrder
    idcli?: SortOrder
    idcot?: SortOrder
    fecha?: SortOrder
    precio?: SortOrder
    descuento?: SortOrder
    preciofinal?: SortOrder
    tiempo?: SortOrder
    arte?: SortOrder
    obs?: SortOrder
    estado?: SortOrder
    factura?: SortOrder
  }

  export type ordentSumOrderByAggregateInput = {
    idot?: SortOrder
    idu?: SortOrder
    idcli?: SortOrder
    idcot?: SortOrder
    precio?: SortOrder
    descuento?: SortOrder
    preciofinal?: SortOrder
    tiempo?: SortOrder
  }

  export type pagoCountOrderByAggregateInput = {
    idpagp?: SortOrder
    idot?: SortOrder
    fecha?: SortOrder
    preciof?: SortOrder
    pago?: SortOrder
    saldo?: SortOrder
    des?: SortOrder
    comprobante?: SortOrder
  }

  export type pagoAvgOrderByAggregateInput = {
    idpagp?: SortOrder
    idot?: SortOrder
    preciof?: SortOrder
    pago?: SortOrder
    saldo?: SortOrder
  }

  export type pagoMaxOrderByAggregateInput = {
    idpagp?: SortOrder
    idot?: SortOrder
    fecha?: SortOrder
    preciof?: SortOrder
    pago?: SortOrder
    saldo?: SortOrder
    des?: SortOrder
    comprobante?: SortOrder
  }

  export type pagoMinOrderByAggregateInput = {
    idpagp?: SortOrder
    idot?: SortOrder
    fecha?: SortOrder
    preciof?: SortOrder
    pago?: SortOrder
    saldo?: SortOrder
    des?: SortOrder
    comprobante?: SortOrder
  }

  export type pagoSumOrderByAggregateInput = {
    idpagp?: SortOrder
    idot?: SortOrder
    preciof?: SortOrder
    pago?: SortOrder
    saldo?: SortOrder
  }

  export type ClienteListRelationFilter = {
    every?: clienteWhereInput
    some?: clienteWhereInput
    none?: clienteWhereInput
  }

  export type EmpresaListRelationFilter = {
    every?: empresaWhereInput
    some?: empresaWhereInput
    none?: empresaWhereInput
  }

  export type ProveedorListRelationFilter = {
    every?: proveedorWhereInput
    some?: proveedorWhereInput
    none?: proveedorWhereInput
  }

  export type TelefonoListRelationFilter = {
    every?: telefonoWhereInput
    some?: telefonoWhereInput
    none?: telefonoWhereInput
  }

  export type clienteOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type empresaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type proveedorOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type telefonoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type personaCountOrderByAggregateInput = {
    idpe?: SortOrder
    ci?: SortOrder
    nombre?: SortOrder
    ap?: SortOrder
    am?: SortOrder
    direccion?: SortOrder
    email?: SortOrder
    estado?: SortOrder
    base64?: SortOrder
  }

  export type personaAvgOrderByAggregateInput = {
    idpe?: SortOrder
  }

  export type personaMaxOrderByAggregateInput = {
    idpe?: SortOrder
    ci?: SortOrder
    nombre?: SortOrder
    ap?: SortOrder
    am?: SortOrder
    direccion?: SortOrder
    email?: SortOrder
    estado?: SortOrder
    base64?: SortOrder
  }

  export type personaMinOrderByAggregateInput = {
    idpe?: SortOrder
    ci?: SortOrder
    nombre?: SortOrder
    ap?: SortOrder
    am?: SortOrder
    direccion?: SortOrder
    email?: SortOrder
    estado?: SortOrder
    base64?: SortOrder
  }

  export type personaSumOrderByAggregateInput = {
    idpe?: SortOrder
  }

  export type productoCountOrderByAggregateInput = {
    idpro?: SortOrder
    nom?: SortOrder
    tam?: SortOrder
    des?: SortOrder
    preciov?: SortOrder
    precioc?: SortOrder
    cantidad?: SortOrder
    foto?: SortOrder
    idmar?: SortOrder
    estado?: SortOrder
    base64?: SortOrder
    ranking?: SortOrder
  }

  export type productoAvgOrderByAggregateInput = {
    idpro?: SortOrder
    preciov?: SortOrder
    precioc?: SortOrder
    cantidad?: SortOrder
    idmar?: SortOrder
    ranking?: SortOrder
  }

  export type productoMaxOrderByAggregateInput = {
    idpro?: SortOrder
    nom?: SortOrder
    tam?: SortOrder
    des?: SortOrder
    preciov?: SortOrder
    precioc?: SortOrder
    cantidad?: SortOrder
    foto?: SortOrder
    idmar?: SortOrder
    estado?: SortOrder
    base64?: SortOrder
    ranking?: SortOrder
  }

  export type productoMinOrderByAggregateInput = {
    idpro?: SortOrder
    nom?: SortOrder
    tam?: SortOrder
    des?: SortOrder
    preciov?: SortOrder
    precioc?: SortOrder
    cantidad?: SortOrder
    foto?: SortOrder
    idmar?: SortOrder
    estado?: SortOrder
    base64?: SortOrder
    ranking?: SortOrder
  }

  export type productoSumOrderByAggregateInput = {
    idpro?: SortOrder
    preciov?: SortOrder
    precioc?: SortOrder
    cantidad?: SortOrder
    idmar?: SortOrder
    ranking?: SortOrder
  }

  export type InventarioListRelationFilter = {
    every?: inventarioWhereInput
    some?: inventarioWhereInput
    none?: inventarioWhereInput
  }

  export type inventarioOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type proveedorCountOrderByAggregateInput = {
    idprov?: SortOrder
    nom?: SortOrder
    dir?: SortOrder
    dep?: SortOrder
    logo?: SortOrder
    idpe?: SortOrder
    estado?: SortOrder
    nit?: SortOrder
  }

  export type proveedorAvgOrderByAggregateInput = {
    idprov?: SortOrder
    idpe?: SortOrder
  }

  export type proveedorMaxOrderByAggregateInput = {
    idprov?: SortOrder
    nom?: SortOrder
    dir?: SortOrder
    dep?: SortOrder
    logo?: SortOrder
    idpe?: SortOrder
    estado?: SortOrder
    nit?: SortOrder
  }

  export type proveedorMinOrderByAggregateInput = {
    idprov?: SortOrder
    nom?: SortOrder
    dir?: SortOrder
    dep?: SortOrder
    logo?: SortOrder
    idpe?: SortOrder
    estado?: SortOrder
    nit?: SortOrder
  }

  export type proveedorSumOrderByAggregateInput = {
    idprov?: SortOrder
    idpe?: SortOrder
  }

  export type registrolaboralCountOrderByAggregateInput = {
    idre?: SortOrder
    idu?: SortOrder
    tiporegistro?: SortOrder
    fecha?: SortOrder
    hora?: SortOrder
    mes?: SortOrder
    estado?: SortOrder
    adicional?: SortOrder
    adicional2?: SortOrder
    atraso?: SortOrder
  }

  export type registrolaboralAvgOrderByAggregateInput = {
    idre?: SortOrder
    idu?: SortOrder
  }

  export type registrolaboralMaxOrderByAggregateInput = {
    idre?: SortOrder
    idu?: SortOrder
    tiporegistro?: SortOrder
    fecha?: SortOrder
    hora?: SortOrder
    mes?: SortOrder
    estado?: SortOrder
    adicional?: SortOrder
    adicional2?: SortOrder
    atraso?: SortOrder
  }

  export type registrolaboralMinOrderByAggregateInput = {
    idre?: SortOrder
    idu?: SortOrder
    tiporegistro?: SortOrder
    fecha?: SortOrder
    hora?: SortOrder
    mes?: SortOrder
    estado?: SortOrder
    adicional?: SortOrder
    adicional2?: SortOrder
    atraso?: SortOrder
  }

  export type registrolaboralSumOrderByAggregateInput = {
    idre?: SortOrder
    idu?: SortOrder
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type UsurolListRelationFilter = {
    every?: usurolWhereInput
    some?: usurolWhereInput
    none?: usurolWhereInput
  }

  export type usurolOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type rolesCountOrderByAggregateInput = {
    idr?: SortOrder
    nombre?: SortOrder
    descrip?: SortOrder
    jerarquia?: SortOrder
    estado?: SortOrder
  }

  export type rolesAvgOrderByAggregateInput = {
    idr?: SortOrder
    jerarquia?: SortOrder
  }

  export type rolesMaxOrderByAggregateInput = {
    idr?: SortOrder
    nombre?: SortOrder
    descrip?: SortOrder
    jerarquia?: SortOrder
    estado?: SortOrder
  }

  export type rolesMinOrderByAggregateInput = {
    idr?: SortOrder
    nombre?: SortOrder
    descrip?: SortOrder
    jerarquia?: SortOrder
    estado?: SortOrder
  }

  export type rolesSumOrderByAggregateInput = {
    idr?: SortOrder
    jerarquia?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type MenuRelationFilter = {
    is?: menuWhereInput
    isNot?: menuWhereInput
  }

  export type RolesRelationFilter = {
    is?: rolesWhereInput
    isNot?: rolesWhereInput
  }

  export type rolmenuIdrIdmCompoundUniqueInput = {
    idr: number
    idm: number
  }

  export type rolmenuCountOrderByAggregateInput = {
    idr?: SortOrder
    idm?: SortOrder
  }

  export type rolmenuAvgOrderByAggregateInput = {
    idr?: SortOrder
    idm?: SortOrder
  }

  export type rolmenuMaxOrderByAggregateInput = {
    idr?: SortOrder
    idm?: SortOrder
  }

  export type rolmenuMinOrderByAggregateInput = {
    idr?: SortOrder
    idm?: SortOrder
  }

  export type rolmenuSumOrderByAggregateInput = {
    idr?: SortOrder
    idm?: SortOrder
  }

  export type telefonoCountOrderByAggregateInput = {
    idtel?: SortOrder
    idpe?: SortOrder
    numero?: SortOrder
    estado?: SortOrder
  }

  export type telefonoAvgOrderByAggregateInput = {
    idtel?: SortOrder
    idpe?: SortOrder
  }

  export type telefonoMaxOrderByAggregateInput = {
    idtel?: SortOrder
    idpe?: SortOrder
    numero?: SortOrder
    estado?: SortOrder
  }

  export type telefonoMinOrderByAggregateInput = {
    idtel?: SortOrder
    idpe?: SortOrder
    numero?: SortOrder
    estado?: SortOrder
  }

  export type telefonoSumOrderByAggregateInput = {
    idtel?: SortOrder
    idpe?: SortOrder
  }

  export type terminadoCountOrderByAggregateInput = {
    idter?: SortOrder
    nom?: SortOrder
    punit?: SortOrder
    idmar?: SortOrder
    estado?: SortOrder
  }

  export type terminadoAvgOrderByAggregateInput = {
    idter?: SortOrder
    punit?: SortOrder
    idmar?: SortOrder
  }

  export type terminadoMaxOrderByAggregateInput = {
    idter?: SortOrder
    nom?: SortOrder
    punit?: SortOrder
    idmar?: SortOrder
    estado?: SortOrder
  }

  export type terminadoMinOrderByAggregateInput = {
    idter?: SortOrder
    nom?: SortOrder
    punit?: SortOrder
    idmar?: SortOrder
    estado?: SortOrder
  }

  export type terminadoSumOrderByAggregateInput = {
    idter?: SortOrder
    punit?: SortOrder
    idmar?: SortOrder
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type DatosListRelationFilter = {
    every?: datosWhereInput
    some?: datosWhereInput
    none?: datosWhereInput
  }

  export type RegistrolaboralListRelationFilter = {
    every?: registrolaboralWhereInput
    some?: registrolaboralWhereInput
    none?: registrolaboralWhereInput
  }

  export type datosOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type registrolaboralOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type usuarioCountOrderByAggregateInput = {
    idu?: SortOrder
    sexo?: SortOrder
    foto?: SortOrder
    fecnac?: SortOrder
    idpe?: SortOrder
    estado?: SortOrder
    idem?: SortOrder
    base64?: SortOrder
  }

  export type usuarioAvgOrderByAggregateInput = {
    idu?: SortOrder
    idpe?: SortOrder
    idem?: SortOrder
  }

  export type usuarioMaxOrderByAggregateInput = {
    idu?: SortOrder
    sexo?: SortOrder
    foto?: SortOrder
    fecnac?: SortOrder
    idpe?: SortOrder
    estado?: SortOrder
    idem?: SortOrder
    base64?: SortOrder
  }

  export type usuarioMinOrderByAggregateInput = {
    idu?: SortOrder
    sexo?: SortOrder
    foto?: SortOrder
    fecnac?: SortOrder
    idpe?: SortOrder
    estado?: SortOrder
    idem?: SortOrder
    base64?: SortOrder
  }

  export type usuarioSumOrderByAggregateInput = {
    idu?: SortOrder
    idpe?: SortOrder
    idem?: SortOrder
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type usurolIdrIduCompoundUniqueInput = {
    idr: number
    idu: number
  }

  export type usurolCountOrderByAggregateInput = {
    idr?: SortOrder
    idu?: SortOrder
  }

  export type usurolAvgOrderByAggregateInput = {
    idr?: SortOrder
    idu?: SortOrder
  }

  export type usurolMaxOrderByAggregateInput = {
    idr?: SortOrder
    idu?: SortOrder
  }

  export type usurolMinOrderByAggregateInput = {
    idr?: SortOrder
    idu?: SortOrder
  }

  export type usurolSumOrderByAggregateInput = {
    idr?: SortOrder
    idu?: SortOrder
  }

  export type ordentCreateNestedOneWithoutArte1Input = {
    create?: XOR<ordentCreateWithoutArte1Input, ordentUncheckedCreateWithoutArte1Input>
    connectOrCreate?: ordentCreateOrConnectWithoutArte1Input
    connect?: ordentWhereUniqueInput
  }

  export type usuarioCreateNestedOneWithoutArte_arte_iduTousuarioInput = {
    create?: XOR<usuarioCreateWithoutArte_arte_iduTousuarioInput, usuarioUncheckedCreateWithoutArte_arte_iduTousuarioInput>
    connectOrCreate?: usuarioCreateOrConnectWithoutArte_arte_iduTousuarioInput
    connect?: usuarioWhereUniqueInput
  }

  export type usuarioCreateNestedOneWithoutArte_arte_iduaTousuarioInput = {
    create?: XOR<usuarioCreateWithoutArte_arte_iduaTousuarioInput, usuarioUncheckedCreateWithoutArte_arte_iduaTousuarioInput>
    connectOrCreate?: usuarioCreateOrConnectWithoutArte_arte_iduaTousuarioInput
    connect?: usuarioWhereUniqueInput
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ordentUpdateOneWithoutArte1NestedInput = {
    create?: XOR<ordentCreateWithoutArte1Input, ordentUncheckedCreateWithoutArte1Input>
    connectOrCreate?: ordentCreateOrConnectWithoutArte1Input
    upsert?: ordentUpsertWithoutArte1Input
    disconnect?: ordentWhereInput | boolean
    delete?: ordentWhereInput | boolean
    connect?: ordentWhereUniqueInput
    update?: XOR<XOR<ordentUpdateToOneWithWhereWithoutArte1Input, ordentUpdateWithoutArte1Input>, ordentUncheckedUpdateWithoutArte1Input>
  }

  export type usuarioUpdateOneWithoutArte_arte_iduTousuarioNestedInput = {
    create?: XOR<usuarioCreateWithoutArte_arte_iduTousuarioInput, usuarioUncheckedCreateWithoutArte_arte_iduTousuarioInput>
    connectOrCreate?: usuarioCreateOrConnectWithoutArte_arte_iduTousuarioInput
    upsert?: usuarioUpsertWithoutArte_arte_iduTousuarioInput
    disconnect?: usuarioWhereInput | boolean
    delete?: usuarioWhereInput | boolean
    connect?: usuarioWhereUniqueInput
    update?: XOR<XOR<usuarioUpdateToOneWithWhereWithoutArte_arte_iduTousuarioInput, usuarioUpdateWithoutArte_arte_iduTousuarioInput>, usuarioUncheckedUpdateWithoutArte_arte_iduTousuarioInput>
  }

  export type usuarioUpdateOneWithoutArte_arte_iduaTousuarioNestedInput = {
    create?: XOR<usuarioCreateWithoutArte_arte_iduaTousuarioInput, usuarioUncheckedCreateWithoutArte_arte_iduaTousuarioInput>
    connectOrCreate?: usuarioCreateOrConnectWithoutArte_arte_iduaTousuarioInput
    upsert?: usuarioUpsertWithoutArte_arte_iduaTousuarioInput
    disconnect?: usuarioWhereInput | boolean
    delete?: usuarioWhereInput | boolean
    connect?: usuarioWhereUniqueInput
    update?: XOR<XOR<usuarioUpdateToOneWithWhereWithoutArte_arte_iduaTousuarioInput, usuarioUpdateWithoutArte_arte_iduaTousuarioInput>, usuarioUncheckedUpdateWithoutArte_arte_iduaTousuarioInput>
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type personaCreateNestedOneWithoutClienteInput = {
    create?: XOR<personaCreateWithoutClienteInput, personaUncheckedCreateWithoutClienteInput>
    connectOrCreate?: personaCreateOrConnectWithoutClienteInput
    connect?: personaWhereUniqueInput
  }

  export type cotizacionCreateNestedManyWithoutClienteInput = {
    create?: XOR<cotizacionCreateWithoutClienteInput, cotizacionUncheckedCreateWithoutClienteInput> | cotizacionCreateWithoutClienteInput[] | cotizacionUncheckedCreateWithoutClienteInput[]
    connectOrCreate?: cotizacionCreateOrConnectWithoutClienteInput | cotizacionCreateOrConnectWithoutClienteInput[]
    createMany?: cotizacionCreateManyClienteInputEnvelope
    connect?: cotizacionWhereUniqueInput | cotizacionWhereUniqueInput[]
  }

  export type ordentCreateNestedManyWithoutClienteInput = {
    create?: XOR<ordentCreateWithoutClienteInput, ordentUncheckedCreateWithoutClienteInput> | ordentCreateWithoutClienteInput[] | ordentUncheckedCreateWithoutClienteInput[]
    connectOrCreate?: ordentCreateOrConnectWithoutClienteInput | ordentCreateOrConnectWithoutClienteInput[]
    createMany?: ordentCreateManyClienteInputEnvelope
    connect?: ordentWhereUniqueInput | ordentWhereUniqueInput[]
  }

  export type cotizacionUncheckedCreateNestedManyWithoutClienteInput = {
    create?: XOR<cotizacionCreateWithoutClienteInput, cotizacionUncheckedCreateWithoutClienteInput> | cotizacionCreateWithoutClienteInput[] | cotizacionUncheckedCreateWithoutClienteInput[]
    connectOrCreate?: cotizacionCreateOrConnectWithoutClienteInput | cotizacionCreateOrConnectWithoutClienteInput[]
    createMany?: cotizacionCreateManyClienteInputEnvelope
    connect?: cotizacionWhereUniqueInput | cotizacionWhereUniqueInput[]
  }

  export type ordentUncheckedCreateNestedManyWithoutClienteInput = {
    create?: XOR<ordentCreateWithoutClienteInput, ordentUncheckedCreateWithoutClienteInput> | ordentCreateWithoutClienteInput[] | ordentUncheckedCreateWithoutClienteInput[]
    connectOrCreate?: ordentCreateOrConnectWithoutClienteInput | ordentCreateOrConnectWithoutClienteInput[]
    createMany?: ordentCreateManyClienteInputEnvelope
    connect?: ordentWhereUniqueInput | ordentWhereUniqueInput[]
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type personaUpdateOneRequiredWithoutClienteNestedInput = {
    create?: XOR<personaCreateWithoutClienteInput, personaUncheckedCreateWithoutClienteInput>
    connectOrCreate?: personaCreateOrConnectWithoutClienteInput
    upsert?: personaUpsertWithoutClienteInput
    connect?: personaWhereUniqueInput
    update?: XOR<XOR<personaUpdateToOneWithWhereWithoutClienteInput, personaUpdateWithoutClienteInput>, personaUncheckedUpdateWithoutClienteInput>
  }

  export type cotizacionUpdateManyWithoutClienteNestedInput = {
    create?: XOR<cotizacionCreateWithoutClienteInput, cotizacionUncheckedCreateWithoutClienteInput> | cotizacionCreateWithoutClienteInput[] | cotizacionUncheckedCreateWithoutClienteInput[]
    connectOrCreate?: cotizacionCreateOrConnectWithoutClienteInput | cotizacionCreateOrConnectWithoutClienteInput[]
    upsert?: cotizacionUpsertWithWhereUniqueWithoutClienteInput | cotizacionUpsertWithWhereUniqueWithoutClienteInput[]
    createMany?: cotizacionCreateManyClienteInputEnvelope
    set?: cotizacionWhereUniqueInput | cotizacionWhereUniqueInput[]
    disconnect?: cotizacionWhereUniqueInput | cotizacionWhereUniqueInput[]
    delete?: cotizacionWhereUniqueInput | cotizacionWhereUniqueInput[]
    connect?: cotizacionWhereUniqueInput | cotizacionWhereUniqueInput[]
    update?: cotizacionUpdateWithWhereUniqueWithoutClienteInput | cotizacionUpdateWithWhereUniqueWithoutClienteInput[]
    updateMany?: cotizacionUpdateManyWithWhereWithoutClienteInput | cotizacionUpdateManyWithWhereWithoutClienteInput[]
    deleteMany?: cotizacionScalarWhereInput | cotizacionScalarWhereInput[]
  }

  export type ordentUpdateManyWithoutClienteNestedInput = {
    create?: XOR<ordentCreateWithoutClienteInput, ordentUncheckedCreateWithoutClienteInput> | ordentCreateWithoutClienteInput[] | ordentUncheckedCreateWithoutClienteInput[]
    connectOrCreate?: ordentCreateOrConnectWithoutClienteInput | ordentCreateOrConnectWithoutClienteInput[]
    upsert?: ordentUpsertWithWhereUniqueWithoutClienteInput | ordentUpsertWithWhereUniqueWithoutClienteInput[]
    createMany?: ordentCreateManyClienteInputEnvelope
    set?: ordentWhereUniqueInput | ordentWhereUniqueInput[]
    disconnect?: ordentWhereUniqueInput | ordentWhereUniqueInput[]
    delete?: ordentWhereUniqueInput | ordentWhereUniqueInput[]
    connect?: ordentWhereUniqueInput | ordentWhereUniqueInput[]
    update?: ordentUpdateWithWhereUniqueWithoutClienteInput | ordentUpdateWithWhereUniqueWithoutClienteInput[]
    updateMany?: ordentUpdateManyWithWhereWithoutClienteInput | ordentUpdateManyWithWhereWithoutClienteInput[]
    deleteMany?: ordentScalarWhereInput | ordentScalarWhereInput[]
  }

  export type cotizacionUncheckedUpdateManyWithoutClienteNestedInput = {
    create?: XOR<cotizacionCreateWithoutClienteInput, cotizacionUncheckedCreateWithoutClienteInput> | cotizacionCreateWithoutClienteInput[] | cotizacionUncheckedCreateWithoutClienteInput[]
    connectOrCreate?: cotizacionCreateOrConnectWithoutClienteInput | cotizacionCreateOrConnectWithoutClienteInput[]
    upsert?: cotizacionUpsertWithWhereUniqueWithoutClienteInput | cotizacionUpsertWithWhereUniqueWithoutClienteInput[]
    createMany?: cotizacionCreateManyClienteInputEnvelope
    set?: cotizacionWhereUniqueInput | cotizacionWhereUniqueInput[]
    disconnect?: cotizacionWhereUniqueInput | cotizacionWhereUniqueInput[]
    delete?: cotizacionWhereUniqueInput | cotizacionWhereUniqueInput[]
    connect?: cotizacionWhereUniqueInput | cotizacionWhereUniqueInput[]
    update?: cotizacionUpdateWithWhereUniqueWithoutClienteInput | cotizacionUpdateWithWhereUniqueWithoutClienteInput[]
    updateMany?: cotizacionUpdateManyWithWhereWithoutClienteInput | cotizacionUpdateManyWithWhereWithoutClienteInput[]
    deleteMany?: cotizacionScalarWhereInput | cotizacionScalarWhereInput[]
  }

  export type ordentUncheckedUpdateManyWithoutClienteNestedInput = {
    create?: XOR<ordentCreateWithoutClienteInput, ordentUncheckedCreateWithoutClienteInput> | ordentCreateWithoutClienteInput[] | ordentUncheckedCreateWithoutClienteInput[]
    connectOrCreate?: ordentCreateOrConnectWithoutClienteInput | ordentCreateOrConnectWithoutClienteInput[]
    upsert?: ordentUpsertWithWhereUniqueWithoutClienteInput | ordentUpsertWithWhereUniqueWithoutClienteInput[]
    createMany?: ordentCreateManyClienteInputEnvelope
    set?: ordentWhereUniqueInput | ordentWhereUniqueInput[]
    disconnect?: ordentWhereUniqueInput | ordentWhereUniqueInput[]
    delete?: ordentWhereUniqueInput | ordentWhereUniqueInput[]
    connect?: ordentWhereUniqueInput | ordentWhereUniqueInput[]
    update?: ordentUpdateWithWhereUniqueWithoutClienteInput | ordentUpdateWithWhereUniqueWithoutClienteInput[]
    updateMany?: ordentUpdateManyWithWhereWithoutClienteInput | ordentUpdateManyWithWhereWithoutClienteInput[]
    deleteMany?: ordentScalarWhereInput | ordentScalarWhereInput[]
  }

  export type marcaCreateNestedOneWithoutColorInput = {
    create?: XOR<marcaCreateWithoutColorInput, marcaUncheckedCreateWithoutColorInput>
    connectOrCreate?: marcaCreateOrConnectWithoutColorInput
    connect?: marcaWhereUniqueInput
  }

  export type marcaUpdateOneWithoutColorNestedInput = {
    create?: XOR<marcaCreateWithoutColorInput, marcaUncheckedCreateWithoutColorInput>
    connectOrCreate?: marcaCreateOrConnectWithoutColorInput
    upsert?: marcaUpsertWithoutColorInput
    disconnect?: marcaWhereInput | boolean
    delete?: marcaWhereInput | boolean
    connect?: marcaWhereUniqueInput
    update?: XOR<XOR<marcaUpdateToOneWithWhereWithoutColorInput, marcaUpdateWithoutColorInput>, marcaUncheckedUpdateWithoutColorInput>
  }

  export type clienteCreateNestedOneWithoutCotizacionInput = {
    create?: XOR<clienteCreateWithoutCotizacionInput, clienteUncheckedCreateWithoutCotizacionInput>
    connectOrCreate?: clienteCreateOrConnectWithoutCotizacionInput
    connect?: clienteWhereUniqueInput
  }

  export type usuarioCreateNestedOneWithoutCotizacionInput = {
    create?: XOR<usuarioCreateWithoutCotizacionInput, usuarioUncheckedCreateWithoutCotizacionInput>
    connectOrCreate?: usuarioCreateOrConnectWithoutCotizacionInput
    connect?: usuarioWhereUniqueInput
  }

  export type detcotCreateNestedManyWithoutCotizacionInput = {
    create?: XOR<detcotCreateWithoutCotizacionInput, detcotUncheckedCreateWithoutCotizacionInput> | detcotCreateWithoutCotizacionInput[] | detcotUncheckedCreateWithoutCotizacionInput[]
    connectOrCreate?: detcotCreateOrConnectWithoutCotizacionInput | detcotCreateOrConnectWithoutCotizacionInput[]
    createMany?: detcotCreateManyCotizacionInputEnvelope
    connect?: detcotWhereUniqueInput | detcotWhereUniqueInput[]
  }

  export type ordentCreateNestedManyWithoutCotizacionInput = {
    create?: XOR<ordentCreateWithoutCotizacionInput, ordentUncheckedCreateWithoutCotizacionInput> | ordentCreateWithoutCotizacionInput[] | ordentUncheckedCreateWithoutCotizacionInput[]
    connectOrCreate?: ordentCreateOrConnectWithoutCotizacionInput | ordentCreateOrConnectWithoutCotizacionInput[]
    createMany?: ordentCreateManyCotizacionInputEnvelope
    connect?: ordentWhereUniqueInput | ordentWhereUniqueInput[]
  }

  export type detcotUncheckedCreateNestedManyWithoutCotizacionInput = {
    create?: XOR<detcotCreateWithoutCotizacionInput, detcotUncheckedCreateWithoutCotizacionInput> | detcotCreateWithoutCotizacionInput[] | detcotUncheckedCreateWithoutCotizacionInput[]
    connectOrCreate?: detcotCreateOrConnectWithoutCotizacionInput | detcotCreateOrConnectWithoutCotizacionInput[]
    createMany?: detcotCreateManyCotizacionInputEnvelope
    connect?: detcotWhereUniqueInput | detcotWhereUniqueInput[]
  }

  export type ordentUncheckedCreateNestedManyWithoutCotizacionInput = {
    create?: XOR<ordentCreateWithoutCotizacionInput, ordentUncheckedCreateWithoutCotizacionInput> | ordentCreateWithoutCotizacionInput[] | ordentUncheckedCreateWithoutCotizacionInput[]
    connectOrCreate?: ordentCreateOrConnectWithoutCotizacionInput | ordentCreateOrConnectWithoutCotizacionInput[]
    createMany?: ordentCreateManyCotizacionInputEnvelope
    connect?: ordentWhereUniqueInput | ordentWhereUniqueInput[]
  }

  export type clienteUpdateOneWithoutCotizacionNestedInput = {
    create?: XOR<clienteCreateWithoutCotizacionInput, clienteUncheckedCreateWithoutCotizacionInput>
    connectOrCreate?: clienteCreateOrConnectWithoutCotizacionInput
    upsert?: clienteUpsertWithoutCotizacionInput
    disconnect?: clienteWhereInput | boolean
    delete?: clienteWhereInput | boolean
    connect?: clienteWhereUniqueInput
    update?: XOR<XOR<clienteUpdateToOneWithWhereWithoutCotizacionInput, clienteUpdateWithoutCotizacionInput>, clienteUncheckedUpdateWithoutCotizacionInput>
  }

  export type usuarioUpdateOneWithoutCotizacionNestedInput = {
    create?: XOR<usuarioCreateWithoutCotizacionInput, usuarioUncheckedCreateWithoutCotizacionInput>
    connectOrCreate?: usuarioCreateOrConnectWithoutCotizacionInput
    upsert?: usuarioUpsertWithoutCotizacionInput
    disconnect?: usuarioWhereInput | boolean
    delete?: usuarioWhereInput | boolean
    connect?: usuarioWhereUniqueInput
    update?: XOR<XOR<usuarioUpdateToOneWithWhereWithoutCotizacionInput, usuarioUpdateWithoutCotizacionInput>, usuarioUncheckedUpdateWithoutCotizacionInput>
  }

  export type detcotUpdateManyWithoutCotizacionNestedInput = {
    create?: XOR<detcotCreateWithoutCotizacionInput, detcotUncheckedCreateWithoutCotizacionInput> | detcotCreateWithoutCotizacionInput[] | detcotUncheckedCreateWithoutCotizacionInput[]
    connectOrCreate?: detcotCreateOrConnectWithoutCotizacionInput | detcotCreateOrConnectWithoutCotizacionInput[]
    upsert?: detcotUpsertWithWhereUniqueWithoutCotizacionInput | detcotUpsertWithWhereUniqueWithoutCotizacionInput[]
    createMany?: detcotCreateManyCotizacionInputEnvelope
    set?: detcotWhereUniqueInput | detcotWhereUniqueInput[]
    disconnect?: detcotWhereUniqueInput | detcotWhereUniqueInput[]
    delete?: detcotWhereUniqueInput | detcotWhereUniqueInput[]
    connect?: detcotWhereUniqueInput | detcotWhereUniqueInput[]
    update?: detcotUpdateWithWhereUniqueWithoutCotizacionInput | detcotUpdateWithWhereUniqueWithoutCotizacionInput[]
    updateMany?: detcotUpdateManyWithWhereWithoutCotizacionInput | detcotUpdateManyWithWhereWithoutCotizacionInput[]
    deleteMany?: detcotScalarWhereInput | detcotScalarWhereInput[]
  }

  export type ordentUpdateManyWithoutCotizacionNestedInput = {
    create?: XOR<ordentCreateWithoutCotizacionInput, ordentUncheckedCreateWithoutCotizacionInput> | ordentCreateWithoutCotizacionInput[] | ordentUncheckedCreateWithoutCotizacionInput[]
    connectOrCreate?: ordentCreateOrConnectWithoutCotizacionInput | ordentCreateOrConnectWithoutCotizacionInput[]
    upsert?: ordentUpsertWithWhereUniqueWithoutCotizacionInput | ordentUpsertWithWhereUniqueWithoutCotizacionInput[]
    createMany?: ordentCreateManyCotizacionInputEnvelope
    set?: ordentWhereUniqueInput | ordentWhereUniqueInput[]
    disconnect?: ordentWhereUniqueInput | ordentWhereUniqueInput[]
    delete?: ordentWhereUniqueInput | ordentWhereUniqueInput[]
    connect?: ordentWhereUniqueInput | ordentWhereUniqueInput[]
    update?: ordentUpdateWithWhereUniqueWithoutCotizacionInput | ordentUpdateWithWhereUniqueWithoutCotizacionInput[]
    updateMany?: ordentUpdateManyWithWhereWithoutCotizacionInput | ordentUpdateManyWithWhereWithoutCotizacionInput[]
    deleteMany?: ordentScalarWhereInput | ordentScalarWhereInput[]
  }

  export type detcotUncheckedUpdateManyWithoutCotizacionNestedInput = {
    create?: XOR<detcotCreateWithoutCotizacionInput, detcotUncheckedCreateWithoutCotizacionInput> | detcotCreateWithoutCotizacionInput[] | detcotUncheckedCreateWithoutCotizacionInput[]
    connectOrCreate?: detcotCreateOrConnectWithoutCotizacionInput | detcotCreateOrConnectWithoutCotizacionInput[]
    upsert?: detcotUpsertWithWhereUniqueWithoutCotizacionInput | detcotUpsertWithWhereUniqueWithoutCotizacionInput[]
    createMany?: detcotCreateManyCotizacionInputEnvelope
    set?: detcotWhereUniqueInput | detcotWhereUniqueInput[]
    disconnect?: detcotWhereUniqueInput | detcotWhereUniqueInput[]
    delete?: detcotWhereUniqueInput | detcotWhereUniqueInput[]
    connect?: detcotWhereUniqueInput | detcotWhereUniqueInput[]
    update?: detcotUpdateWithWhereUniqueWithoutCotizacionInput | detcotUpdateWithWhereUniqueWithoutCotizacionInput[]
    updateMany?: detcotUpdateManyWithWhereWithoutCotizacionInput | detcotUpdateManyWithWhereWithoutCotizacionInput[]
    deleteMany?: detcotScalarWhereInput | detcotScalarWhereInput[]
  }

  export type ordentUncheckedUpdateManyWithoutCotizacionNestedInput = {
    create?: XOR<ordentCreateWithoutCotizacionInput, ordentUncheckedCreateWithoutCotizacionInput> | ordentCreateWithoutCotizacionInput[] | ordentUncheckedCreateWithoutCotizacionInput[]
    connectOrCreate?: ordentCreateOrConnectWithoutCotizacionInput | ordentCreateOrConnectWithoutCotizacionInput[]
    upsert?: ordentUpsertWithWhereUniqueWithoutCotizacionInput | ordentUpsertWithWhereUniqueWithoutCotizacionInput[]
    createMany?: ordentCreateManyCotizacionInputEnvelope
    set?: ordentWhereUniqueInput | ordentWhereUniqueInput[]
    disconnect?: ordentWhereUniqueInput | ordentWhereUniqueInput[]
    delete?: ordentWhereUniqueInput | ordentWhereUniqueInput[]
    connect?: ordentWhereUniqueInput | ordentWhereUniqueInput[]
    update?: ordentUpdateWithWhereUniqueWithoutCotizacionInput | ordentUpdateWithWhereUniqueWithoutCotizacionInput[]
    updateMany?: ordentUpdateManyWithWhereWithoutCotizacionInput | ordentUpdateManyWithWhereWithoutCotizacionInput[]
    deleteMany?: ordentScalarWhereInput | ordentScalarWhereInput[]
  }

  export type usuarioCreateNestedOneWithoutDatosInput = {
    create?: XOR<usuarioCreateWithoutDatosInput, usuarioUncheckedCreateWithoutDatosInput>
    connectOrCreate?: usuarioCreateOrConnectWithoutDatosInput
    connect?: usuarioWhereUniqueInput
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type usuarioUpdateOneRequiredWithoutDatosNestedInput = {
    create?: XOR<usuarioCreateWithoutDatosInput, usuarioUncheckedCreateWithoutDatosInput>
    connectOrCreate?: usuarioCreateOrConnectWithoutDatosInput
    upsert?: usuarioUpsertWithoutDatosInput
    connect?: usuarioWhereUniqueInput
    update?: XOR<XOR<usuarioUpdateToOneWithWhereWithoutDatosInput, usuarioUpdateWithoutDatosInput>, usuarioUncheckedUpdateWithoutDatosInput>
  }

  export type cotizacionCreateNestedOneWithoutDetcotInput = {
    create?: XOR<cotizacionCreateWithoutDetcotInput, cotizacionUncheckedCreateWithoutDetcotInput>
    connectOrCreate?: cotizacionCreateOrConnectWithoutDetcotInput
    connect?: cotizacionWhereUniqueInput
  }

  export type productoCreateNestedOneWithoutDetcotInput = {
    create?: XOR<productoCreateWithoutDetcotInput, productoUncheckedCreateWithoutDetcotInput>
    connectOrCreate?: productoCreateOrConnectWithoutDetcotInput
    connect?: productoWhereUniqueInput
  }

  export type cotizacionUpdateOneWithoutDetcotNestedInput = {
    create?: XOR<cotizacionCreateWithoutDetcotInput, cotizacionUncheckedCreateWithoutDetcotInput>
    connectOrCreate?: cotizacionCreateOrConnectWithoutDetcotInput
    upsert?: cotizacionUpsertWithoutDetcotInput
    disconnect?: cotizacionWhereInput | boolean
    delete?: cotizacionWhereInput | boolean
    connect?: cotizacionWhereUniqueInput
    update?: XOR<XOR<cotizacionUpdateToOneWithWhereWithoutDetcotInput, cotizacionUpdateWithoutDetcotInput>, cotizacionUncheckedUpdateWithoutDetcotInput>
  }

  export type productoUpdateOneWithoutDetcotNestedInput = {
    create?: XOR<productoCreateWithoutDetcotInput, productoUncheckedCreateWithoutDetcotInput>
    connectOrCreate?: productoCreateOrConnectWithoutDetcotInput
    upsert?: productoUpsertWithoutDetcotInput
    disconnect?: productoWhereInput | boolean
    delete?: productoWhereInput | boolean
    connect?: productoWhereUniqueInput
    update?: XOR<XOR<productoUpdateToOneWithWhereWithoutDetcotInput, productoUpdateWithoutDetcotInput>, productoUncheckedUpdateWithoutDetcotInput>
  }

  export type ordentCreateNestedOneWithoutDetotInput = {
    create?: XOR<ordentCreateWithoutDetotInput, ordentUncheckedCreateWithoutDetotInput>
    connectOrCreate?: ordentCreateOrConnectWithoutDetotInput
    connect?: ordentWhereUniqueInput
  }

  export type productoCreateNestedOneWithoutDetotInput = {
    create?: XOR<productoCreateWithoutDetotInput, productoUncheckedCreateWithoutDetotInput>
    connectOrCreate?: productoCreateOrConnectWithoutDetotInput
    connect?: productoWhereUniqueInput
  }

  export type ordentUpdateOneWithoutDetotNestedInput = {
    create?: XOR<ordentCreateWithoutDetotInput, ordentUncheckedCreateWithoutDetotInput>
    connectOrCreate?: ordentCreateOrConnectWithoutDetotInput
    upsert?: ordentUpsertWithoutDetotInput
    disconnect?: ordentWhereInput | boolean
    delete?: ordentWhereInput | boolean
    connect?: ordentWhereUniqueInput
    update?: XOR<XOR<ordentUpdateToOneWithWhereWithoutDetotInput, ordentUpdateWithoutDetotInput>, ordentUncheckedUpdateWithoutDetotInput>
  }

  export type productoUpdateOneWithoutDetotNestedInput = {
    create?: XOR<productoCreateWithoutDetotInput, productoUncheckedCreateWithoutDetotInput>
    connectOrCreate?: productoCreateOrConnectWithoutDetotInput
    upsert?: productoUpsertWithoutDetotInput
    disconnect?: productoWhereInput | boolean
    delete?: productoWhereInput | boolean
    connect?: productoWhereUniqueInput
    update?: XOR<XOR<productoUpdateToOneWithWhereWithoutDetotInput, productoUpdateWithoutDetotInput>, productoUncheckedUpdateWithoutDetotInput>
  }

  export type personaCreateNestedOneWithoutEmpresaInput = {
    create?: XOR<personaCreateWithoutEmpresaInput, personaUncheckedCreateWithoutEmpresaInput>
    connectOrCreate?: personaCreateOrConnectWithoutEmpresaInput
    connect?: personaWhereUniqueInput
  }

  export type leyendaCreateNestedManyWithoutEmpresaInput = {
    create?: XOR<leyendaCreateWithoutEmpresaInput, leyendaUncheckedCreateWithoutEmpresaInput> | leyendaCreateWithoutEmpresaInput[] | leyendaUncheckedCreateWithoutEmpresaInput[]
    connectOrCreate?: leyendaCreateOrConnectWithoutEmpresaInput | leyendaCreateOrConnectWithoutEmpresaInput[]
    createMany?: leyendaCreateManyEmpresaInputEnvelope
    connect?: leyendaWhereUniqueInput | leyendaWhereUniqueInput[]
  }

  export type usuarioCreateNestedManyWithoutEmpresaInput = {
    create?: XOR<usuarioCreateWithoutEmpresaInput, usuarioUncheckedCreateWithoutEmpresaInput> | usuarioCreateWithoutEmpresaInput[] | usuarioUncheckedCreateWithoutEmpresaInput[]
    connectOrCreate?: usuarioCreateOrConnectWithoutEmpresaInput | usuarioCreateOrConnectWithoutEmpresaInput[]
    createMany?: usuarioCreateManyEmpresaInputEnvelope
    connect?: usuarioWhereUniqueInput | usuarioWhereUniqueInput[]
  }

  export type leyendaUncheckedCreateNestedManyWithoutEmpresaInput = {
    create?: XOR<leyendaCreateWithoutEmpresaInput, leyendaUncheckedCreateWithoutEmpresaInput> | leyendaCreateWithoutEmpresaInput[] | leyendaUncheckedCreateWithoutEmpresaInput[]
    connectOrCreate?: leyendaCreateOrConnectWithoutEmpresaInput | leyendaCreateOrConnectWithoutEmpresaInput[]
    createMany?: leyendaCreateManyEmpresaInputEnvelope
    connect?: leyendaWhereUniqueInput | leyendaWhereUniqueInput[]
  }

  export type usuarioUncheckedCreateNestedManyWithoutEmpresaInput = {
    create?: XOR<usuarioCreateWithoutEmpresaInput, usuarioUncheckedCreateWithoutEmpresaInput> | usuarioCreateWithoutEmpresaInput[] | usuarioUncheckedCreateWithoutEmpresaInput[]
    connectOrCreate?: usuarioCreateOrConnectWithoutEmpresaInput | usuarioCreateOrConnectWithoutEmpresaInput[]
    createMany?: usuarioCreateManyEmpresaInputEnvelope
    connect?: usuarioWhereUniqueInput | usuarioWhereUniqueInput[]
  }

  export type NullableBytesFieldUpdateOperationsInput = {
    set?: Buffer | null
  }

  export type personaUpdateOneWithoutEmpresaNestedInput = {
    create?: XOR<personaCreateWithoutEmpresaInput, personaUncheckedCreateWithoutEmpresaInput>
    connectOrCreate?: personaCreateOrConnectWithoutEmpresaInput
    upsert?: personaUpsertWithoutEmpresaInput
    disconnect?: personaWhereInput | boolean
    delete?: personaWhereInput | boolean
    connect?: personaWhereUniqueInput
    update?: XOR<XOR<personaUpdateToOneWithWhereWithoutEmpresaInput, personaUpdateWithoutEmpresaInput>, personaUncheckedUpdateWithoutEmpresaInput>
  }

  export type leyendaUpdateManyWithoutEmpresaNestedInput = {
    create?: XOR<leyendaCreateWithoutEmpresaInput, leyendaUncheckedCreateWithoutEmpresaInput> | leyendaCreateWithoutEmpresaInput[] | leyendaUncheckedCreateWithoutEmpresaInput[]
    connectOrCreate?: leyendaCreateOrConnectWithoutEmpresaInput | leyendaCreateOrConnectWithoutEmpresaInput[]
    upsert?: leyendaUpsertWithWhereUniqueWithoutEmpresaInput | leyendaUpsertWithWhereUniqueWithoutEmpresaInput[]
    createMany?: leyendaCreateManyEmpresaInputEnvelope
    set?: leyendaWhereUniqueInput | leyendaWhereUniqueInput[]
    disconnect?: leyendaWhereUniqueInput | leyendaWhereUniqueInput[]
    delete?: leyendaWhereUniqueInput | leyendaWhereUniqueInput[]
    connect?: leyendaWhereUniqueInput | leyendaWhereUniqueInput[]
    update?: leyendaUpdateWithWhereUniqueWithoutEmpresaInput | leyendaUpdateWithWhereUniqueWithoutEmpresaInput[]
    updateMany?: leyendaUpdateManyWithWhereWithoutEmpresaInput | leyendaUpdateManyWithWhereWithoutEmpresaInput[]
    deleteMany?: leyendaScalarWhereInput | leyendaScalarWhereInput[]
  }

  export type usuarioUpdateManyWithoutEmpresaNestedInput = {
    create?: XOR<usuarioCreateWithoutEmpresaInput, usuarioUncheckedCreateWithoutEmpresaInput> | usuarioCreateWithoutEmpresaInput[] | usuarioUncheckedCreateWithoutEmpresaInput[]
    connectOrCreate?: usuarioCreateOrConnectWithoutEmpresaInput | usuarioCreateOrConnectWithoutEmpresaInput[]
    upsert?: usuarioUpsertWithWhereUniqueWithoutEmpresaInput | usuarioUpsertWithWhereUniqueWithoutEmpresaInput[]
    createMany?: usuarioCreateManyEmpresaInputEnvelope
    set?: usuarioWhereUniqueInput | usuarioWhereUniqueInput[]
    disconnect?: usuarioWhereUniqueInput | usuarioWhereUniqueInput[]
    delete?: usuarioWhereUniqueInput | usuarioWhereUniqueInput[]
    connect?: usuarioWhereUniqueInput | usuarioWhereUniqueInput[]
    update?: usuarioUpdateWithWhereUniqueWithoutEmpresaInput | usuarioUpdateWithWhereUniqueWithoutEmpresaInput[]
    updateMany?: usuarioUpdateManyWithWhereWithoutEmpresaInput | usuarioUpdateManyWithWhereWithoutEmpresaInput[]
    deleteMany?: usuarioScalarWhereInput | usuarioScalarWhereInput[]
  }

  export type leyendaUncheckedUpdateManyWithoutEmpresaNestedInput = {
    create?: XOR<leyendaCreateWithoutEmpresaInput, leyendaUncheckedCreateWithoutEmpresaInput> | leyendaCreateWithoutEmpresaInput[] | leyendaUncheckedCreateWithoutEmpresaInput[]
    connectOrCreate?: leyendaCreateOrConnectWithoutEmpresaInput | leyendaCreateOrConnectWithoutEmpresaInput[]
    upsert?: leyendaUpsertWithWhereUniqueWithoutEmpresaInput | leyendaUpsertWithWhereUniqueWithoutEmpresaInput[]
    createMany?: leyendaCreateManyEmpresaInputEnvelope
    set?: leyendaWhereUniqueInput | leyendaWhereUniqueInput[]
    disconnect?: leyendaWhereUniqueInput | leyendaWhereUniqueInput[]
    delete?: leyendaWhereUniqueInput | leyendaWhereUniqueInput[]
    connect?: leyendaWhereUniqueInput | leyendaWhereUniqueInput[]
    update?: leyendaUpdateWithWhereUniqueWithoutEmpresaInput | leyendaUpdateWithWhereUniqueWithoutEmpresaInput[]
    updateMany?: leyendaUpdateManyWithWhereWithoutEmpresaInput | leyendaUpdateManyWithWhereWithoutEmpresaInput[]
    deleteMany?: leyendaScalarWhereInput | leyendaScalarWhereInput[]
  }

  export type usuarioUncheckedUpdateManyWithoutEmpresaNestedInput = {
    create?: XOR<usuarioCreateWithoutEmpresaInput, usuarioUncheckedCreateWithoutEmpresaInput> | usuarioCreateWithoutEmpresaInput[] | usuarioUncheckedCreateWithoutEmpresaInput[]
    connectOrCreate?: usuarioCreateOrConnectWithoutEmpresaInput | usuarioCreateOrConnectWithoutEmpresaInput[]
    upsert?: usuarioUpsertWithWhereUniqueWithoutEmpresaInput | usuarioUpsertWithWhereUniqueWithoutEmpresaInput[]
    createMany?: usuarioCreateManyEmpresaInputEnvelope
    set?: usuarioWhereUniqueInput | usuarioWhereUniqueInput[]
    disconnect?: usuarioWhereUniqueInput | usuarioWhereUniqueInput[]
    delete?: usuarioWhereUniqueInput | usuarioWhereUniqueInput[]
    connect?: usuarioWhereUniqueInput | usuarioWhereUniqueInput[]
    update?: usuarioUpdateWithWhereUniqueWithoutEmpresaInput | usuarioUpdateWithWhereUniqueWithoutEmpresaInput[]
    updateMany?: usuarioUpdateManyWithWhereWithoutEmpresaInput | usuarioUpdateManyWithWhereWithoutEmpresaInput[]
    deleteMany?: usuarioScalarWhereInput | usuarioScalarWhereInput[]
  }

  export type ordentCreateNestedOneWithoutFactura1Input = {
    create?: XOR<ordentCreateWithoutFactura1Input, ordentUncheckedCreateWithoutFactura1Input>
    connectOrCreate?: ordentCreateOrConnectWithoutFactura1Input
    connect?: ordentWhereUniqueInput
  }

  export type usuarioCreateNestedOneWithoutFacturaInput = {
    create?: XOR<usuarioCreateWithoutFacturaInput, usuarioUncheckedCreateWithoutFacturaInput>
    connectOrCreate?: usuarioCreateOrConnectWithoutFacturaInput
    connect?: usuarioWhereUniqueInput
  }

  export type ordentUpdateOneWithoutFactura1NestedInput = {
    create?: XOR<ordentCreateWithoutFactura1Input, ordentUncheckedCreateWithoutFactura1Input>
    connectOrCreate?: ordentCreateOrConnectWithoutFactura1Input
    upsert?: ordentUpsertWithoutFactura1Input
    disconnect?: ordentWhereInput | boolean
    delete?: ordentWhereInput | boolean
    connect?: ordentWhereUniqueInput
    update?: XOR<XOR<ordentUpdateToOneWithWhereWithoutFactura1Input, ordentUpdateWithoutFactura1Input>, ordentUncheckedUpdateWithoutFactura1Input>
  }

  export type usuarioUpdateOneWithoutFacturaNestedInput = {
    create?: XOR<usuarioCreateWithoutFacturaInput, usuarioUncheckedCreateWithoutFacturaInput>
    connectOrCreate?: usuarioCreateOrConnectWithoutFacturaInput
    upsert?: usuarioUpsertWithoutFacturaInput
    disconnect?: usuarioWhereInput | boolean
    delete?: usuarioWhereInput | boolean
    connect?: usuarioWhereUniqueInput
    update?: XOR<XOR<usuarioUpdateToOneWithWhereWithoutFacturaInput, usuarioUpdateWithoutFacturaInput>, usuarioUncheckedUpdateWithoutFacturaInput>
  }

  export type proveedorCreateNestedOneWithoutInventarioInput = {
    create?: XOR<proveedorCreateWithoutInventarioInput, proveedorUncheckedCreateWithoutInventarioInput>
    connectOrCreate?: proveedorCreateOrConnectWithoutInventarioInput
    connect?: proveedorWhereUniqueInput
  }

  export type proveedorUpdateOneWithoutInventarioNestedInput = {
    create?: XOR<proveedorCreateWithoutInventarioInput, proveedorUncheckedCreateWithoutInventarioInput>
    connectOrCreate?: proveedorCreateOrConnectWithoutInventarioInput
    upsert?: proveedorUpsertWithoutInventarioInput
    disconnect?: proveedorWhereInput | boolean
    delete?: proveedorWhereInput | boolean
    connect?: proveedorWhereUniqueInput
    update?: XOR<XOR<proveedorUpdateToOneWithWhereWithoutInventarioInput, proveedorUpdateWithoutInventarioInput>, proveedorUncheckedUpdateWithoutInventarioInput>
  }

  export type empresaCreateNestedOneWithoutLeyendaInput = {
    create?: XOR<empresaCreateWithoutLeyendaInput, empresaUncheckedCreateWithoutLeyendaInput>
    connectOrCreate?: empresaCreateOrConnectWithoutLeyendaInput
    connect?: empresaWhereUniqueInput
  }

  export type empresaUpdateOneWithoutLeyendaNestedInput = {
    create?: XOR<empresaCreateWithoutLeyendaInput, empresaUncheckedCreateWithoutLeyendaInput>
    connectOrCreate?: empresaCreateOrConnectWithoutLeyendaInput
    upsert?: empresaUpsertWithoutLeyendaInput
    disconnect?: empresaWhereInput | boolean
    delete?: empresaWhereInput | boolean
    connect?: empresaWhereUniqueInput
    update?: XOR<XOR<empresaUpdateToOneWithWhereWithoutLeyendaInput, empresaUpdateWithoutLeyendaInput>, empresaUncheckedUpdateWithoutLeyendaInput>
  }

  export type colorCreateNestedManyWithoutMarcaInput = {
    create?: XOR<colorCreateWithoutMarcaInput, colorUncheckedCreateWithoutMarcaInput> | colorCreateWithoutMarcaInput[] | colorUncheckedCreateWithoutMarcaInput[]
    connectOrCreate?: colorCreateOrConnectWithoutMarcaInput | colorCreateOrConnectWithoutMarcaInput[]
    createMany?: colorCreateManyMarcaInputEnvelope
    connect?: colorWhereUniqueInput | colorWhereUniqueInput[]
  }

  export type productoCreateNestedManyWithoutMarcaInput = {
    create?: XOR<productoCreateWithoutMarcaInput, productoUncheckedCreateWithoutMarcaInput> | productoCreateWithoutMarcaInput[] | productoUncheckedCreateWithoutMarcaInput[]
    connectOrCreate?: productoCreateOrConnectWithoutMarcaInput | productoCreateOrConnectWithoutMarcaInput[]
    createMany?: productoCreateManyMarcaInputEnvelope
    connect?: productoWhereUniqueInput | productoWhereUniqueInput[]
  }

  export type terminadoCreateNestedManyWithoutMarcaInput = {
    create?: XOR<terminadoCreateWithoutMarcaInput, terminadoUncheckedCreateWithoutMarcaInput> | terminadoCreateWithoutMarcaInput[] | terminadoUncheckedCreateWithoutMarcaInput[]
    connectOrCreate?: terminadoCreateOrConnectWithoutMarcaInput | terminadoCreateOrConnectWithoutMarcaInput[]
    createMany?: terminadoCreateManyMarcaInputEnvelope
    connect?: terminadoWhereUniqueInput | terminadoWhereUniqueInput[]
  }

  export type colorUncheckedCreateNestedManyWithoutMarcaInput = {
    create?: XOR<colorCreateWithoutMarcaInput, colorUncheckedCreateWithoutMarcaInput> | colorCreateWithoutMarcaInput[] | colorUncheckedCreateWithoutMarcaInput[]
    connectOrCreate?: colorCreateOrConnectWithoutMarcaInput | colorCreateOrConnectWithoutMarcaInput[]
    createMany?: colorCreateManyMarcaInputEnvelope
    connect?: colorWhereUniqueInput | colorWhereUniqueInput[]
  }

  export type productoUncheckedCreateNestedManyWithoutMarcaInput = {
    create?: XOR<productoCreateWithoutMarcaInput, productoUncheckedCreateWithoutMarcaInput> | productoCreateWithoutMarcaInput[] | productoUncheckedCreateWithoutMarcaInput[]
    connectOrCreate?: productoCreateOrConnectWithoutMarcaInput | productoCreateOrConnectWithoutMarcaInput[]
    createMany?: productoCreateManyMarcaInputEnvelope
    connect?: productoWhereUniqueInput | productoWhereUniqueInput[]
  }

  export type terminadoUncheckedCreateNestedManyWithoutMarcaInput = {
    create?: XOR<terminadoCreateWithoutMarcaInput, terminadoUncheckedCreateWithoutMarcaInput> | terminadoCreateWithoutMarcaInput[] | terminadoUncheckedCreateWithoutMarcaInput[]
    connectOrCreate?: terminadoCreateOrConnectWithoutMarcaInput | terminadoCreateOrConnectWithoutMarcaInput[]
    createMany?: terminadoCreateManyMarcaInputEnvelope
    connect?: terminadoWhereUniqueInput | terminadoWhereUniqueInput[]
  }

  export type colorUpdateManyWithoutMarcaNestedInput = {
    create?: XOR<colorCreateWithoutMarcaInput, colorUncheckedCreateWithoutMarcaInput> | colorCreateWithoutMarcaInput[] | colorUncheckedCreateWithoutMarcaInput[]
    connectOrCreate?: colorCreateOrConnectWithoutMarcaInput | colorCreateOrConnectWithoutMarcaInput[]
    upsert?: colorUpsertWithWhereUniqueWithoutMarcaInput | colorUpsertWithWhereUniqueWithoutMarcaInput[]
    createMany?: colorCreateManyMarcaInputEnvelope
    set?: colorWhereUniqueInput | colorWhereUniqueInput[]
    disconnect?: colorWhereUniqueInput | colorWhereUniqueInput[]
    delete?: colorWhereUniqueInput | colorWhereUniqueInput[]
    connect?: colorWhereUniqueInput | colorWhereUniqueInput[]
    update?: colorUpdateWithWhereUniqueWithoutMarcaInput | colorUpdateWithWhereUniqueWithoutMarcaInput[]
    updateMany?: colorUpdateManyWithWhereWithoutMarcaInput | colorUpdateManyWithWhereWithoutMarcaInput[]
    deleteMany?: colorScalarWhereInput | colorScalarWhereInput[]
  }

  export type productoUpdateManyWithoutMarcaNestedInput = {
    create?: XOR<productoCreateWithoutMarcaInput, productoUncheckedCreateWithoutMarcaInput> | productoCreateWithoutMarcaInput[] | productoUncheckedCreateWithoutMarcaInput[]
    connectOrCreate?: productoCreateOrConnectWithoutMarcaInput | productoCreateOrConnectWithoutMarcaInput[]
    upsert?: productoUpsertWithWhereUniqueWithoutMarcaInput | productoUpsertWithWhereUniqueWithoutMarcaInput[]
    createMany?: productoCreateManyMarcaInputEnvelope
    set?: productoWhereUniqueInput | productoWhereUniqueInput[]
    disconnect?: productoWhereUniqueInput | productoWhereUniqueInput[]
    delete?: productoWhereUniqueInput | productoWhereUniqueInput[]
    connect?: productoWhereUniqueInput | productoWhereUniqueInput[]
    update?: productoUpdateWithWhereUniqueWithoutMarcaInput | productoUpdateWithWhereUniqueWithoutMarcaInput[]
    updateMany?: productoUpdateManyWithWhereWithoutMarcaInput | productoUpdateManyWithWhereWithoutMarcaInput[]
    deleteMany?: productoScalarWhereInput | productoScalarWhereInput[]
  }

  export type terminadoUpdateManyWithoutMarcaNestedInput = {
    create?: XOR<terminadoCreateWithoutMarcaInput, terminadoUncheckedCreateWithoutMarcaInput> | terminadoCreateWithoutMarcaInput[] | terminadoUncheckedCreateWithoutMarcaInput[]
    connectOrCreate?: terminadoCreateOrConnectWithoutMarcaInput | terminadoCreateOrConnectWithoutMarcaInput[]
    upsert?: terminadoUpsertWithWhereUniqueWithoutMarcaInput | terminadoUpsertWithWhereUniqueWithoutMarcaInput[]
    createMany?: terminadoCreateManyMarcaInputEnvelope
    set?: terminadoWhereUniqueInput | terminadoWhereUniqueInput[]
    disconnect?: terminadoWhereUniqueInput | terminadoWhereUniqueInput[]
    delete?: terminadoWhereUniqueInput | terminadoWhereUniqueInput[]
    connect?: terminadoWhereUniqueInput | terminadoWhereUniqueInput[]
    update?: terminadoUpdateWithWhereUniqueWithoutMarcaInput | terminadoUpdateWithWhereUniqueWithoutMarcaInput[]
    updateMany?: terminadoUpdateManyWithWhereWithoutMarcaInput | terminadoUpdateManyWithWhereWithoutMarcaInput[]
    deleteMany?: terminadoScalarWhereInput | terminadoScalarWhereInput[]
  }

  export type colorUncheckedUpdateManyWithoutMarcaNestedInput = {
    create?: XOR<colorCreateWithoutMarcaInput, colorUncheckedCreateWithoutMarcaInput> | colorCreateWithoutMarcaInput[] | colorUncheckedCreateWithoutMarcaInput[]
    connectOrCreate?: colorCreateOrConnectWithoutMarcaInput | colorCreateOrConnectWithoutMarcaInput[]
    upsert?: colorUpsertWithWhereUniqueWithoutMarcaInput | colorUpsertWithWhereUniqueWithoutMarcaInput[]
    createMany?: colorCreateManyMarcaInputEnvelope
    set?: colorWhereUniqueInput | colorWhereUniqueInput[]
    disconnect?: colorWhereUniqueInput | colorWhereUniqueInput[]
    delete?: colorWhereUniqueInput | colorWhereUniqueInput[]
    connect?: colorWhereUniqueInput | colorWhereUniqueInput[]
    update?: colorUpdateWithWhereUniqueWithoutMarcaInput | colorUpdateWithWhereUniqueWithoutMarcaInput[]
    updateMany?: colorUpdateManyWithWhereWithoutMarcaInput | colorUpdateManyWithWhereWithoutMarcaInput[]
    deleteMany?: colorScalarWhereInput | colorScalarWhereInput[]
  }

  export type productoUncheckedUpdateManyWithoutMarcaNestedInput = {
    create?: XOR<productoCreateWithoutMarcaInput, productoUncheckedCreateWithoutMarcaInput> | productoCreateWithoutMarcaInput[] | productoUncheckedCreateWithoutMarcaInput[]
    connectOrCreate?: productoCreateOrConnectWithoutMarcaInput | productoCreateOrConnectWithoutMarcaInput[]
    upsert?: productoUpsertWithWhereUniqueWithoutMarcaInput | productoUpsertWithWhereUniqueWithoutMarcaInput[]
    createMany?: productoCreateManyMarcaInputEnvelope
    set?: productoWhereUniqueInput | productoWhereUniqueInput[]
    disconnect?: productoWhereUniqueInput | productoWhereUniqueInput[]
    delete?: productoWhereUniqueInput | productoWhereUniqueInput[]
    connect?: productoWhereUniqueInput | productoWhereUniqueInput[]
    update?: productoUpdateWithWhereUniqueWithoutMarcaInput | productoUpdateWithWhereUniqueWithoutMarcaInput[]
    updateMany?: productoUpdateManyWithWhereWithoutMarcaInput | productoUpdateManyWithWhereWithoutMarcaInput[]
    deleteMany?: productoScalarWhereInput | productoScalarWhereInput[]
  }

  export type terminadoUncheckedUpdateManyWithoutMarcaNestedInput = {
    create?: XOR<terminadoCreateWithoutMarcaInput, terminadoUncheckedCreateWithoutMarcaInput> | terminadoCreateWithoutMarcaInput[] | terminadoUncheckedCreateWithoutMarcaInput[]
    connectOrCreate?: terminadoCreateOrConnectWithoutMarcaInput | terminadoCreateOrConnectWithoutMarcaInput[]
    upsert?: terminadoUpsertWithWhereUniqueWithoutMarcaInput | terminadoUpsertWithWhereUniqueWithoutMarcaInput[]
    createMany?: terminadoCreateManyMarcaInputEnvelope
    set?: terminadoWhereUniqueInput | terminadoWhereUniqueInput[]
    disconnect?: terminadoWhereUniqueInput | terminadoWhereUniqueInput[]
    delete?: terminadoWhereUniqueInput | terminadoWhereUniqueInput[]
    connect?: terminadoWhereUniqueInput | terminadoWhereUniqueInput[]
    update?: terminadoUpdateWithWhereUniqueWithoutMarcaInput | terminadoUpdateWithWhereUniqueWithoutMarcaInput[]
    updateMany?: terminadoUpdateManyWithWhereWithoutMarcaInput | terminadoUpdateManyWithWhereWithoutMarcaInput[]
    deleteMany?: terminadoScalarWhereInput | terminadoScalarWhereInput[]
  }

  export type rolmenuCreateNestedManyWithoutMenuInput = {
    create?: XOR<rolmenuCreateWithoutMenuInput, rolmenuUncheckedCreateWithoutMenuInput> | rolmenuCreateWithoutMenuInput[] | rolmenuUncheckedCreateWithoutMenuInput[]
    connectOrCreate?: rolmenuCreateOrConnectWithoutMenuInput | rolmenuCreateOrConnectWithoutMenuInput[]
    createMany?: rolmenuCreateManyMenuInputEnvelope
    connect?: rolmenuWhereUniqueInput | rolmenuWhereUniqueInput[]
  }

  export type rolmenuUncheckedCreateNestedManyWithoutMenuInput = {
    create?: XOR<rolmenuCreateWithoutMenuInput, rolmenuUncheckedCreateWithoutMenuInput> | rolmenuCreateWithoutMenuInput[] | rolmenuUncheckedCreateWithoutMenuInput[]
    connectOrCreate?: rolmenuCreateOrConnectWithoutMenuInput | rolmenuCreateOrConnectWithoutMenuInput[]
    createMany?: rolmenuCreateManyMenuInputEnvelope
    connect?: rolmenuWhereUniqueInput | rolmenuWhereUniqueInput[]
  }

  export type rolmenuUpdateManyWithoutMenuNestedInput = {
    create?: XOR<rolmenuCreateWithoutMenuInput, rolmenuUncheckedCreateWithoutMenuInput> | rolmenuCreateWithoutMenuInput[] | rolmenuUncheckedCreateWithoutMenuInput[]
    connectOrCreate?: rolmenuCreateOrConnectWithoutMenuInput | rolmenuCreateOrConnectWithoutMenuInput[]
    upsert?: rolmenuUpsertWithWhereUniqueWithoutMenuInput | rolmenuUpsertWithWhereUniqueWithoutMenuInput[]
    createMany?: rolmenuCreateManyMenuInputEnvelope
    set?: rolmenuWhereUniqueInput | rolmenuWhereUniqueInput[]
    disconnect?: rolmenuWhereUniqueInput | rolmenuWhereUniqueInput[]
    delete?: rolmenuWhereUniqueInput | rolmenuWhereUniqueInput[]
    connect?: rolmenuWhereUniqueInput | rolmenuWhereUniqueInput[]
    update?: rolmenuUpdateWithWhereUniqueWithoutMenuInput | rolmenuUpdateWithWhereUniqueWithoutMenuInput[]
    updateMany?: rolmenuUpdateManyWithWhereWithoutMenuInput | rolmenuUpdateManyWithWhereWithoutMenuInput[]
    deleteMany?: rolmenuScalarWhereInput | rolmenuScalarWhereInput[]
  }

  export type rolmenuUncheckedUpdateManyWithoutMenuNestedInput = {
    create?: XOR<rolmenuCreateWithoutMenuInput, rolmenuUncheckedCreateWithoutMenuInput> | rolmenuCreateWithoutMenuInput[] | rolmenuUncheckedCreateWithoutMenuInput[]
    connectOrCreate?: rolmenuCreateOrConnectWithoutMenuInput | rolmenuCreateOrConnectWithoutMenuInput[]
    upsert?: rolmenuUpsertWithWhereUniqueWithoutMenuInput | rolmenuUpsertWithWhereUniqueWithoutMenuInput[]
    createMany?: rolmenuCreateManyMenuInputEnvelope
    set?: rolmenuWhereUniqueInput | rolmenuWhereUniqueInput[]
    disconnect?: rolmenuWhereUniqueInput | rolmenuWhereUniqueInput[]
    delete?: rolmenuWhereUniqueInput | rolmenuWhereUniqueInput[]
    connect?: rolmenuWhereUniqueInput | rolmenuWhereUniqueInput[]
    update?: rolmenuUpdateWithWhereUniqueWithoutMenuInput | rolmenuUpdateWithWhereUniqueWithoutMenuInput[]
    updateMany?: rolmenuUpdateManyWithWhereWithoutMenuInput | rolmenuUpdateManyWithWhereWithoutMenuInput[]
    deleteMany?: rolmenuScalarWhereInput | rolmenuScalarWhereInput[]
  }

  export type arteCreateNestedManyWithoutOrdentInput = {
    create?: XOR<arteCreateWithoutOrdentInput, arteUncheckedCreateWithoutOrdentInput> | arteCreateWithoutOrdentInput[] | arteUncheckedCreateWithoutOrdentInput[]
    connectOrCreate?: arteCreateOrConnectWithoutOrdentInput | arteCreateOrConnectWithoutOrdentInput[]
    createMany?: arteCreateManyOrdentInputEnvelope
    connect?: arteWhereUniqueInput | arteWhereUniqueInput[]
  }

  export type detotCreateNestedManyWithoutOrdentInput = {
    create?: XOR<detotCreateWithoutOrdentInput, detotUncheckedCreateWithoutOrdentInput> | detotCreateWithoutOrdentInput[] | detotUncheckedCreateWithoutOrdentInput[]
    connectOrCreate?: detotCreateOrConnectWithoutOrdentInput | detotCreateOrConnectWithoutOrdentInput[]
    createMany?: detotCreateManyOrdentInputEnvelope
    connect?: detotWhereUniqueInput | detotWhereUniqueInput[]
  }

  export type facturaCreateNestedManyWithoutOrdentInput = {
    create?: XOR<facturaCreateWithoutOrdentInput, facturaUncheckedCreateWithoutOrdentInput> | facturaCreateWithoutOrdentInput[] | facturaUncheckedCreateWithoutOrdentInput[]
    connectOrCreate?: facturaCreateOrConnectWithoutOrdentInput | facturaCreateOrConnectWithoutOrdentInput[]
    createMany?: facturaCreateManyOrdentInputEnvelope
    connect?: facturaWhereUniqueInput | facturaWhereUniqueInput[]
  }

  export type clienteCreateNestedOneWithoutOrdentInput = {
    create?: XOR<clienteCreateWithoutOrdentInput, clienteUncheckedCreateWithoutOrdentInput>
    connectOrCreate?: clienteCreateOrConnectWithoutOrdentInput
    connect?: clienteWhereUniqueInput
  }

  export type cotizacionCreateNestedOneWithoutOrdentInput = {
    create?: XOR<cotizacionCreateWithoutOrdentInput, cotizacionUncheckedCreateWithoutOrdentInput>
    connectOrCreate?: cotizacionCreateOrConnectWithoutOrdentInput
    connect?: cotizacionWhereUniqueInput
  }

  export type usuarioCreateNestedOneWithoutOrdentInput = {
    create?: XOR<usuarioCreateWithoutOrdentInput, usuarioUncheckedCreateWithoutOrdentInput>
    connectOrCreate?: usuarioCreateOrConnectWithoutOrdentInput
    connect?: usuarioWhereUniqueInput
  }

  export type pagoCreateNestedManyWithoutOrdentInput = {
    create?: XOR<pagoCreateWithoutOrdentInput, pagoUncheckedCreateWithoutOrdentInput> | pagoCreateWithoutOrdentInput[] | pagoUncheckedCreateWithoutOrdentInput[]
    connectOrCreate?: pagoCreateOrConnectWithoutOrdentInput | pagoCreateOrConnectWithoutOrdentInput[]
    createMany?: pagoCreateManyOrdentInputEnvelope
    connect?: pagoWhereUniqueInput | pagoWhereUniqueInput[]
  }

  export type arteUncheckedCreateNestedManyWithoutOrdentInput = {
    create?: XOR<arteCreateWithoutOrdentInput, arteUncheckedCreateWithoutOrdentInput> | arteCreateWithoutOrdentInput[] | arteUncheckedCreateWithoutOrdentInput[]
    connectOrCreate?: arteCreateOrConnectWithoutOrdentInput | arteCreateOrConnectWithoutOrdentInput[]
    createMany?: arteCreateManyOrdentInputEnvelope
    connect?: arteWhereUniqueInput | arteWhereUniqueInput[]
  }

  export type detotUncheckedCreateNestedManyWithoutOrdentInput = {
    create?: XOR<detotCreateWithoutOrdentInput, detotUncheckedCreateWithoutOrdentInput> | detotCreateWithoutOrdentInput[] | detotUncheckedCreateWithoutOrdentInput[]
    connectOrCreate?: detotCreateOrConnectWithoutOrdentInput | detotCreateOrConnectWithoutOrdentInput[]
    createMany?: detotCreateManyOrdentInputEnvelope
    connect?: detotWhereUniqueInput | detotWhereUniqueInput[]
  }

  export type facturaUncheckedCreateNestedManyWithoutOrdentInput = {
    create?: XOR<facturaCreateWithoutOrdentInput, facturaUncheckedCreateWithoutOrdentInput> | facturaCreateWithoutOrdentInput[] | facturaUncheckedCreateWithoutOrdentInput[]
    connectOrCreate?: facturaCreateOrConnectWithoutOrdentInput | facturaCreateOrConnectWithoutOrdentInput[]
    createMany?: facturaCreateManyOrdentInputEnvelope
    connect?: facturaWhereUniqueInput | facturaWhereUniqueInput[]
  }

  export type pagoUncheckedCreateNestedManyWithoutOrdentInput = {
    create?: XOR<pagoCreateWithoutOrdentInput, pagoUncheckedCreateWithoutOrdentInput> | pagoCreateWithoutOrdentInput[] | pagoUncheckedCreateWithoutOrdentInput[]
    connectOrCreate?: pagoCreateOrConnectWithoutOrdentInput | pagoCreateOrConnectWithoutOrdentInput[]
    createMany?: pagoCreateManyOrdentInputEnvelope
    connect?: pagoWhereUniqueInput | pagoWhereUniqueInput[]
  }

  export type arteUpdateManyWithoutOrdentNestedInput = {
    create?: XOR<arteCreateWithoutOrdentInput, arteUncheckedCreateWithoutOrdentInput> | arteCreateWithoutOrdentInput[] | arteUncheckedCreateWithoutOrdentInput[]
    connectOrCreate?: arteCreateOrConnectWithoutOrdentInput | arteCreateOrConnectWithoutOrdentInput[]
    upsert?: arteUpsertWithWhereUniqueWithoutOrdentInput | arteUpsertWithWhereUniqueWithoutOrdentInput[]
    createMany?: arteCreateManyOrdentInputEnvelope
    set?: arteWhereUniqueInput | arteWhereUniqueInput[]
    disconnect?: arteWhereUniqueInput | arteWhereUniqueInput[]
    delete?: arteWhereUniqueInput | arteWhereUniqueInput[]
    connect?: arteWhereUniqueInput | arteWhereUniqueInput[]
    update?: arteUpdateWithWhereUniqueWithoutOrdentInput | arteUpdateWithWhereUniqueWithoutOrdentInput[]
    updateMany?: arteUpdateManyWithWhereWithoutOrdentInput | arteUpdateManyWithWhereWithoutOrdentInput[]
    deleteMany?: arteScalarWhereInput | arteScalarWhereInput[]
  }

  export type detotUpdateManyWithoutOrdentNestedInput = {
    create?: XOR<detotCreateWithoutOrdentInput, detotUncheckedCreateWithoutOrdentInput> | detotCreateWithoutOrdentInput[] | detotUncheckedCreateWithoutOrdentInput[]
    connectOrCreate?: detotCreateOrConnectWithoutOrdentInput | detotCreateOrConnectWithoutOrdentInput[]
    upsert?: detotUpsertWithWhereUniqueWithoutOrdentInput | detotUpsertWithWhereUniqueWithoutOrdentInput[]
    createMany?: detotCreateManyOrdentInputEnvelope
    set?: detotWhereUniqueInput | detotWhereUniqueInput[]
    disconnect?: detotWhereUniqueInput | detotWhereUniqueInput[]
    delete?: detotWhereUniqueInput | detotWhereUniqueInput[]
    connect?: detotWhereUniqueInput | detotWhereUniqueInput[]
    update?: detotUpdateWithWhereUniqueWithoutOrdentInput | detotUpdateWithWhereUniqueWithoutOrdentInput[]
    updateMany?: detotUpdateManyWithWhereWithoutOrdentInput | detotUpdateManyWithWhereWithoutOrdentInput[]
    deleteMany?: detotScalarWhereInput | detotScalarWhereInput[]
  }

  export type facturaUpdateManyWithoutOrdentNestedInput = {
    create?: XOR<facturaCreateWithoutOrdentInput, facturaUncheckedCreateWithoutOrdentInput> | facturaCreateWithoutOrdentInput[] | facturaUncheckedCreateWithoutOrdentInput[]
    connectOrCreate?: facturaCreateOrConnectWithoutOrdentInput | facturaCreateOrConnectWithoutOrdentInput[]
    upsert?: facturaUpsertWithWhereUniqueWithoutOrdentInput | facturaUpsertWithWhereUniqueWithoutOrdentInput[]
    createMany?: facturaCreateManyOrdentInputEnvelope
    set?: facturaWhereUniqueInput | facturaWhereUniqueInput[]
    disconnect?: facturaWhereUniqueInput | facturaWhereUniqueInput[]
    delete?: facturaWhereUniqueInput | facturaWhereUniqueInput[]
    connect?: facturaWhereUniqueInput | facturaWhereUniqueInput[]
    update?: facturaUpdateWithWhereUniqueWithoutOrdentInput | facturaUpdateWithWhereUniqueWithoutOrdentInput[]
    updateMany?: facturaUpdateManyWithWhereWithoutOrdentInput | facturaUpdateManyWithWhereWithoutOrdentInput[]
    deleteMany?: facturaScalarWhereInput | facturaScalarWhereInput[]
  }

  export type clienteUpdateOneWithoutOrdentNestedInput = {
    create?: XOR<clienteCreateWithoutOrdentInput, clienteUncheckedCreateWithoutOrdentInput>
    connectOrCreate?: clienteCreateOrConnectWithoutOrdentInput
    upsert?: clienteUpsertWithoutOrdentInput
    disconnect?: clienteWhereInput | boolean
    delete?: clienteWhereInput | boolean
    connect?: clienteWhereUniqueInput
    update?: XOR<XOR<clienteUpdateToOneWithWhereWithoutOrdentInput, clienteUpdateWithoutOrdentInput>, clienteUncheckedUpdateWithoutOrdentInput>
  }

  export type cotizacionUpdateOneWithoutOrdentNestedInput = {
    create?: XOR<cotizacionCreateWithoutOrdentInput, cotizacionUncheckedCreateWithoutOrdentInput>
    connectOrCreate?: cotizacionCreateOrConnectWithoutOrdentInput
    upsert?: cotizacionUpsertWithoutOrdentInput
    disconnect?: cotizacionWhereInput | boolean
    delete?: cotizacionWhereInput | boolean
    connect?: cotizacionWhereUniqueInput
    update?: XOR<XOR<cotizacionUpdateToOneWithWhereWithoutOrdentInput, cotizacionUpdateWithoutOrdentInput>, cotizacionUncheckedUpdateWithoutOrdentInput>
  }

  export type usuarioUpdateOneWithoutOrdentNestedInput = {
    create?: XOR<usuarioCreateWithoutOrdentInput, usuarioUncheckedCreateWithoutOrdentInput>
    connectOrCreate?: usuarioCreateOrConnectWithoutOrdentInput
    upsert?: usuarioUpsertWithoutOrdentInput
    disconnect?: usuarioWhereInput | boolean
    delete?: usuarioWhereInput | boolean
    connect?: usuarioWhereUniqueInput
    update?: XOR<XOR<usuarioUpdateToOneWithWhereWithoutOrdentInput, usuarioUpdateWithoutOrdentInput>, usuarioUncheckedUpdateWithoutOrdentInput>
  }

  export type pagoUpdateManyWithoutOrdentNestedInput = {
    create?: XOR<pagoCreateWithoutOrdentInput, pagoUncheckedCreateWithoutOrdentInput> | pagoCreateWithoutOrdentInput[] | pagoUncheckedCreateWithoutOrdentInput[]
    connectOrCreate?: pagoCreateOrConnectWithoutOrdentInput | pagoCreateOrConnectWithoutOrdentInput[]
    upsert?: pagoUpsertWithWhereUniqueWithoutOrdentInput | pagoUpsertWithWhereUniqueWithoutOrdentInput[]
    createMany?: pagoCreateManyOrdentInputEnvelope
    set?: pagoWhereUniqueInput | pagoWhereUniqueInput[]
    disconnect?: pagoWhereUniqueInput | pagoWhereUniqueInput[]
    delete?: pagoWhereUniqueInput | pagoWhereUniqueInput[]
    connect?: pagoWhereUniqueInput | pagoWhereUniqueInput[]
    update?: pagoUpdateWithWhereUniqueWithoutOrdentInput | pagoUpdateWithWhereUniqueWithoutOrdentInput[]
    updateMany?: pagoUpdateManyWithWhereWithoutOrdentInput | pagoUpdateManyWithWhereWithoutOrdentInput[]
    deleteMany?: pagoScalarWhereInput | pagoScalarWhereInput[]
  }

  export type arteUncheckedUpdateManyWithoutOrdentNestedInput = {
    create?: XOR<arteCreateWithoutOrdentInput, arteUncheckedCreateWithoutOrdentInput> | arteCreateWithoutOrdentInput[] | arteUncheckedCreateWithoutOrdentInput[]
    connectOrCreate?: arteCreateOrConnectWithoutOrdentInput | arteCreateOrConnectWithoutOrdentInput[]
    upsert?: arteUpsertWithWhereUniqueWithoutOrdentInput | arteUpsertWithWhereUniqueWithoutOrdentInput[]
    createMany?: arteCreateManyOrdentInputEnvelope
    set?: arteWhereUniqueInput | arteWhereUniqueInput[]
    disconnect?: arteWhereUniqueInput | arteWhereUniqueInput[]
    delete?: arteWhereUniqueInput | arteWhereUniqueInput[]
    connect?: arteWhereUniqueInput | arteWhereUniqueInput[]
    update?: arteUpdateWithWhereUniqueWithoutOrdentInput | arteUpdateWithWhereUniqueWithoutOrdentInput[]
    updateMany?: arteUpdateManyWithWhereWithoutOrdentInput | arteUpdateManyWithWhereWithoutOrdentInput[]
    deleteMany?: arteScalarWhereInput | arteScalarWhereInput[]
  }

  export type detotUncheckedUpdateManyWithoutOrdentNestedInput = {
    create?: XOR<detotCreateWithoutOrdentInput, detotUncheckedCreateWithoutOrdentInput> | detotCreateWithoutOrdentInput[] | detotUncheckedCreateWithoutOrdentInput[]
    connectOrCreate?: detotCreateOrConnectWithoutOrdentInput | detotCreateOrConnectWithoutOrdentInput[]
    upsert?: detotUpsertWithWhereUniqueWithoutOrdentInput | detotUpsertWithWhereUniqueWithoutOrdentInput[]
    createMany?: detotCreateManyOrdentInputEnvelope
    set?: detotWhereUniqueInput | detotWhereUniqueInput[]
    disconnect?: detotWhereUniqueInput | detotWhereUniqueInput[]
    delete?: detotWhereUniqueInput | detotWhereUniqueInput[]
    connect?: detotWhereUniqueInput | detotWhereUniqueInput[]
    update?: detotUpdateWithWhereUniqueWithoutOrdentInput | detotUpdateWithWhereUniqueWithoutOrdentInput[]
    updateMany?: detotUpdateManyWithWhereWithoutOrdentInput | detotUpdateManyWithWhereWithoutOrdentInput[]
    deleteMany?: detotScalarWhereInput | detotScalarWhereInput[]
  }

  export type facturaUncheckedUpdateManyWithoutOrdentNestedInput = {
    create?: XOR<facturaCreateWithoutOrdentInput, facturaUncheckedCreateWithoutOrdentInput> | facturaCreateWithoutOrdentInput[] | facturaUncheckedCreateWithoutOrdentInput[]
    connectOrCreate?: facturaCreateOrConnectWithoutOrdentInput | facturaCreateOrConnectWithoutOrdentInput[]
    upsert?: facturaUpsertWithWhereUniqueWithoutOrdentInput | facturaUpsertWithWhereUniqueWithoutOrdentInput[]
    createMany?: facturaCreateManyOrdentInputEnvelope
    set?: facturaWhereUniqueInput | facturaWhereUniqueInput[]
    disconnect?: facturaWhereUniqueInput | facturaWhereUniqueInput[]
    delete?: facturaWhereUniqueInput | facturaWhereUniqueInput[]
    connect?: facturaWhereUniqueInput | facturaWhereUniqueInput[]
    update?: facturaUpdateWithWhereUniqueWithoutOrdentInput | facturaUpdateWithWhereUniqueWithoutOrdentInput[]
    updateMany?: facturaUpdateManyWithWhereWithoutOrdentInput | facturaUpdateManyWithWhereWithoutOrdentInput[]
    deleteMany?: facturaScalarWhereInput | facturaScalarWhereInput[]
  }

  export type pagoUncheckedUpdateManyWithoutOrdentNestedInput = {
    create?: XOR<pagoCreateWithoutOrdentInput, pagoUncheckedCreateWithoutOrdentInput> | pagoCreateWithoutOrdentInput[] | pagoUncheckedCreateWithoutOrdentInput[]
    connectOrCreate?: pagoCreateOrConnectWithoutOrdentInput | pagoCreateOrConnectWithoutOrdentInput[]
    upsert?: pagoUpsertWithWhereUniqueWithoutOrdentInput | pagoUpsertWithWhereUniqueWithoutOrdentInput[]
    createMany?: pagoCreateManyOrdentInputEnvelope
    set?: pagoWhereUniqueInput | pagoWhereUniqueInput[]
    disconnect?: pagoWhereUniqueInput | pagoWhereUniqueInput[]
    delete?: pagoWhereUniqueInput | pagoWhereUniqueInput[]
    connect?: pagoWhereUniqueInput | pagoWhereUniqueInput[]
    update?: pagoUpdateWithWhereUniqueWithoutOrdentInput | pagoUpdateWithWhereUniqueWithoutOrdentInput[]
    updateMany?: pagoUpdateManyWithWhereWithoutOrdentInput | pagoUpdateManyWithWhereWithoutOrdentInput[]
    deleteMany?: pagoScalarWhereInput | pagoScalarWhereInput[]
  }

  export type ordentCreateNestedOneWithoutPagoInput = {
    create?: XOR<ordentCreateWithoutPagoInput, ordentUncheckedCreateWithoutPagoInput>
    connectOrCreate?: ordentCreateOrConnectWithoutPagoInput
    connect?: ordentWhereUniqueInput
  }

  export type ordentUpdateOneWithoutPagoNestedInput = {
    create?: XOR<ordentCreateWithoutPagoInput, ordentUncheckedCreateWithoutPagoInput>
    connectOrCreate?: ordentCreateOrConnectWithoutPagoInput
    upsert?: ordentUpsertWithoutPagoInput
    disconnect?: ordentWhereInput | boolean
    delete?: ordentWhereInput | boolean
    connect?: ordentWhereUniqueInput
    update?: XOR<XOR<ordentUpdateToOneWithWhereWithoutPagoInput, ordentUpdateWithoutPagoInput>, ordentUncheckedUpdateWithoutPagoInput>
  }

  export type clienteCreateNestedManyWithoutPersonaInput = {
    create?: XOR<clienteCreateWithoutPersonaInput, clienteUncheckedCreateWithoutPersonaInput> | clienteCreateWithoutPersonaInput[] | clienteUncheckedCreateWithoutPersonaInput[]
    connectOrCreate?: clienteCreateOrConnectWithoutPersonaInput | clienteCreateOrConnectWithoutPersonaInput[]
    createMany?: clienteCreateManyPersonaInputEnvelope
    connect?: clienteWhereUniqueInput | clienteWhereUniqueInput[]
  }

  export type empresaCreateNestedManyWithoutPersonaInput = {
    create?: XOR<empresaCreateWithoutPersonaInput, empresaUncheckedCreateWithoutPersonaInput> | empresaCreateWithoutPersonaInput[] | empresaUncheckedCreateWithoutPersonaInput[]
    connectOrCreate?: empresaCreateOrConnectWithoutPersonaInput | empresaCreateOrConnectWithoutPersonaInput[]
    createMany?: empresaCreateManyPersonaInputEnvelope
    connect?: empresaWhereUniqueInput | empresaWhereUniqueInput[]
  }

  export type proveedorCreateNestedManyWithoutPersonaInput = {
    create?: XOR<proveedorCreateWithoutPersonaInput, proveedorUncheckedCreateWithoutPersonaInput> | proveedorCreateWithoutPersonaInput[] | proveedorUncheckedCreateWithoutPersonaInput[]
    connectOrCreate?: proveedorCreateOrConnectWithoutPersonaInput | proveedorCreateOrConnectWithoutPersonaInput[]
    createMany?: proveedorCreateManyPersonaInputEnvelope
    connect?: proveedorWhereUniqueInput | proveedorWhereUniqueInput[]
  }

  export type telefonoCreateNestedManyWithoutPersonaInput = {
    create?: XOR<telefonoCreateWithoutPersonaInput, telefonoUncheckedCreateWithoutPersonaInput> | telefonoCreateWithoutPersonaInput[] | telefonoUncheckedCreateWithoutPersonaInput[]
    connectOrCreate?: telefonoCreateOrConnectWithoutPersonaInput | telefonoCreateOrConnectWithoutPersonaInput[]
    createMany?: telefonoCreateManyPersonaInputEnvelope
    connect?: telefonoWhereUniqueInput | telefonoWhereUniqueInput[]
  }

  export type usuarioCreateNestedManyWithoutPersonaInput = {
    create?: XOR<usuarioCreateWithoutPersonaInput, usuarioUncheckedCreateWithoutPersonaInput> | usuarioCreateWithoutPersonaInput[] | usuarioUncheckedCreateWithoutPersonaInput[]
    connectOrCreate?: usuarioCreateOrConnectWithoutPersonaInput | usuarioCreateOrConnectWithoutPersonaInput[]
    createMany?: usuarioCreateManyPersonaInputEnvelope
    connect?: usuarioWhereUniqueInput | usuarioWhereUniqueInput[]
  }

  export type clienteUncheckedCreateNestedManyWithoutPersonaInput = {
    create?: XOR<clienteCreateWithoutPersonaInput, clienteUncheckedCreateWithoutPersonaInput> | clienteCreateWithoutPersonaInput[] | clienteUncheckedCreateWithoutPersonaInput[]
    connectOrCreate?: clienteCreateOrConnectWithoutPersonaInput | clienteCreateOrConnectWithoutPersonaInput[]
    createMany?: clienteCreateManyPersonaInputEnvelope
    connect?: clienteWhereUniqueInput | clienteWhereUniqueInput[]
  }

  export type empresaUncheckedCreateNestedManyWithoutPersonaInput = {
    create?: XOR<empresaCreateWithoutPersonaInput, empresaUncheckedCreateWithoutPersonaInput> | empresaCreateWithoutPersonaInput[] | empresaUncheckedCreateWithoutPersonaInput[]
    connectOrCreate?: empresaCreateOrConnectWithoutPersonaInput | empresaCreateOrConnectWithoutPersonaInput[]
    createMany?: empresaCreateManyPersonaInputEnvelope
    connect?: empresaWhereUniqueInput | empresaWhereUniqueInput[]
  }

  export type proveedorUncheckedCreateNestedManyWithoutPersonaInput = {
    create?: XOR<proveedorCreateWithoutPersonaInput, proveedorUncheckedCreateWithoutPersonaInput> | proveedorCreateWithoutPersonaInput[] | proveedorUncheckedCreateWithoutPersonaInput[]
    connectOrCreate?: proveedorCreateOrConnectWithoutPersonaInput | proveedorCreateOrConnectWithoutPersonaInput[]
    createMany?: proveedorCreateManyPersonaInputEnvelope
    connect?: proveedorWhereUniqueInput | proveedorWhereUniqueInput[]
  }

  export type telefonoUncheckedCreateNestedManyWithoutPersonaInput = {
    create?: XOR<telefonoCreateWithoutPersonaInput, telefonoUncheckedCreateWithoutPersonaInput> | telefonoCreateWithoutPersonaInput[] | telefonoUncheckedCreateWithoutPersonaInput[]
    connectOrCreate?: telefonoCreateOrConnectWithoutPersonaInput | telefonoCreateOrConnectWithoutPersonaInput[]
    createMany?: telefonoCreateManyPersonaInputEnvelope
    connect?: telefonoWhereUniqueInput | telefonoWhereUniqueInput[]
  }

  export type usuarioUncheckedCreateNestedManyWithoutPersonaInput = {
    create?: XOR<usuarioCreateWithoutPersonaInput, usuarioUncheckedCreateWithoutPersonaInput> | usuarioCreateWithoutPersonaInput[] | usuarioUncheckedCreateWithoutPersonaInput[]
    connectOrCreate?: usuarioCreateOrConnectWithoutPersonaInput | usuarioCreateOrConnectWithoutPersonaInput[]
    createMany?: usuarioCreateManyPersonaInputEnvelope
    connect?: usuarioWhereUniqueInput | usuarioWhereUniqueInput[]
  }

  export type clienteUpdateManyWithoutPersonaNestedInput = {
    create?: XOR<clienteCreateWithoutPersonaInput, clienteUncheckedCreateWithoutPersonaInput> | clienteCreateWithoutPersonaInput[] | clienteUncheckedCreateWithoutPersonaInput[]
    connectOrCreate?: clienteCreateOrConnectWithoutPersonaInput | clienteCreateOrConnectWithoutPersonaInput[]
    upsert?: clienteUpsertWithWhereUniqueWithoutPersonaInput | clienteUpsertWithWhereUniqueWithoutPersonaInput[]
    createMany?: clienteCreateManyPersonaInputEnvelope
    set?: clienteWhereUniqueInput | clienteWhereUniqueInput[]
    disconnect?: clienteWhereUniqueInput | clienteWhereUniqueInput[]
    delete?: clienteWhereUniqueInput | clienteWhereUniqueInput[]
    connect?: clienteWhereUniqueInput | clienteWhereUniqueInput[]
    update?: clienteUpdateWithWhereUniqueWithoutPersonaInput | clienteUpdateWithWhereUniqueWithoutPersonaInput[]
    updateMany?: clienteUpdateManyWithWhereWithoutPersonaInput | clienteUpdateManyWithWhereWithoutPersonaInput[]
    deleteMany?: clienteScalarWhereInput | clienteScalarWhereInput[]
  }

  export type empresaUpdateManyWithoutPersonaNestedInput = {
    create?: XOR<empresaCreateWithoutPersonaInput, empresaUncheckedCreateWithoutPersonaInput> | empresaCreateWithoutPersonaInput[] | empresaUncheckedCreateWithoutPersonaInput[]
    connectOrCreate?: empresaCreateOrConnectWithoutPersonaInput | empresaCreateOrConnectWithoutPersonaInput[]
    upsert?: empresaUpsertWithWhereUniqueWithoutPersonaInput | empresaUpsertWithWhereUniqueWithoutPersonaInput[]
    createMany?: empresaCreateManyPersonaInputEnvelope
    set?: empresaWhereUniqueInput | empresaWhereUniqueInput[]
    disconnect?: empresaWhereUniqueInput | empresaWhereUniqueInput[]
    delete?: empresaWhereUniqueInput | empresaWhereUniqueInput[]
    connect?: empresaWhereUniqueInput | empresaWhereUniqueInput[]
    update?: empresaUpdateWithWhereUniqueWithoutPersonaInput | empresaUpdateWithWhereUniqueWithoutPersonaInput[]
    updateMany?: empresaUpdateManyWithWhereWithoutPersonaInput | empresaUpdateManyWithWhereWithoutPersonaInput[]
    deleteMany?: empresaScalarWhereInput | empresaScalarWhereInput[]
  }

  export type proveedorUpdateManyWithoutPersonaNestedInput = {
    create?: XOR<proveedorCreateWithoutPersonaInput, proveedorUncheckedCreateWithoutPersonaInput> | proveedorCreateWithoutPersonaInput[] | proveedorUncheckedCreateWithoutPersonaInput[]
    connectOrCreate?: proveedorCreateOrConnectWithoutPersonaInput | proveedorCreateOrConnectWithoutPersonaInput[]
    upsert?: proveedorUpsertWithWhereUniqueWithoutPersonaInput | proveedorUpsertWithWhereUniqueWithoutPersonaInput[]
    createMany?: proveedorCreateManyPersonaInputEnvelope
    set?: proveedorWhereUniqueInput | proveedorWhereUniqueInput[]
    disconnect?: proveedorWhereUniqueInput | proveedorWhereUniqueInput[]
    delete?: proveedorWhereUniqueInput | proveedorWhereUniqueInput[]
    connect?: proveedorWhereUniqueInput | proveedorWhereUniqueInput[]
    update?: proveedorUpdateWithWhereUniqueWithoutPersonaInput | proveedorUpdateWithWhereUniqueWithoutPersonaInput[]
    updateMany?: proveedorUpdateManyWithWhereWithoutPersonaInput | proveedorUpdateManyWithWhereWithoutPersonaInput[]
    deleteMany?: proveedorScalarWhereInput | proveedorScalarWhereInput[]
  }

  export type telefonoUpdateManyWithoutPersonaNestedInput = {
    create?: XOR<telefonoCreateWithoutPersonaInput, telefonoUncheckedCreateWithoutPersonaInput> | telefonoCreateWithoutPersonaInput[] | telefonoUncheckedCreateWithoutPersonaInput[]
    connectOrCreate?: telefonoCreateOrConnectWithoutPersonaInput | telefonoCreateOrConnectWithoutPersonaInput[]
    upsert?: telefonoUpsertWithWhereUniqueWithoutPersonaInput | telefonoUpsertWithWhereUniqueWithoutPersonaInput[]
    createMany?: telefonoCreateManyPersonaInputEnvelope
    set?: telefonoWhereUniqueInput | telefonoWhereUniqueInput[]
    disconnect?: telefonoWhereUniqueInput | telefonoWhereUniqueInput[]
    delete?: telefonoWhereUniqueInput | telefonoWhereUniqueInput[]
    connect?: telefonoWhereUniqueInput | telefonoWhereUniqueInput[]
    update?: telefonoUpdateWithWhereUniqueWithoutPersonaInput | telefonoUpdateWithWhereUniqueWithoutPersonaInput[]
    updateMany?: telefonoUpdateManyWithWhereWithoutPersonaInput | telefonoUpdateManyWithWhereWithoutPersonaInput[]
    deleteMany?: telefonoScalarWhereInput | telefonoScalarWhereInput[]
  }

  export type usuarioUpdateManyWithoutPersonaNestedInput = {
    create?: XOR<usuarioCreateWithoutPersonaInput, usuarioUncheckedCreateWithoutPersonaInput> | usuarioCreateWithoutPersonaInput[] | usuarioUncheckedCreateWithoutPersonaInput[]
    connectOrCreate?: usuarioCreateOrConnectWithoutPersonaInput | usuarioCreateOrConnectWithoutPersonaInput[]
    upsert?: usuarioUpsertWithWhereUniqueWithoutPersonaInput | usuarioUpsertWithWhereUniqueWithoutPersonaInput[]
    createMany?: usuarioCreateManyPersonaInputEnvelope
    set?: usuarioWhereUniqueInput | usuarioWhereUniqueInput[]
    disconnect?: usuarioWhereUniqueInput | usuarioWhereUniqueInput[]
    delete?: usuarioWhereUniqueInput | usuarioWhereUniqueInput[]
    connect?: usuarioWhereUniqueInput | usuarioWhereUniqueInput[]
    update?: usuarioUpdateWithWhereUniqueWithoutPersonaInput | usuarioUpdateWithWhereUniqueWithoutPersonaInput[]
    updateMany?: usuarioUpdateManyWithWhereWithoutPersonaInput | usuarioUpdateManyWithWhereWithoutPersonaInput[]
    deleteMany?: usuarioScalarWhereInput | usuarioScalarWhereInput[]
  }

  export type clienteUncheckedUpdateManyWithoutPersonaNestedInput = {
    create?: XOR<clienteCreateWithoutPersonaInput, clienteUncheckedCreateWithoutPersonaInput> | clienteCreateWithoutPersonaInput[] | clienteUncheckedCreateWithoutPersonaInput[]
    connectOrCreate?: clienteCreateOrConnectWithoutPersonaInput | clienteCreateOrConnectWithoutPersonaInput[]
    upsert?: clienteUpsertWithWhereUniqueWithoutPersonaInput | clienteUpsertWithWhereUniqueWithoutPersonaInput[]
    createMany?: clienteCreateManyPersonaInputEnvelope
    set?: clienteWhereUniqueInput | clienteWhereUniqueInput[]
    disconnect?: clienteWhereUniqueInput | clienteWhereUniqueInput[]
    delete?: clienteWhereUniqueInput | clienteWhereUniqueInput[]
    connect?: clienteWhereUniqueInput | clienteWhereUniqueInput[]
    update?: clienteUpdateWithWhereUniqueWithoutPersonaInput | clienteUpdateWithWhereUniqueWithoutPersonaInput[]
    updateMany?: clienteUpdateManyWithWhereWithoutPersonaInput | clienteUpdateManyWithWhereWithoutPersonaInput[]
    deleteMany?: clienteScalarWhereInput | clienteScalarWhereInput[]
  }

  export type empresaUncheckedUpdateManyWithoutPersonaNestedInput = {
    create?: XOR<empresaCreateWithoutPersonaInput, empresaUncheckedCreateWithoutPersonaInput> | empresaCreateWithoutPersonaInput[] | empresaUncheckedCreateWithoutPersonaInput[]
    connectOrCreate?: empresaCreateOrConnectWithoutPersonaInput | empresaCreateOrConnectWithoutPersonaInput[]
    upsert?: empresaUpsertWithWhereUniqueWithoutPersonaInput | empresaUpsertWithWhereUniqueWithoutPersonaInput[]
    createMany?: empresaCreateManyPersonaInputEnvelope
    set?: empresaWhereUniqueInput | empresaWhereUniqueInput[]
    disconnect?: empresaWhereUniqueInput | empresaWhereUniqueInput[]
    delete?: empresaWhereUniqueInput | empresaWhereUniqueInput[]
    connect?: empresaWhereUniqueInput | empresaWhereUniqueInput[]
    update?: empresaUpdateWithWhereUniqueWithoutPersonaInput | empresaUpdateWithWhereUniqueWithoutPersonaInput[]
    updateMany?: empresaUpdateManyWithWhereWithoutPersonaInput | empresaUpdateManyWithWhereWithoutPersonaInput[]
    deleteMany?: empresaScalarWhereInput | empresaScalarWhereInput[]
  }

  export type proveedorUncheckedUpdateManyWithoutPersonaNestedInput = {
    create?: XOR<proveedorCreateWithoutPersonaInput, proveedorUncheckedCreateWithoutPersonaInput> | proveedorCreateWithoutPersonaInput[] | proveedorUncheckedCreateWithoutPersonaInput[]
    connectOrCreate?: proveedorCreateOrConnectWithoutPersonaInput | proveedorCreateOrConnectWithoutPersonaInput[]
    upsert?: proveedorUpsertWithWhereUniqueWithoutPersonaInput | proveedorUpsertWithWhereUniqueWithoutPersonaInput[]
    createMany?: proveedorCreateManyPersonaInputEnvelope
    set?: proveedorWhereUniqueInput | proveedorWhereUniqueInput[]
    disconnect?: proveedorWhereUniqueInput | proveedorWhereUniqueInput[]
    delete?: proveedorWhereUniqueInput | proveedorWhereUniqueInput[]
    connect?: proveedorWhereUniqueInput | proveedorWhereUniqueInput[]
    update?: proveedorUpdateWithWhereUniqueWithoutPersonaInput | proveedorUpdateWithWhereUniqueWithoutPersonaInput[]
    updateMany?: proveedorUpdateManyWithWhereWithoutPersonaInput | proveedorUpdateManyWithWhereWithoutPersonaInput[]
    deleteMany?: proveedorScalarWhereInput | proveedorScalarWhereInput[]
  }

  export type telefonoUncheckedUpdateManyWithoutPersonaNestedInput = {
    create?: XOR<telefonoCreateWithoutPersonaInput, telefonoUncheckedCreateWithoutPersonaInput> | telefonoCreateWithoutPersonaInput[] | telefonoUncheckedCreateWithoutPersonaInput[]
    connectOrCreate?: telefonoCreateOrConnectWithoutPersonaInput | telefonoCreateOrConnectWithoutPersonaInput[]
    upsert?: telefonoUpsertWithWhereUniqueWithoutPersonaInput | telefonoUpsertWithWhereUniqueWithoutPersonaInput[]
    createMany?: telefonoCreateManyPersonaInputEnvelope
    set?: telefonoWhereUniqueInput | telefonoWhereUniqueInput[]
    disconnect?: telefonoWhereUniqueInput | telefonoWhereUniqueInput[]
    delete?: telefonoWhereUniqueInput | telefonoWhereUniqueInput[]
    connect?: telefonoWhereUniqueInput | telefonoWhereUniqueInput[]
    update?: telefonoUpdateWithWhereUniqueWithoutPersonaInput | telefonoUpdateWithWhereUniqueWithoutPersonaInput[]
    updateMany?: telefonoUpdateManyWithWhereWithoutPersonaInput | telefonoUpdateManyWithWhereWithoutPersonaInput[]
    deleteMany?: telefonoScalarWhereInput | telefonoScalarWhereInput[]
  }

  export type usuarioUncheckedUpdateManyWithoutPersonaNestedInput = {
    create?: XOR<usuarioCreateWithoutPersonaInput, usuarioUncheckedCreateWithoutPersonaInput> | usuarioCreateWithoutPersonaInput[] | usuarioUncheckedCreateWithoutPersonaInput[]
    connectOrCreate?: usuarioCreateOrConnectWithoutPersonaInput | usuarioCreateOrConnectWithoutPersonaInput[]
    upsert?: usuarioUpsertWithWhereUniqueWithoutPersonaInput | usuarioUpsertWithWhereUniqueWithoutPersonaInput[]
    createMany?: usuarioCreateManyPersonaInputEnvelope
    set?: usuarioWhereUniqueInput | usuarioWhereUniqueInput[]
    disconnect?: usuarioWhereUniqueInput | usuarioWhereUniqueInput[]
    delete?: usuarioWhereUniqueInput | usuarioWhereUniqueInput[]
    connect?: usuarioWhereUniqueInput | usuarioWhereUniqueInput[]
    update?: usuarioUpdateWithWhereUniqueWithoutPersonaInput | usuarioUpdateWithWhereUniqueWithoutPersonaInput[]
    updateMany?: usuarioUpdateManyWithWhereWithoutPersonaInput | usuarioUpdateManyWithWhereWithoutPersonaInput[]
    deleteMany?: usuarioScalarWhereInput | usuarioScalarWhereInput[]
  }

  export type detcotCreateNestedManyWithoutProductoInput = {
    create?: XOR<detcotCreateWithoutProductoInput, detcotUncheckedCreateWithoutProductoInput> | detcotCreateWithoutProductoInput[] | detcotUncheckedCreateWithoutProductoInput[]
    connectOrCreate?: detcotCreateOrConnectWithoutProductoInput | detcotCreateOrConnectWithoutProductoInput[]
    createMany?: detcotCreateManyProductoInputEnvelope
    connect?: detcotWhereUniqueInput | detcotWhereUniqueInput[]
  }

  export type detotCreateNestedManyWithoutProductoInput = {
    create?: XOR<detotCreateWithoutProductoInput, detotUncheckedCreateWithoutProductoInput> | detotCreateWithoutProductoInput[] | detotUncheckedCreateWithoutProductoInput[]
    connectOrCreate?: detotCreateOrConnectWithoutProductoInput | detotCreateOrConnectWithoutProductoInput[]
    createMany?: detotCreateManyProductoInputEnvelope
    connect?: detotWhereUniqueInput | detotWhereUniqueInput[]
  }

  export type marcaCreateNestedOneWithoutProductoInput = {
    create?: XOR<marcaCreateWithoutProductoInput, marcaUncheckedCreateWithoutProductoInput>
    connectOrCreate?: marcaCreateOrConnectWithoutProductoInput
    connect?: marcaWhereUniqueInput
  }

  export type detcotUncheckedCreateNestedManyWithoutProductoInput = {
    create?: XOR<detcotCreateWithoutProductoInput, detcotUncheckedCreateWithoutProductoInput> | detcotCreateWithoutProductoInput[] | detcotUncheckedCreateWithoutProductoInput[]
    connectOrCreate?: detcotCreateOrConnectWithoutProductoInput | detcotCreateOrConnectWithoutProductoInput[]
    createMany?: detcotCreateManyProductoInputEnvelope
    connect?: detcotWhereUniqueInput | detcotWhereUniqueInput[]
  }

  export type detotUncheckedCreateNestedManyWithoutProductoInput = {
    create?: XOR<detotCreateWithoutProductoInput, detotUncheckedCreateWithoutProductoInput> | detotCreateWithoutProductoInput[] | detotUncheckedCreateWithoutProductoInput[]
    connectOrCreate?: detotCreateOrConnectWithoutProductoInput | detotCreateOrConnectWithoutProductoInput[]
    createMany?: detotCreateManyProductoInputEnvelope
    connect?: detotWhereUniqueInput | detotWhereUniqueInput[]
  }

  export type detcotUpdateManyWithoutProductoNestedInput = {
    create?: XOR<detcotCreateWithoutProductoInput, detcotUncheckedCreateWithoutProductoInput> | detcotCreateWithoutProductoInput[] | detcotUncheckedCreateWithoutProductoInput[]
    connectOrCreate?: detcotCreateOrConnectWithoutProductoInput | detcotCreateOrConnectWithoutProductoInput[]
    upsert?: detcotUpsertWithWhereUniqueWithoutProductoInput | detcotUpsertWithWhereUniqueWithoutProductoInput[]
    createMany?: detcotCreateManyProductoInputEnvelope
    set?: detcotWhereUniqueInput | detcotWhereUniqueInput[]
    disconnect?: detcotWhereUniqueInput | detcotWhereUniqueInput[]
    delete?: detcotWhereUniqueInput | detcotWhereUniqueInput[]
    connect?: detcotWhereUniqueInput | detcotWhereUniqueInput[]
    update?: detcotUpdateWithWhereUniqueWithoutProductoInput | detcotUpdateWithWhereUniqueWithoutProductoInput[]
    updateMany?: detcotUpdateManyWithWhereWithoutProductoInput | detcotUpdateManyWithWhereWithoutProductoInput[]
    deleteMany?: detcotScalarWhereInput | detcotScalarWhereInput[]
  }

  export type detotUpdateManyWithoutProductoNestedInput = {
    create?: XOR<detotCreateWithoutProductoInput, detotUncheckedCreateWithoutProductoInput> | detotCreateWithoutProductoInput[] | detotUncheckedCreateWithoutProductoInput[]
    connectOrCreate?: detotCreateOrConnectWithoutProductoInput | detotCreateOrConnectWithoutProductoInput[]
    upsert?: detotUpsertWithWhereUniqueWithoutProductoInput | detotUpsertWithWhereUniqueWithoutProductoInput[]
    createMany?: detotCreateManyProductoInputEnvelope
    set?: detotWhereUniqueInput | detotWhereUniqueInput[]
    disconnect?: detotWhereUniqueInput | detotWhereUniqueInput[]
    delete?: detotWhereUniqueInput | detotWhereUniqueInput[]
    connect?: detotWhereUniqueInput | detotWhereUniqueInput[]
    update?: detotUpdateWithWhereUniqueWithoutProductoInput | detotUpdateWithWhereUniqueWithoutProductoInput[]
    updateMany?: detotUpdateManyWithWhereWithoutProductoInput | detotUpdateManyWithWhereWithoutProductoInput[]
    deleteMany?: detotScalarWhereInput | detotScalarWhereInput[]
  }

  export type marcaUpdateOneWithoutProductoNestedInput = {
    create?: XOR<marcaCreateWithoutProductoInput, marcaUncheckedCreateWithoutProductoInput>
    connectOrCreate?: marcaCreateOrConnectWithoutProductoInput
    upsert?: marcaUpsertWithoutProductoInput
    disconnect?: marcaWhereInput | boolean
    delete?: marcaWhereInput | boolean
    connect?: marcaWhereUniqueInput
    update?: XOR<XOR<marcaUpdateToOneWithWhereWithoutProductoInput, marcaUpdateWithoutProductoInput>, marcaUncheckedUpdateWithoutProductoInput>
  }

  export type detcotUncheckedUpdateManyWithoutProductoNestedInput = {
    create?: XOR<detcotCreateWithoutProductoInput, detcotUncheckedCreateWithoutProductoInput> | detcotCreateWithoutProductoInput[] | detcotUncheckedCreateWithoutProductoInput[]
    connectOrCreate?: detcotCreateOrConnectWithoutProductoInput | detcotCreateOrConnectWithoutProductoInput[]
    upsert?: detcotUpsertWithWhereUniqueWithoutProductoInput | detcotUpsertWithWhereUniqueWithoutProductoInput[]
    createMany?: detcotCreateManyProductoInputEnvelope
    set?: detcotWhereUniqueInput | detcotWhereUniqueInput[]
    disconnect?: detcotWhereUniqueInput | detcotWhereUniqueInput[]
    delete?: detcotWhereUniqueInput | detcotWhereUniqueInput[]
    connect?: detcotWhereUniqueInput | detcotWhereUniqueInput[]
    update?: detcotUpdateWithWhereUniqueWithoutProductoInput | detcotUpdateWithWhereUniqueWithoutProductoInput[]
    updateMany?: detcotUpdateManyWithWhereWithoutProductoInput | detcotUpdateManyWithWhereWithoutProductoInput[]
    deleteMany?: detcotScalarWhereInput | detcotScalarWhereInput[]
  }

  export type detotUncheckedUpdateManyWithoutProductoNestedInput = {
    create?: XOR<detotCreateWithoutProductoInput, detotUncheckedCreateWithoutProductoInput> | detotCreateWithoutProductoInput[] | detotUncheckedCreateWithoutProductoInput[]
    connectOrCreate?: detotCreateOrConnectWithoutProductoInput | detotCreateOrConnectWithoutProductoInput[]
    upsert?: detotUpsertWithWhereUniqueWithoutProductoInput | detotUpsertWithWhereUniqueWithoutProductoInput[]
    createMany?: detotCreateManyProductoInputEnvelope
    set?: detotWhereUniqueInput | detotWhereUniqueInput[]
    disconnect?: detotWhereUniqueInput | detotWhereUniqueInput[]
    delete?: detotWhereUniqueInput | detotWhereUniqueInput[]
    connect?: detotWhereUniqueInput | detotWhereUniqueInput[]
    update?: detotUpdateWithWhereUniqueWithoutProductoInput | detotUpdateWithWhereUniqueWithoutProductoInput[]
    updateMany?: detotUpdateManyWithWhereWithoutProductoInput | detotUpdateManyWithWhereWithoutProductoInput[]
    deleteMany?: detotScalarWhereInput | detotScalarWhereInput[]
  }

  export type inventarioCreateNestedManyWithoutProveedorInput = {
    create?: XOR<inventarioCreateWithoutProveedorInput, inventarioUncheckedCreateWithoutProveedorInput> | inventarioCreateWithoutProveedorInput[] | inventarioUncheckedCreateWithoutProveedorInput[]
    connectOrCreate?: inventarioCreateOrConnectWithoutProveedorInput | inventarioCreateOrConnectWithoutProveedorInput[]
    createMany?: inventarioCreateManyProveedorInputEnvelope
    connect?: inventarioWhereUniqueInput | inventarioWhereUniqueInput[]
  }

  export type personaCreateNestedOneWithoutProveedorInput = {
    create?: XOR<personaCreateWithoutProveedorInput, personaUncheckedCreateWithoutProveedorInput>
    connectOrCreate?: personaCreateOrConnectWithoutProveedorInput
    connect?: personaWhereUniqueInput
  }

  export type inventarioUncheckedCreateNestedManyWithoutProveedorInput = {
    create?: XOR<inventarioCreateWithoutProveedorInput, inventarioUncheckedCreateWithoutProveedorInput> | inventarioCreateWithoutProveedorInput[] | inventarioUncheckedCreateWithoutProveedorInput[]
    connectOrCreate?: inventarioCreateOrConnectWithoutProveedorInput | inventarioCreateOrConnectWithoutProveedorInput[]
    createMany?: inventarioCreateManyProveedorInputEnvelope
    connect?: inventarioWhereUniqueInput | inventarioWhereUniqueInput[]
  }

  export type inventarioUpdateManyWithoutProveedorNestedInput = {
    create?: XOR<inventarioCreateWithoutProveedorInput, inventarioUncheckedCreateWithoutProveedorInput> | inventarioCreateWithoutProveedorInput[] | inventarioUncheckedCreateWithoutProveedorInput[]
    connectOrCreate?: inventarioCreateOrConnectWithoutProveedorInput | inventarioCreateOrConnectWithoutProveedorInput[]
    upsert?: inventarioUpsertWithWhereUniqueWithoutProveedorInput | inventarioUpsertWithWhereUniqueWithoutProveedorInput[]
    createMany?: inventarioCreateManyProveedorInputEnvelope
    set?: inventarioWhereUniqueInput | inventarioWhereUniqueInput[]
    disconnect?: inventarioWhereUniqueInput | inventarioWhereUniqueInput[]
    delete?: inventarioWhereUniqueInput | inventarioWhereUniqueInput[]
    connect?: inventarioWhereUniqueInput | inventarioWhereUniqueInput[]
    update?: inventarioUpdateWithWhereUniqueWithoutProveedorInput | inventarioUpdateWithWhereUniqueWithoutProveedorInput[]
    updateMany?: inventarioUpdateManyWithWhereWithoutProveedorInput | inventarioUpdateManyWithWhereWithoutProveedorInput[]
    deleteMany?: inventarioScalarWhereInput | inventarioScalarWhereInput[]
  }

  export type personaUpdateOneWithoutProveedorNestedInput = {
    create?: XOR<personaCreateWithoutProveedorInput, personaUncheckedCreateWithoutProveedorInput>
    connectOrCreate?: personaCreateOrConnectWithoutProveedorInput
    upsert?: personaUpsertWithoutProveedorInput
    disconnect?: personaWhereInput | boolean
    delete?: personaWhereInput | boolean
    connect?: personaWhereUniqueInput
    update?: XOR<XOR<personaUpdateToOneWithWhereWithoutProveedorInput, personaUpdateWithoutProveedorInput>, personaUncheckedUpdateWithoutProveedorInput>
  }

  export type inventarioUncheckedUpdateManyWithoutProveedorNestedInput = {
    create?: XOR<inventarioCreateWithoutProveedorInput, inventarioUncheckedCreateWithoutProveedorInput> | inventarioCreateWithoutProveedorInput[] | inventarioUncheckedCreateWithoutProveedorInput[]
    connectOrCreate?: inventarioCreateOrConnectWithoutProveedorInput | inventarioCreateOrConnectWithoutProveedorInput[]
    upsert?: inventarioUpsertWithWhereUniqueWithoutProveedorInput | inventarioUpsertWithWhereUniqueWithoutProveedorInput[]
    createMany?: inventarioCreateManyProveedorInputEnvelope
    set?: inventarioWhereUniqueInput | inventarioWhereUniqueInput[]
    disconnect?: inventarioWhereUniqueInput | inventarioWhereUniqueInput[]
    delete?: inventarioWhereUniqueInput | inventarioWhereUniqueInput[]
    connect?: inventarioWhereUniqueInput | inventarioWhereUniqueInput[]
    update?: inventarioUpdateWithWhereUniqueWithoutProveedorInput | inventarioUpdateWithWhereUniqueWithoutProveedorInput[]
    updateMany?: inventarioUpdateManyWithWhereWithoutProveedorInput | inventarioUpdateManyWithWhereWithoutProveedorInput[]
    deleteMany?: inventarioScalarWhereInput | inventarioScalarWhereInput[]
  }

  export type usuarioCreateNestedOneWithoutRegistrolaboralInput = {
    create?: XOR<usuarioCreateWithoutRegistrolaboralInput, usuarioUncheckedCreateWithoutRegistrolaboralInput>
    connectOrCreate?: usuarioCreateOrConnectWithoutRegistrolaboralInput
    connect?: usuarioWhereUniqueInput
  }

  export type usuarioUpdateOneWithoutRegistrolaboralNestedInput = {
    create?: XOR<usuarioCreateWithoutRegistrolaboralInput, usuarioUncheckedCreateWithoutRegistrolaboralInput>
    connectOrCreate?: usuarioCreateOrConnectWithoutRegistrolaboralInput
    upsert?: usuarioUpsertWithoutRegistrolaboralInput
    disconnect?: usuarioWhereInput | boolean
    delete?: usuarioWhereInput | boolean
    connect?: usuarioWhereUniqueInput
    update?: XOR<XOR<usuarioUpdateToOneWithWhereWithoutRegistrolaboralInput, usuarioUpdateWithoutRegistrolaboralInput>, usuarioUncheckedUpdateWithoutRegistrolaboralInput>
  }

  export type rolmenuCreateNestedManyWithoutRolesInput = {
    create?: XOR<rolmenuCreateWithoutRolesInput, rolmenuUncheckedCreateWithoutRolesInput> | rolmenuCreateWithoutRolesInput[] | rolmenuUncheckedCreateWithoutRolesInput[]
    connectOrCreate?: rolmenuCreateOrConnectWithoutRolesInput | rolmenuCreateOrConnectWithoutRolesInput[]
    createMany?: rolmenuCreateManyRolesInputEnvelope
    connect?: rolmenuWhereUniqueInput | rolmenuWhereUniqueInput[]
  }

  export type usurolCreateNestedManyWithoutRolesInput = {
    create?: XOR<usurolCreateWithoutRolesInput, usurolUncheckedCreateWithoutRolesInput> | usurolCreateWithoutRolesInput[] | usurolUncheckedCreateWithoutRolesInput[]
    connectOrCreate?: usurolCreateOrConnectWithoutRolesInput | usurolCreateOrConnectWithoutRolesInput[]
    createMany?: usurolCreateManyRolesInputEnvelope
    connect?: usurolWhereUniqueInput | usurolWhereUniqueInput[]
  }

  export type rolmenuUncheckedCreateNestedManyWithoutRolesInput = {
    create?: XOR<rolmenuCreateWithoutRolesInput, rolmenuUncheckedCreateWithoutRolesInput> | rolmenuCreateWithoutRolesInput[] | rolmenuUncheckedCreateWithoutRolesInput[]
    connectOrCreate?: rolmenuCreateOrConnectWithoutRolesInput | rolmenuCreateOrConnectWithoutRolesInput[]
    createMany?: rolmenuCreateManyRolesInputEnvelope
    connect?: rolmenuWhereUniqueInput | rolmenuWhereUniqueInput[]
  }

  export type usurolUncheckedCreateNestedManyWithoutRolesInput = {
    create?: XOR<usurolCreateWithoutRolesInput, usurolUncheckedCreateWithoutRolesInput> | usurolCreateWithoutRolesInput[] | usurolUncheckedCreateWithoutRolesInput[]
    connectOrCreate?: usurolCreateOrConnectWithoutRolesInput | usurolCreateOrConnectWithoutRolesInput[]
    createMany?: usurolCreateManyRolesInputEnvelope
    connect?: usurolWhereUniqueInput | usurolWhereUniqueInput[]
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type rolmenuUpdateManyWithoutRolesNestedInput = {
    create?: XOR<rolmenuCreateWithoutRolesInput, rolmenuUncheckedCreateWithoutRolesInput> | rolmenuCreateWithoutRolesInput[] | rolmenuUncheckedCreateWithoutRolesInput[]
    connectOrCreate?: rolmenuCreateOrConnectWithoutRolesInput | rolmenuCreateOrConnectWithoutRolesInput[]
    upsert?: rolmenuUpsertWithWhereUniqueWithoutRolesInput | rolmenuUpsertWithWhereUniqueWithoutRolesInput[]
    createMany?: rolmenuCreateManyRolesInputEnvelope
    set?: rolmenuWhereUniqueInput | rolmenuWhereUniqueInput[]
    disconnect?: rolmenuWhereUniqueInput | rolmenuWhereUniqueInput[]
    delete?: rolmenuWhereUniqueInput | rolmenuWhereUniqueInput[]
    connect?: rolmenuWhereUniqueInput | rolmenuWhereUniqueInput[]
    update?: rolmenuUpdateWithWhereUniqueWithoutRolesInput | rolmenuUpdateWithWhereUniqueWithoutRolesInput[]
    updateMany?: rolmenuUpdateManyWithWhereWithoutRolesInput | rolmenuUpdateManyWithWhereWithoutRolesInput[]
    deleteMany?: rolmenuScalarWhereInput | rolmenuScalarWhereInput[]
  }

  export type usurolUpdateManyWithoutRolesNestedInput = {
    create?: XOR<usurolCreateWithoutRolesInput, usurolUncheckedCreateWithoutRolesInput> | usurolCreateWithoutRolesInput[] | usurolUncheckedCreateWithoutRolesInput[]
    connectOrCreate?: usurolCreateOrConnectWithoutRolesInput | usurolCreateOrConnectWithoutRolesInput[]
    upsert?: usurolUpsertWithWhereUniqueWithoutRolesInput | usurolUpsertWithWhereUniqueWithoutRolesInput[]
    createMany?: usurolCreateManyRolesInputEnvelope
    set?: usurolWhereUniqueInput | usurolWhereUniqueInput[]
    disconnect?: usurolWhereUniqueInput | usurolWhereUniqueInput[]
    delete?: usurolWhereUniqueInput | usurolWhereUniqueInput[]
    connect?: usurolWhereUniqueInput | usurolWhereUniqueInput[]
    update?: usurolUpdateWithWhereUniqueWithoutRolesInput | usurolUpdateWithWhereUniqueWithoutRolesInput[]
    updateMany?: usurolUpdateManyWithWhereWithoutRolesInput | usurolUpdateManyWithWhereWithoutRolesInput[]
    deleteMany?: usurolScalarWhereInput | usurolScalarWhereInput[]
  }

  export type rolmenuUncheckedUpdateManyWithoutRolesNestedInput = {
    create?: XOR<rolmenuCreateWithoutRolesInput, rolmenuUncheckedCreateWithoutRolesInput> | rolmenuCreateWithoutRolesInput[] | rolmenuUncheckedCreateWithoutRolesInput[]
    connectOrCreate?: rolmenuCreateOrConnectWithoutRolesInput | rolmenuCreateOrConnectWithoutRolesInput[]
    upsert?: rolmenuUpsertWithWhereUniqueWithoutRolesInput | rolmenuUpsertWithWhereUniqueWithoutRolesInput[]
    createMany?: rolmenuCreateManyRolesInputEnvelope
    set?: rolmenuWhereUniqueInput | rolmenuWhereUniqueInput[]
    disconnect?: rolmenuWhereUniqueInput | rolmenuWhereUniqueInput[]
    delete?: rolmenuWhereUniqueInput | rolmenuWhereUniqueInput[]
    connect?: rolmenuWhereUniqueInput | rolmenuWhereUniqueInput[]
    update?: rolmenuUpdateWithWhereUniqueWithoutRolesInput | rolmenuUpdateWithWhereUniqueWithoutRolesInput[]
    updateMany?: rolmenuUpdateManyWithWhereWithoutRolesInput | rolmenuUpdateManyWithWhereWithoutRolesInput[]
    deleteMany?: rolmenuScalarWhereInput | rolmenuScalarWhereInput[]
  }

  export type usurolUncheckedUpdateManyWithoutRolesNestedInput = {
    create?: XOR<usurolCreateWithoutRolesInput, usurolUncheckedCreateWithoutRolesInput> | usurolCreateWithoutRolesInput[] | usurolUncheckedCreateWithoutRolesInput[]
    connectOrCreate?: usurolCreateOrConnectWithoutRolesInput | usurolCreateOrConnectWithoutRolesInput[]
    upsert?: usurolUpsertWithWhereUniqueWithoutRolesInput | usurolUpsertWithWhereUniqueWithoutRolesInput[]
    createMany?: usurolCreateManyRolesInputEnvelope
    set?: usurolWhereUniqueInput | usurolWhereUniqueInput[]
    disconnect?: usurolWhereUniqueInput | usurolWhereUniqueInput[]
    delete?: usurolWhereUniqueInput | usurolWhereUniqueInput[]
    connect?: usurolWhereUniqueInput | usurolWhereUniqueInput[]
    update?: usurolUpdateWithWhereUniqueWithoutRolesInput | usurolUpdateWithWhereUniqueWithoutRolesInput[]
    updateMany?: usurolUpdateManyWithWhereWithoutRolesInput | usurolUpdateManyWithWhereWithoutRolesInput[]
    deleteMany?: usurolScalarWhereInput | usurolScalarWhereInput[]
  }

  export type menuCreateNestedOneWithoutRolmenuInput = {
    create?: XOR<menuCreateWithoutRolmenuInput, menuUncheckedCreateWithoutRolmenuInput>
    connectOrCreate?: menuCreateOrConnectWithoutRolmenuInput
    connect?: menuWhereUniqueInput
  }

  export type rolesCreateNestedOneWithoutRolmenuInput = {
    create?: XOR<rolesCreateWithoutRolmenuInput, rolesUncheckedCreateWithoutRolmenuInput>
    connectOrCreate?: rolesCreateOrConnectWithoutRolmenuInput
    connect?: rolesWhereUniqueInput
  }

  export type menuUpdateOneRequiredWithoutRolmenuNestedInput = {
    create?: XOR<menuCreateWithoutRolmenuInput, menuUncheckedCreateWithoutRolmenuInput>
    connectOrCreate?: menuCreateOrConnectWithoutRolmenuInput
    upsert?: menuUpsertWithoutRolmenuInput
    connect?: menuWhereUniqueInput
    update?: XOR<XOR<menuUpdateToOneWithWhereWithoutRolmenuInput, menuUpdateWithoutRolmenuInput>, menuUncheckedUpdateWithoutRolmenuInput>
  }

  export type rolesUpdateOneRequiredWithoutRolmenuNestedInput = {
    create?: XOR<rolesCreateWithoutRolmenuInput, rolesUncheckedCreateWithoutRolmenuInput>
    connectOrCreate?: rolesCreateOrConnectWithoutRolmenuInput
    upsert?: rolesUpsertWithoutRolmenuInput
    connect?: rolesWhereUniqueInput
    update?: XOR<XOR<rolesUpdateToOneWithWhereWithoutRolmenuInput, rolesUpdateWithoutRolmenuInput>, rolesUncheckedUpdateWithoutRolmenuInput>
  }

  export type personaCreateNestedOneWithoutTelefonoInput = {
    create?: XOR<personaCreateWithoutTelefonoInput, personaUncheckedCreateWithoutTelefonoInput>
    connectOrCreate?: personaCreateOrConnectWithoutTelefonoInput
    connect?: personaWhereUniqueInput
  }

  export type personaUpdateOneRequiredWithoutTelefonoNestedInput = {
    create?: XOR<personaCreateWithoutTelefonoInput, personaUncheckedCreateWithoutTelefonoInput>
    connectOrCreate?: personaCreateOrConnectWithoutTelefonoInput
    upsert?: personaUpsertWithoutTelefonoInput
    connect?: personaWhereUniqueInput
    update?: XOR<XOR<personaUpdateToOneWithWhereWithoutTelefonoInput, personaUpdateWithoutTelefonoInput>, personaUncheckedUpdateWithoutTelefonoInput>
  }

  export type marcaCreateNestedOneWithoutTerminadoInput = {
    create?: XOR<marcaCreateWithoutTerminadoInput, marcaUncheckedCreateWithoutTerminadoInput>
    connectOrCreate?: marcaCreateOrConnectWithoutTerminadoInput
    connect?: marcaWhereUniqueInput
  }

  export type marcaUpdateOneWithoutTerminadoNestedInput = {
    create?: XOR<marcaCreateWithoutTerminadoInput, marcaUncheckedCreateWithoutTerminadoInput>
    connectOrCreate?: marcaCreateOrConnectWithoutTerminadoInput
    upsert?: marcaUpsertWithoutTerminadoInput
    disconnect?: marcaWhereInput | boolean
    delete?: marcaWhereInput | boolean
    connect?: marcaWhereUniqueInput
    update?: XOR<XOR<marcaUpdateToOneWithWhereWithoutTerminadoInput, marcaUpdateWithoutTerminadoInput>, marcaUncheckedUpdateWithoutTerminadoInput>
  }

  export type arteCreateNestedManyWithoutUsuario_arte_iduTousuarioInput = {
    create?: XOR<arteCreateWithoutUsuario_arte_iduTousuarioInput, arteUncheckedCreateWithoutUsuario_arte_iduTousuarioInput> | arteCreateWithoutUsuario_arte_iduTousuarioInput[] | arteUncheckedCreateWithoutUsuario_arte_iduTousuarioInput[]
    connectOrCreate?: arteCreateOrConnectWithoutUsuario_arte_iduTousuarioInput | arteCreateOrConnectWithoutUsuario_arte_iduTousuarioInput[]
    createMany?: arteCreateManyUsuario_arte_iduTousuarioInputEnvelope
    connect?: arteWhereUniqueInput | arteWhereUniqueInput[]
  }

  export type arteCreateNestedManyWithoutUsuario_arte_iduaTousuarioInput = {
    create?: XOR<arteCreateWithoutUsuario_arte_iduaTousuarioInput, arteUncheckedCreateWithoutUsuario_arte_iduaTousuarioInput> | arteCreateWithoutUsuario_arte_iduaTousuarioInput[] | arteUncheckedCreateWithoutUsuario_arte_iduaTousuarioInput[]
    connectOrCreate?: arteCreateOrConnectWithoutUsuario_arte_iduaTousuarioInput | arteCreateOrConnectWithoutUsuario_arte_iduaTousuarioInput[]
    createMany?: arteCreateManyUsuario_arte_iduaTousuarioInputEnvelope
    connect?: arteWhereUniqueInput | arteWhereUniqueInput[]
  }

  export type cotizacionCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<cotizacionCreateWithoutUsuarioInput, cotizacionUncheckedCreateWithoutUsuarioInput> | cotizacionCreateWithoutUsuarioInput[] | cotizacionUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: cotizacionCreateOrConnectWithoutUsuarioInput | cotizacionCreateOrConnectWithoutUsuarioInput[]
    createMany?: cotizacionCreateManyUsuarioInputEnvelope
    connect?: cotizacionWhereUniqueInput | cotizacionWhereUniqueInput[]
  }

  export type datosCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<datosCreateWithoutUsuarioInput, datosUncheckedCreateWithoutUsuarioInput> | datosCreateWithoutUsuarioInput[] | datosUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: datosCreateOrConnectWithoutUsuarioInput | datosCreateOrConnectWithoutUsuarioInput[]
    createMany?: datosCreateManyUsuarioInputEnvelope
    connect?: datosWhereUniqueInput | datosWhereUniqueInput[]
  }

  export type facturaCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<facturaCreateWithoutUsuarioInput, facturaUncheckedCreateWithoutUsuarioInput> | facturaCreateWithoutUsuarioInput[] | facturaUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: facturaCreateOrConnectWithoutUsuarioInput | facturaCreateOrConnectWithoutUsuarioInput[]
    createMany?: facturaCreateManyUsuarioInputEnvelope
    connect?: facturaWhereUniqueInput | facturaWhereUniqueInput[]
  }

  export type ordentCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<ordentCreateWithoutUsuarioInput, ordentUncheckedCreateWithoutUsuarioInput> | ordentCreateWithoutUsuarioInput[] | ordentUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: ordentCreateOrConnectWithoutUsuarioInput | ordentCreateOrConnectWithoutUsuarioInput[]
    createMany?: ordentCreateManyUsuarioInputEnvelope
    connect?: ordentWhereUniqueInput | ordentWhereUniqueInput[]
  }

  export type registrolaboralCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<registrolaboralCreateWithoutUsuarioInput, registrolaboralUncheckedCreateWithoutUsuarioInput> | registrolaboralCreateWithoutUsuarioInput[] | registrolaboralUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: registrolaboralCreateOrConnectWithoutUsuarioInput | registrolaboralCreateOrConnectWithoutUsuarioInput[]
    createMany?: registrolaboralCreateManyUsuarioInputEnvelope
    connect?: registrolaboralWhereUniqueInput | registrolaboralWhereUniqueInput[]
  }

  export type empresaCreateNestedOneWithoutUsuarioInput = {
    create?: XOR<empresaCreateWithoutUsuarioInput, empresaUncheckedCreateWithoutUsuarioInput>
    connectOrCreate?: empresaCreateOrConnectWithoutUsuarioInput
    connect?: empresaWhereUniqueInput
  }

  export type personaCreateNestedOneWithoutUsuarioInput = {
    create?: XOR<personaCreateWithoutUsuarioInput, personaUncheckedCreateWithoutUsuarioInput>
    connectOrCreate?: personaCreateOrConnectWithoutUsuarioInput
    connect?: personaWhereUniqueInput
  }

  export type usurolCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<usurolCreateWithoutUsuarioInput, usurolUncheckedCreateWithoutUsuarioInput> | usurolCreateWithoutUsuarioInput[] | usurolUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: usurolCreateOrConnectWithoutUsuarioInput | usurolCreateOrConnectWithoutUsuarioInput[]
    createMany?: usurolCreateManyUsuarioInputEnvelope
    connect?: usurolWhereUniqueInput | usurolWhereUniqueInput[]
  }

  export type arteUncheckedCreateNestedManyWithoutUsuario_arte_iduTousuarioInput = {
    create?: XOR<arteCreateWithoutUsuario_arte_iduTousuarioInput, arteUncheckedCreateWithoutUsuario_arte_iduTousuarioInput> | arteCreateWithoutUsuario_arte_iduTousuarioInput[] | arteUncheckedCreateWithoutUsuario_arte_iduTousuarioInput[]
    connectOrCreate?: arteCreateOrConnectWithoutUsuario_arte_iduTousuarioInput | arteCreateOrConnectWithoutUsuario_arte_iduTousuarioInput[]
    createMany?: arteCreateManyUsuario_arte_iduTousuarioInputEnvelope
    connect?: arteWhereUniqueInput | arteWhereUniqueInput[]
  }

  export type arteUncheckedCreateNestedManyWithoutUsuario_arte_iduaTousuarioInput = {
    create?: XOR<arteCreateWithoutUsuario_arte_iduaTousuarioInput, arteUncheckedCreateWithoutUsuario_arte_iduaTousuarioInput> | arteCreateWithoutUsuario_arte_iduaTousuarioInput[] | arteUncheckedCreateWithoutUsuario_arte_iduaTousuarioInput[]
    connectOrCreate?: arteCreateOrConnectWithoutUsuario_arte_iduaTousuarioInput | arteCreateOrConnectWithoutUsuario_arte_iduaTousuarioInput[]
    createMany?: arteCreateManyUsuario_arte_iduaTousuarioInputEnvelope
    connect?: arteWhereUniqueInput | arteWhereUniqueInput[]
  }

  export type cotizacionUncheckedCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<cotizacionCreateWithoutUsuarioInput, cotizacionUncheckedCreateWithoutUsuarioInput> | cotizacionCreateWithoutUsuarioInput[] | cotizacionUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: cotizacionCreateOrConnectWithoutUsuarioInput | cotizacionCreateOrConnectWithoutUsuarioInput[]
    createMany?: cotizacionCreateManyUsuarioInputEnvelope
    connect?: cotizacionWhereUniqueInput | cotizacionWhereUniqueInput[]
  }

  export type datosUncheckedCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<datosCreateWithoutUsuarioInput, datosUncheckedCreateWithoutUsuarioInput> | datosCreateWithoutUsuarioInput[] | datosUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: datosCreateOrConnectWithoutUsuarioInput | datosCreateOrConnectWithoutUsuarioInput[]
    createMany?: datosCreateManyUsuarioInputEnvelope
    connect?: datosWhereUniqueInput | datosWhereUniqueInput[]
  }

  export type facturaUncheckedCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<facturaCreateWithoutUsuarioInput, facturaUncheckedCreateWithoutUsuarioInput> | facturaCreateWithoutUsuarioInput[] | facturaUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: facturaCreateOrConnectWithoutUsuarioInput | facturaCreateOrConnectWithoutUsuarioInput[]
    createMany?: facturaCreateManyUsuarioInputEnvelope
    connect?: facturaWhereUniqueInput | facturaWhereUniqueInput[]
  }

  export type ordentUncheckedCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<ordentCreateWithoutUsuarioInput, ordentUncheckedCreateWithoutUsuarioInput> | ordentCreateWithoutUsuarioInput[] | ordentUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: ordentCreateOrConnectWithoutUsuarioInput | ordentCreateOrConnectWithoutUsuarioInput[]
    createMany?: ordentCreateManyUsuarioInputEnvelope
    connect?: ordentWhereUniqueInput | ordentWhereUniqueInput[]
  }

  export type registrolaboralUncheckedCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<registrolaboralCreateWithoutUsuarioInput, registrolaboralUncheckedCreateWithoutUsuarioInput> | registrolaboralCreateWithoutUsuarioInput[] | registrolaboralUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: registrolaboralCreateOrConnectWithoutUsuarioInput | registrolaboralCreateOrConnectWithoutUsuarioInput[]
    createMany?: registrolaboralCreateManyUsuarioInputEnvelope
    connect?: registrolaboralWhereUniqueInput | registrolaboralWhereUniqueInput[]
  }

  export type usurolUncheckedCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<usurolCreateWithoutUsuarioInput, usurolUncheckedCreateWithoutUsuarioInput> | usurolCreateWithoutUsuarioInput[] | usurolUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: usurolCreateOrConnectWithoutUsuarioInput | usurolCreateOrConnectWithoutUsuarioInput[]
    createMany?: usurolCreateManyUsuarioInputEnvelope
    connect?: usurolWhereUniqueInput | usurolWhereUniqueInput[]
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type arteUpdateManyWithoutUsuario_arte_iduTousuarioNestedInput = {
    create?: XOR<arteCreateWithoutUsuario_arte_iduTousuarioInput, arteUncheckedCreateWithoutUsuario_arte_iduTousuarioInput> | arteCreateWithoutUsuario_arte_iduTousuarioInput[] | arteUncheckedCreateWithoutUsuario_arte_iduTousuarioInput[]
    connectOrCreate?: arteCreateOrConnectWithoutUsuario_arte_iduTousuarioInput | arteCreateOrConnectWithoutUsuario_arte_iduTousuarioInput[]
    upsert?: arteUpsertWithWhereUniqueWithoutUsuario_arte_iduTousuarioInput | arteUpsertWithWhereUniqueWithoutUsuario_arte_iduTousuarioInput[]
    createMany?: arteCreateManyUsuario_arte_iduTousuarioInputEnvelope
    set?: arteWhereUniqueInput | arteWhereUniqueInput[]
    disconnect?: arteWhereUniqueInput | arteWhereUniqueInput[]
    delete?: arteWhereUniqueInput | arteWhereUniqueInput[]
    connect?: arteWhereUniqueInput | arteWhereUniqueInput[]
    update?: arteUpdateWithWhereUniqueWithoutUsuario_arte_iduTousuarioInput | arteUpdateWithWhereUniqueWithoutUsuario_arte_iduTousuarioInput[]
    updateMany?: arteUpdateManyWithWhereWithoutUsuario_arte_iduTousuarioInput | arteUpdateManyWithWhereWithoutUsuario_arte_iduTousuarioInput[]
    deleteMany?: arteScalarWhereInput | arteScalarWhereInput[]
  }

  export type arteUpdateManyWithoutUsuario_arte_iduaTousuarioNestedInput = {
    create?: XOR<arteCreateWithoutUsuario_arte_iduaTousuarioInput, arteUncheckedCreateWithoutUsuario_arte_iduaTousuarioInput> | arteCreateWithoutUsuario_arte_iduaTousuarioInput[] | arteUncheckedCreateWithoutUsuario_arte_iduaTousuarioInput[]
    connectOrCreate?: arteCreateOrConnectWithoutUsuario_arte_iduaTousuarioInput | arteCreateOrConnectWithoutUsuario_arte_iduaTousuarioInput[]
    upsert?: arteUpsertWithWhereUniqueWithoutUsuario_arte_iduaTousuarioInput | arteUpsertWithWhereUniqueWithoutUsuario_arte_iduaTousuarioInput[]
    createMany?: arteCreateManyUsuario_arte_iduaTousuarioInputEnvelope
    set?: arteWhereUniqueInput | arteWhereUniqueInput[]
    disconnect?: arteWhereUniqueInput | arteWhereUniqueInput[]
    delete?: arteWhereUniqueInput | arteWhereUniqueInput[]
    connect?: arteWhereUniqueInput | arteWhereUniqueInput[]
    update?: arteUpdateWithWhereUniqueWithoutUsuario_arte_iduaTousuarioInput | arteUpdateWithWhereUniqueWithoutUsuario_arte_iduaTousuarioInput[]
    updateMany?: arteUpdateManyWithWhereWithoutUsuario_arte_iduaTousuarioInput | arteUpdateManyWithWhereWithoutUsuario_arte_iduaTousuarioInput[]
    deleteMany?: arteScalarWhereInput | arteScalarWhereInput[]
  }

  export type cotizacionUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<cotizacionCreateWithoutUsuarioInput, cotizacionUncheckedCreateWithoutUsuarioInput> | cotizacionCreateWithoutUsuarioInput[] | cotizacionUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: cotizacionCreateOrConnectWithoutUsuarioInput | cotizacionCreateOrConnectWithoutUsuarioInput[]
    upsert?: cotizacionUpsertWithWhereUniqueWithoutUsuarioInput | cotizacionUpsertWithWhereUniqueWithoutUsuarioInput[]
    createMany?: cotizacionCreateManyUsuarioInputEnvelope
    set?: cotizacionWhereUniqueInput | cotizacionWhereUniqueInput[]
    disconnect?: cotizacionWhereUniqueInput | cotizacionWhereUniqueInput[]
    delete?: cotizacionWhereUniqueInput | cotizacionWhereUniqueInput[]
    connect?: cotizacionWhereUniqueInput | cotizacionWhereUniqueInput[]
    update?: cotizacionUpdateWithWhereUniqueWithoutUsuarioInput | cotizacionUpdateWithWhereUniqueWithoutUsuarioInput[]
    updateMany?: cotizacionUpdateManyWithWhereWithoutUsuarioInput | cotizacionUpdateManyWithWhereWithoutUsuarioInput[]
    deleteMany?: cotizacionScalarWhereInput | cotizacionScalarWhereInput[]
  }

  export type datosUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<datosCreateWithoutUsuarioInput, datosUncheckedCreateWithoutUsuarioInput> | datosCreateWithoutUsuarioInput[] | datosUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: datosCreateOrConnectWithoutUsuarioInput | datosCreateOrConnectWithoutUsuarioInput[]
    upsert?: datosUpsertWithWhereUniqueWithoutUsuarioInput | datosUpsertWithWhereUniqueWithoutUsuarioInput[]
    createMany?: datosCreateManyUsuarioInputEnvelope
    set?: datosWhereUniqueInput | datosWhereUniqueInput[]
    disconnect?: datosWhereUniqueInput | datosWhereUniqueInput[]
    delete?: datosWhereUniqueInput | datosWhereUniqueInput[]
    connect?: datosWhereUniqueInput | datosWhereUniqueInput[]
    update?: datosUpdateWithWhereUniqueWithoutUsuarioInput | datosUpdateWithWhereUniqueWithoutUsuarioInput[]
    updateMany?: datosUpdateManyWithWhereWithoutUsuarioInput | datosUpdateManyWithWhereWithoutUsuarioInput[]
    deleteMany?: datosScalarWhereInput | datosScalarWhereInput[]
  }

  export type facturaUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<facturaCreateWithoutUsuarioInput, facturaUncheckedCreateWithoutUsuarioInput> | facturaCreateWithoutUsuarioInput[] | facturaUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: facturaCreateOrConnectWithoutUsuarioInput | facturaCreateOrConnectWithoutUsuarioInput[]
    upsert?: facturaUpsertWithWhereUniqueWithoutUsuarioInput | facturaUpsertWithWhereUniqueWithoutUsuarioInput[]
    createMany?: facturaCreateManyUsuarioInputEnvelope
    set?: facturaWhereUniqueInput | facturaWhereUniqueInput[]
    disconnect?: facturaWhereUniqueInput | facturaWhereUniqueInput[]
    delete?: facturaWhereUniqueInput | facturaWhereUniqueInput[]
    connect?: facturaWhereUniqueInput | facturaWhereUniqueInput[]
    update?: facturaUpdateWithWhereUniqueWithoutUsuarioInput | facturaUpdateWithWhereUniqueWithoutUsuarioInput[]
    updateMany?: facturaUpdateManyWithWhereWithoutUsuarioInput | facturaUpdateManyWithWhereWithoutUsuarioInput[]
    deleteMany?: facturaScalarWhereInput | facturaScalarWhereInput[]
  }

  export type ordentUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<ordentCreateWithoutUsuarioInput, ordentUncheckedCreateWithoutUsuarioInput> | ordentCreateWithoutUsuarioInput[] | ordentUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: ordentCreateOrConnectWithoutUsuarioInput | ordentCreateOrConnectWithoutUsuarioInput[]
    upsert?: ordentUpsertWithWhereUniqueWithoutUsuarioInput | ordentUpsertWithWhereUniqueWithoutUsuarioInput[]
    createMany?: ordentCreateManyUsuarioInputEnvelope
    set?: ordentWhereUniqueInput | ordentWhereUniqueInput[]
    disconnect?: ordentWhereUniqueInput | ordentWhereUniqueInput[]
    delete?: ordentWhereUniqueInput | ordentWhereUniqueInput[]
    connect?: ordentWhereUniqueInput | ordentWhereUniqueInput[]
    update?: ordentUpdateWithWhereUniqueWithoutUsuarioInput | ordentUpdateWithWhereUniqueWithoutUsuarioInput[]
    updateMany?: ordentUpdateManyWithWhereWithoutUsuarioInput | ordentUpdateManyWithWhereWithoutUsuarioInput[]
    deleteMany?: ordentScalarWhereInput | ordentScalarWhereInput[]
  }

  export type registrolaboralUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<registrolaboralCreateWithoutUsuarioInput, registrolaboralUncheckedCreateWithoutUsuarioInput> | registrolaboralCreateWithoutUsuarioInput[] | registrolaboralUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: registrolaboralCreateOrConnectWithoutUsuarioInput | registrolaboralCreateOrConnectWithoutUsuarioInput[]
    upsert?: registrolaboralUpsertWithWhereUniqueWithoutUsuarioInput | registrolaboralUpsertWithWhereUniqueWithoutUsuarioInput[]
    createMany?: registrolaboralCreateManyUsuarioInputEnvelope
    set?: registrolaboralWhereUniqueInput | registrolaboralWhereUniqueInput[]
    disconnect?: registrolaboralWhereUniqueInput | registrolaboralWhereUniqueInput[]
    delete?: registrolaboralWhereUniqueInput | registrolaboralWhereUniqueInput[]
    connect?: registrolaboralWhereUniqueInput | registrolaboralWhereUniqueInput[]
    update?: registrolaboralUpdateWithWhereUniqueWithoutUsuarioInput | registrolaboralUpdateWithWhereUniqueWithoutUsuarioInput[]
    updateMany?: registrolaboralUpdateManyWithWhereWithoutUsuarioInput | registrolaboralUpdateManyWithWhereWithoutUsuarioInput[]
    deleteMany?: registrolaboralScalarWhereInput | registrolaboralScalarWhereInput[]
  }

  export type empresaUpdateOneWithoutUsuarioNestedInput = {
    create?: XOR<empresaCreateWithoutUsuarioInput, empresaUncheckedCreateWithoutUsuarioInput>
    connectOrCreate?: empresaCreateOrConnectWithoutUsuarioInput
    upsert?: empresaUpsertWithoutUsuarioInput
    disconnect?: empresaWhereInput | boolean
    delete?: empresaWhereInput | boolean
    connect?: empresaWhereUniqueInput
    update?: XOR<XOR<empresaUpdateToOneWithWhereWithoutUsuarioInput, empresaUpdateWithoutUsuarioInput>, empresaUncheckedUpdateWithoutUsuarioInput>
  }

  export type personaUpdateOneRequiredWithoutUsuarioNestedInput = {
    create?: XOR<personaCreateWithoutUsuarioInput, personaUncheckedCreateWithoutUsuarioInput>
    connectOrCreate?: personaCreateOrConnectWithoutUsuarioInput
    upsert?: personaUpsertWithoutUsuarioInput
    connect?: personaWhereUniqueInput
    update?: XOR<XOR<personaUpdateToOneWithWhereWithoutUsuarioInput, personaUpdateWithoutUsuarioInput>, personaUncheckedUpdateWithoutUsuarioInput>
  }

  export type usurolUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<usurolCreateWithoutUsuarioInput, usurolUncheckedCreateWithoutUsuarioInput> | usurolCreateWithoutUsuarioInput[] | usurolUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: usurolCreateOrConnectWithoutUsuarioInput | usurolCreateOrConnectWithoutUsuarioInput[]
    upsert?: usurolUpsertWithWhereUniqueWithoutUsuarioInput | usurolUpsertWithWhereUniqueWithoutUsuarioInput[]
    createMany?: usurolCreateManyUsuarioInputEnvelope
    set?: usurolWhereUniqueInput | usurolWhereUniqueInput[]
    disconnect?: usurolWhereUniqueInput | usurolWhereUniqueInput[]
    delete?: usurolWhereUniqueInput | usurolWhereUniqueInput[]
    connect?: usurolWhereUniqueInput | usurolWhereUniqueInput[]
    update?: usurolUpdateWithWhereUniqueWithoutUsuarioInput | usurolUpdateWithWhereUniqueWithoutUsuarioInput[]
    updateMany?: usurolUpdateManyWithWhereWithoutUsuarioInput | usurolUpdateManyWithWhereWithoutUsuarioInput[]
    deleteMany?: usurolScalarWhereInput | usurolScalarWhereInput[]
  }

  export type arteUncheckedUpdateManyWithoutUsuario_arte_iduTousuarioNestedInput = {
    create?: XOR<arteCreateWithoutUsuario_arte_iduTousuarioInput, arteUncheckedCreateWithoutUsuario_arte_iduTousuarioInput> | arteCreateWithoutUsuario_arte_iduTousuarioInput[] | arteUncheckedCreateWithoutUsuario_arte_iduTousuarioInput[]
    connectOrCreate?: arteCreateOrConnectWithoutUsuario_arte_iduTousuarioInput | arteCreateOrConnectWithoutUsuario_arte_iduTousuarioInput[]
    upsert?: arteUpsertWithWhereUniqueWithoutUsuario_arte_iduTousuarioInput | arteUpsertWithWhereUniqueWithoutUsuario_arte_iduTousuarioInput[]
    createMany?: arteCreateManyUsuario_arte_iduTousuarioInputEnvelope
    set?: arteWhereUniqueInput | arteWhereUniqueInput[]
    disconnect?: arteWhereUniqueInput | arteWhereUniqueInput[]
    delete?: arteWhereUniqueInput | arteWhereUniqueInput[]
    connect?: arteWhereUniqueInput | arteWhereUniqueInput[]
    update?: arteUpdateWithWhereUniqueWithoutUsuario_arte_iduTousuarioInput | arteUpdateWithWhereUniqueWithoutUsuario_arte_iduTousuarioInput[]
    updateMany?: arteUpdateManyWithWhereWithoutUsuario_arte_iduTousuarioInput | arteUpdateManyWithWhereWithoutUsuario_arte_iduTousuarioInput[]
    deleteMany?: arteScalarWhereInput | arteScalarWhereInput[]
  }

  export type arteUncheckedUpdateManyWithoutUsuario_arte_iduaTousuarioNestedInput = {
    create?: XOR<arteCreateWithoutUsuario_arte_iduaTousuarioInput, arteUncheckedCreateWithoutUsuario_arte_iduaTousuarioInput> | arteCreateWithoutUsuario_arte_iduaTousuarioInput[] | arteUncheckedCreateWithoutUsuario_arte_iduaTousuarioInput[]
    connectOrCreate?: arteCreateOrConnectWithoutUsuario_arte_iduaTousuarioInput | arteCreateOrConnectWithoutUsuario_arte_iduaTousuarioInput[]
    upsert?: arteUpsertWithWhereUniqueWithoutUsuario_arte_iduaTousuarioInput | arteUpsertWithWhereUniqueWithoutUsuario_arte_iduaTousuarioInput[]
    createMany?: arteCreateManyUsuario_arte_iduaTousuarioInputEnvelope
    set?: arteWhereUniqueInput | arteWhereUniqueInput[]
    disconnect?: arteWhereUniqueInput | arteWhereUniqueInput[]
    delete?: arteWhereUniqueInput | arteWhereUniqueInput[]
    connect?: arteWhereUniqueInput | arteWhereUniqueInput[]
    update?: arteUpdateWithWhereUniqueWithoutUsuario_arte_iduaTousuarioInput | arteUpdateWithWhereUniqueWithoutUsuario_arte_iduaTousuarioInput[]
    updateMany?: arteUpdateManyWithWhereWithoutUsuario_arte_iduaTousuarioInput | arteUpdateManyWithWhereWithoutUsuario_arte_iduaTousuarioInput[]
    deleteMany?: arteScalarWhereInput | arteScalarWhereInput[]
  }

  export type cotizacionUncheckedUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<cotizacionCreateWithoutUsuarioInput, cotizacionUncheckedCreateWithoutUsuarioInput> | cotizacionCreateWithoutUsuarioInput[] | cotizacionUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: cotizacionCreateOrConnectWithoutUsuarioInput | cotizacionCreateOrConnectWithoutUsuarioInput[]
    upsert?: cotizacionUpsertWithWhereUniqueWithoutUsuarioInput | cotizacionUpsertWithWhereUniqueWithoutUsuarioInput[]
    createMany?: cotizacionCreateManyUsuarioInputEnvelope
    set?: cotizacionWhereUniqueInput | cotizacionWhereUniqueInput[]
    disconnect?: cotizacionWhereUniqueInput | cotizacionWhereUniqueInput[]
    delete?: cotizacionWhereUniqueInput | cotizacionWhereUniqueInput[]
    connect?: cotizacionWhereUniqueInput | cotizacionWhereUniqueInput[]
    update?: cotizacionUpdateWithWhereUniqueWithoutUsuarioInput | cotizacionUpdateWithWhereUniqueWithoutUsuarioInput[]
    updateMany?: cotizacionUpdateManyWithWhereWithoutUsuarioInput | cotizacionUpdateManyWithWhereWithoutUsuarioInput[]
    deleteMany?: cotizacionScalarWhereInput | cotizacionScalarWhereInput[]
  }

  export type datosUncheckedUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<datosCreateWithoutUsuarioInput, datosUncheckedCreateWithoutUsuarioInput> | datosCreateWithoutUsuarioInput[] | datosUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: datosCreateOrConnectWithoutUsuarioInput | datosCreateOrConnectWithoutUsuarioInput[]
    upsert?: datosUpsertWithWhereUniqueWithoutUsuarioInput | datosUpsertWithWhereUniqueWithoutUsuarioInput[]
    createMany?: datosCreateManyUsuarioInputEnvelope
    set?: datosWhereUniqueInput | datosWhereUniqueInput[]
    disconnect?: datosWhereUniqueInput | datosWhereUniqueInput[]
    delete?: datosWhereUniqueInput | datosWhereUniqueInput[]
    connect?: datosWhereUniqueInput | datosWhereUniqueInput[]
    update?: datosUpdateWithWhereUniqueWithoutUsuarioInput | datosUpdateWithWhereUniqueWithoutUsuarioInput[]
    updateMany?: datosUpdateManyWithWhereWithoutUsuarioInput | datosUpdateManyWithWhereWithoutUsuarioInput[]
    deleteMany?: datosScalarWhereInput | datosScalarWhereInput[]
  }

  export type facturaUncheckedUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<facturaCreateWithoutUsuarioInput, facturaUncheckedCreateWithoutUsuarioInput> | facturaCreateWithoutUsuarioInput[] | facturaUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: facturaCreateOrConnectWithoutUsuarioInput | facturaCreateOrConnectWithoutUsuarioInput[]
    upsert?: facturaUpsertWithWhereUniqueWithoutUsuarioInput | facturaUpsertWithWhereUniqueWithoutUsuarioInput[]
    createMany?: facturaCreateManyUsuarioInputEnvelope
    set?: facturaWhereUniqueInput | facturaWhereUniqueInput[]
    disconnect?: facturaWhereUniqueInput | facturaWhereUniqueInput[]
    delete?: facturaWhereUniqueInput | facturaWhereUniqueInput[]
    connect?: facturaWhereUniqueInput | facturaWhereUniqueInput[]
    update?: facturaUpdateWithWhereUniqueWithoutUsuarioInput | facturaUpdateWithWhereUniqueWithoutUsuarioInput[]
    updateMany?: facturaUpdateManyWithWhereWithoutUsuarioInput | facturaUpdateManyWithWhereWithoutUsuarioInput[]
    deleteMany?: facturaScalarWhereInput | facturaScalarWhereInput[]
  }

  export type ordentUncheckedUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<ordentCreateWithoutUsuarioInput, ordentUncheckedCreateWithoutUsuarioInput> | ordentCreateWithoutUsuarioInput[] | ordentUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: ordentCreateOrConnectWithoutUsuarioInput | ordentCreateOrConnectWithoutUsuarioInput[]
    upsert?: ordentUpsertWithWhereUniqueWithoutUsuarioInput | ordentUpsertWithWhereUniqueWithoutUsuarioInput[]
    createMany?: ordentCreateManyUsuarioInputEnvelope
    set?: ordentWhereUniqueInput | ordentWhereUniqueInput[]
    disconnect?: ordentWhereUniqueInput | ordentWhereUniqueInput[]
    delete?: ordentWhereUniqueInput | ordentWhereUniqueInput[]
    connect?: ordentWhereUniqueInput | ordentWhereUniqueInput[]
    update?: ordentUpdateWithWhereUniqueWithoutUsuarioInput | ordentUpdateWithWhereUniqueWithoutUsuarioInput[]
    updateMany?: ordentUpdateManyWithWhereWithoutUsuarioInput | ordentUpdateManyWithWhereWithoutUsuarioInput[]
    deleteMany?: ordentScalarWhereInput | ordentScalarWhereInput[]
  }

  export type registrolaboralUncheckedUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<registrolaboralCreateWithoutUsuarioInput, registrolaboralUncheckedCreateWithoutUsuarioInput> | registrolaboralCreateWithoutUsuarioInput[] | registrolaboralUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: registrolaboralCreateOrConnectWithoutUsuarioInput | registrolaboralCreateOrConnectWithoutUsuarioInput[]
    upsert?: registrolaboralUpsertWithWhereUniqueWithoutUsuarioInput | registrolaboralUpsertWithWhereUniqueWithoutUsuarioInput[]
    createMany?: registrolaboralCreateManyUsuarioInputEnvelope
    set?: registrolaboralWhereUniqueInput | registrolaboralWhereUniqueInput[]
    disconnect?: registrolaboralWhereUniqueInput | registrolaboralWhereUniqueInput[]
    delete?: registrolaboralWhereUniqueInput | registrolaboralWhereUniqueInput[]
    connect?: registrolaboralWhereUniqueInput | registrolaboralWhereUniqueInput[]
    update?: registrolaboralUpdateWithWhereUniqueWithoutUsuarioInput | registrolaboralUpdateWithWhereUniqueWithoutUsuarioInput[]
    updateMany?: registrolaboralUpdateManyWithWhereWithoutUsuarioInput | registrolaboralUpdateManyWithWhereWithoutUsuarioInput[]
    deleteMany?: registrolaboralScalarWhereInput | registrolaboralScalarWhereInput[]
  }

  export type usurolUncheckedUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<usurolCreateWithoutUsuarioInput, usurolUncheckedCreateWithoutUsuarioInput> | usurolCreateWithoutUsuarioInput[] | usurolUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: usurolCreateOrConnectWithoutUsuarioInput | usurolCreateOrConnectWithoutUsuarioInput[]
    upsert?: usurolUpsertWithWhereUniqueWithoutUsuarioInput | usurolUpsertWithWhereUniqueWithoutUsuarioInput[]
    createMany?: usurolCreateManyUsuarioInputEnvelope
    set?: usurolWhereUniqueInput | usurolWhereUniqueInput[]
    disconnect?: usurolWhereUniqueInput | usurolWhereUniqueInput[]
    delete?: usurolWhereUniqueInput | usurolWhereUniqueInput[]
    connect?: usurolWhereUniqueInput | usurolWhereUniqueInput[]
    update?: usurolUpdateWithWhereUniqueWithoutUsuarioInput | usurolUpdateWithWhereUniqueWithoutUsuarioInput[]
    updateMany?: usurolUpdateManyWithWhereWithoutUsuarioInput | usurolUpdateManyWithWhereWithoutUsuarioInput[]
    deleteMany?: usurolScalarWhereInput | usurolScalarWhereInput[]
  }

  export type rolesCreateNestedOneWithoutUsurolInput = {
    create?: XOR<rolesCreateWithoutUsurolInput, rolesUncheckedCreateWithoutUsurolInput>
    connectOrCreate?: rolesCreateOrConnectWithoutUsurolInput
    connect?: rolesWhereUniqueInput
  }

  export type usuarioCreateNestedOneWithoutUsurolInput = {
    create?: XOR<usuarioCreateWithoutUsurolInput, usuarioUncheckedCreateWithoutUsurolInput>
    connectOrCreate?: usuarioCreateOrConnectWithoutUsurolInput
    connect?: usuarioWhereUniqueInput
  }

  export type rolesUpdateOneRequiredWithoutUsurolNestedInput = {
    create?: XOR<rolesCreateWithoutUsurolInput, rolesUncheckedCreateWithoutUsurolInput>
    connectOrCreate?: rolesCreateOrConnectWithoutUsurolInput
    upsert?: rolesUpsertWithoutUsurolInput
    connect?: rolesWhereUniqueInput
    update?: XOR<XOR<rolesUpdateToOneWithWhereWithoutUsurolInput, rolesUpdateWithoutUsurolInput>, rolesUncheckedUpdateWithoutUsurolInput>
  }

  export type usuarioUpdateOneRequiredWithoutUsurolNestedInput = {
    create?: XOR<usuarioCreateWithoutUsurolInput, usuarioUncheckedCreateWithoutUsurolInput>
    connectOrCreate?: usuarioCreateOrConnectWithoutUsurolInput
    upsert?: usuarioUpsertWithoutUsurolInput
    connect?: usuarioWhereUniqueInput
    update?: XOR<XOR<usuarioUpdateToOneWithWhereWithoutUsurolInput, usuarioUpdateWithoutUsurolInput>, usuarioUncheckedUpdateWithoutUsurolInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedBytesNullableFilter<$PrismaModel = never> = {
    equals?: Buffer | BytesFieldRefInput<$PrismaModel> | null
    in?: Buffer[] | ListBytesFieldRefInput<$PrismaModel> | null
    notIn?: Buffer[] | ListBytesFieldRefInput<$PrismaModel> | null
    not?: NestedBytesNullableFilter<$PrismaModel> | Buffer | null
  }

  export type NestedBytesNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Buffer | BytesFieldRefInput<$PrismaModel> | null
    in?: Buffer[] | ListBytesFieldRefInput<$PrismaModel> | null
    notIn?: Buffer[] | ListBytesFieldRefInput<$PrismaModel> | null
    not?: NestedBytesNullableWithAggregatesFilter<$PrismaModel> | Buffer | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBytesNullableFilter<$PrismaModel>
    _max?: NestedBytesNullableFilter<$PrismaModel>
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type ordentCreateWithoutArte1Input = {
    fecha?: Date | string | null
    precio?: number | null
    descuento?: number | null
    preciofinal?: number | null
    tiempo?: number | null
    arte?: string | null
    obs?: string | null
    estado?: string | null
    factura?: string | null
    detot?: detotCreateNestedManyWithoutOrdentInput
    factura1?: facturaCreateNestedManyWithoutOrdentInput
    cliente?: clienteCreateNestedOneWithoutOrdentInput
    cotizacion?: cotizacionCreateNestedOneWithoutOrdentInput
    usuario?: usuarioCreateNestedOneWithoutOrdentInput
    pago?: pagoCreateNestedManyWithoutOrdentInput
  }

  export type ordentUncheckedCreateWithoutArte1Input = {
    idot?: number
    idu?: number | null
    idcli?: number | null
    idcot?: number | null
    fecha?: Date | string | null
    precio?: number | null
    descuento?: number | null
    preciofinal?: number | null
    tiempo?: number | null
    arte?: string | null
    obs?: string | null
    estado?: string | null
    factura?: string | null
    detot?: detotUncheckedCreateNestedManyWithoutOrdentInput
    factura1?: facturaUncheckedCreateNestedManyWithoutOrdentInput
    pago?: pagoUncheckedCreateNestedManyWithoutOrdentInput
  }

  export type ordentCreateOrConnectWithoutArte1Input = {
    where: ordentWhereUniqueInput
    create: XOR<ordentCreateWithoutArte1Input, ordentUncheckedCreateWithoutArte1Input>
  }

  export type usuarioCreateWithoutArte_arte_iduTousuarioInput = {
    sexo: string
    foto?: Buffer | null
    fecnac: Date | string
    estado?: boolean | null
    base64?: string | null
    arte_arte_iduaTousuario?: arteCreateNestedManyWithoutUsuario_arte_iduaTousuarioInput
    cotizacion?: cotizacionCreateNestedManyWithoutUsuarioInput
    datos?: datosCreateNestedManyWithoutUsuarioInput
    factura?: facturaCreateNestedManyWithoutUsuarioInput
    ordent?: ordentCreateNestedManyWithoutUsuarioInput
    registrolaboral?: registrolaboralCreateNestedManyWithoutUsuarioInput
    empresa?: empresaCreateNestedOneWithoutUsuarioInput
    persona: personaCreateNestedOneWithoutUsuarioInput
    usurol?: usurolCreateNestedManyWithoutUsuarioInput
  }

  export type usuarioUncheckedCreateWithoutArte_arte_iduTousuarioInput = {
    idu?: number
    sexo: string
    foto?: Buffer | null
    fecnac: Date | string
    idpe: number
    estado?: boolean | null
    idem?: number | null
    base64?: string | null
    arte_arte_iduaTousuario?: arteUncheckedCreateNestedManyWithoutUsuario_arte_iduaTousuarioInput
    cotizacion?: cotizacionUncheckedCreateNestedManyWithoutUsuarioInput
    datos?: datosUncheckedCreateNestedManyWithoutUsuarioInput
    factura?: facturaUncheckedCreateNestedManyWithoutUsuarioInput
    ordent?: ordentUncheckedCreateNestedManyWithoutUsuarioInput
    registrolaboral?: registrolaboralUncheckedCreateNestedManyWithoutUsuarioInput
    usurol?: usurolUncheckedCreateNestedManyWithoutUsuarioInput
  }

  export type usuarioCreateOrConnectWithoutArte_arte_iduTousuarioInput = {
    where: usuarioWhereUniqueInput
    create: XOR<usuarioCreateWithoutArte_arte_iduTousuarioInput, usuarioUncheckedCreateWithoutArte_arte_iduTousuarioInput>
  }

  export type usuarioCreateWithoutArte_arte_iduaTousuarioInput = {
    sexo: string
    foto?: Buffer | null
    fecnac: Date | string
    estado?: boolean | null
    base64?: string | null
    arte_arte_iduTousuario?: arteCreateNestedManyWithoutUsuario_arte_iduTousuarioInput
    cotizacion?: cotizacionCreateNestedManyWithoutUsuarioInput
    datos?: datosCreateNestedManyWithoutUsuarioInput
    factura?: facturaCreateNestedManyWithoutUsuarioInput
    ordent?: ordentCreateNestedManyWithoutUsuarioInput
    registrolaboral?: registrolaboralCreateNestedManyWithoutUsuarioInput
    empresa?: empresaCreateNestedOneWithoutUsuarioInput
    persona: personaCreateNestedOneWithoutUsuarioInput
    usurol?: usurolCreateNestedManyWithoutUsuarioInput
  }

  export type usuarioUncheckedCreateWithoutArte_arte_iduaTousuarioInput = {
    idu?: number
    sexo: string
    foto?: Buffer | null
    fecnac: Date | string
    idpe: number
    estado?: boolean | null
    idem?: number | null
    base64?: string | null
    arte_arte_iduTousuario?: arteUncheckedCreateNestedManyWithoutUsuario_arte_iduTousuarioInput
    cotizacion?: cotizacionUncheckedCreateNestedManyWithoutUsuarioInput
    datos?: datosUncheckedCreateNestedManyWithoutUsuarioInput
    factura?: facturaUncheckedCreateNestedManyWithoutUsuarioInput
    ordent?: ordentUncheckedCreateNestedManyWithoutUsuarioInput
    registrolaboral?: registrolaboralUncheckedCreateNestedManyWithoutUsuarioInput
    usurol?: usurolUncheckedCreateNestedManyWithoutUsuarioInput
  }

  export type usuarioCreateOrConnectWithoutArte_arte_iduaTousuarioInput = {
    where: usuarioWhereUniqueInput
    create: XOR<usuarioCreateWithoutArte_arte_iduaTousuarioInput, usuarioUncheckedCreateWithoutArte_arte_iduaTousuarioInput>
  }

  export type ordentUpsertWithoutArte1Input = {
    update: XOR<ordentUpdateWithoutArte1Input, ordentUncheckedUpdateWithoutArte1Input>
    create: XOR<ordentCreateWithoutArte1Input, ordentUncheckedCreateWithoutArte1Input>
    where?: ordentWhereInput
  }

  export type ordentUpdateToOneWithWhereWithoutArte1Input = {
    where?: ordentWhereInput
    data: XOR<ordentUpdateWithoutArte1Input, ordentUncheckedUpdateWithoutArte1Input>
  }

  export type ordentUpdateWithoutArte1Input = {
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    precio?: NullableFloatFieldUpdateOperationsInput | number | null
    descuento?: NullableFloatFieldUpdateOperationsInput | number | null
    preciofinal?: NullableFloatFieldUpdateOperationsInput | number | null
    tiempo?: NullableIntFieldUpdateOperationsInput | number | null
    arte?: NullableStringFieldUpdateOperationsInput | string | null
    obs?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableStringFieldUpdateOperationsInput | string | null
    factura?: NullableStringFieldUpdateOperationsInput | string | null
    detot?: detotUpdateManyWithoutOrdentNestedInput
    factura1?: facturaUpdateManyWithoutOrdentNestedInput
    cliente?: clienteUpdateOneWithoutOrdentNestedInput
    cotizacion?: cotizacionUpdateOneWithoutOrdentNestedInput
    usuario?: usuarioUpdateOneWithoutOrdentNestedInput
    pago?: pagoUpdateManyWithoutOrdentNestedInput
  }

  export type ordentUncheckedUpdateWithoutArte1Input = {
    idot?: IntFieldUpdateOperationsInput | number
    idu?: NullableIntFieldUpdateOperationsInput | number | null
    idcli?: NullableIntFieldUpdateOperationsInput | number | null
    idcot?: NullableIntFieldUpdateOperationsInput | number | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    precio?: NullableFloatFieldUpdateOperationsInput | number | null
    descuento?: NullableFloatFieldUpdateOperationsInput | number | null
    preciofinal?: NullableFloatFieldUpdateOperationsInput | number | null
    tiempo?: NullableIntFieldUpdateOperationsInput | number | null
    arte?: NullableStringFieldUpdateOperationsInput | string | null
    obs?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableStringFieldUpdateOperationsInput | string | null
    factura?: NullableStringFieldUpdateOperationsInput | string | null
    detot?: detotUncheckedUpdateManyWithoutOrdentNestedInput
    factura1?: facturaUncheckedUpdateManyWithoutOrdentNestedInput
    pago?: pagoUncheckedUpdateManyWithoutOrdentNestedInput
  }

  export type usuarioUpsertWithoutArte_arte_iduTousuarioInput = {
    update: XOR<usuarioUpdateWithoutArte_arte_iduTousuarioInput, usuarioUncheckedUpdateWithoutArte_arte_iduTousuarioInput>
    create: XOR<usuarioCreateWithoutArte_arte_iduTousuarioInput, usuarioUncheckedCreateWithoutArte_arte_iduTousuarioInput>
    where?: usuarioWhereInput
  }

  export type usuarioUpdateToOneWithWhereWithoutArte_arte_iduTousuarioInput = {
    where?: usuarioWhereInput
    data: XOR<usuarioUpdateWithoutArte_arte_iduTousuarioInput, usuarioUncheckedUpdateWithoutArte_arte_iduTousuarioInput>
  }

  export type usuarioUpdateWithoutArte_arte_iduTousuarioInput = {
    sexo?: StringFieldUpdateOperationsInput | string
    foto?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    fecnac?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    base64?: NullableStringFieldUpdateOperationsInput | string | null
    arte_arte_iduaTousuario?: arteUpdateManyWithoutUsuario_arte_iduaTousuarioNestedInput
    cotizacion?: cotizacionUpdateManyWithoutUsuarioNestedInput
    datos?: datosUpdateManyWithoutUsuarioNestedInput
    factura?: facturaUpdateManyWithoutUsuarioNestedInput
    ordent?: ordentUpdateManyWithoutUsuarioNestedInput
    registrolaboral?: registrolaboralUpdateManyWithoutUsuarioNestedInput
    empresa?: empresaUpdateOneWithoutUsuarioNestedInput
    persona?: personaUpdateOneRequiredWithoutUsuarioNestedInput
    usurol?: usurolUpdateManyWithoutUsuarioNestedInput
  }

  export type usuarioUncheckedUpdateWithoutArte_arte_iduTousuarioInput = {
    idu?: IntFieldUpdateOperationsInput | number
    sexo?: StringFieldUpdateOperationsInput | string
    foto?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    fecnac?: DateTimeFieldUpdateOperationsInput | Date | string
    idpe?: IntFieldUpdateOperationsInput | number
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    idem?: NullableIntFieldUpdateOperationsInput | number | null
    base64?: NullableStringFieldUpdateOperationsInput | string | null
    arte_arte_iduaTousuario?: arteUncheckedUpdateManyWithoutUsuario_arte_iduaTousuarioNestedInput
    cotizacion?: cotizacionUncheckedUpdateManyWithoutUsuarioNestedInput
    datos?: datosUncheckedUpdateManyWithoutUsuarioNestedInput
    factura?: facturaUncheckedUpdateManyWithoutUsuarioNestedInput
    ordent?: ordentUncheckedUpdateManyWithoutUsuarioNestedInput
    registrolaboral?: registrolaboralUncheckedUpdateManyWithoutUsuarioNestedInput
    usurol?: usurolUncheckedUpdateManyWithoutUsuarioNestedInput
  }

  export type usuarioUpsertWithoutArte_arte_iduaTousuarioInput = {
    update: XOR<usuarioUpdateWithoutArte_arte_iduaTousuarioInput, usuarioUncheckedUpdateWithoutArte_arte_iduaTousuarioInput>
    create: XOR<usuarioCreateWithoutArte_arte_iduaTousuarioInput, usuarioUncheckedCreateWithoutArte_arte_iduaTousuarioInput>
    where?: usuarioWhereInput
  }

  export type usuarioUpdateToOneWithWhereWithoutArte_arte_iduaTousuarioInput = {
    where?: usuarioWhereInput
    data: XOR<usuarioUpdateWithoutArte_arte_iduaTousuarioInput, usuarioUncheckedUpdateWithoutArte_arte_iduaTousuarioInput>
  }

  export type usuarioUpdateWithoutArte_arte_iduaTousuarioInput = {
    sexo?: StringFieldUpdateOperationsInput | string
    foto?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    fecnac?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    base64?: NullableStringFieldUpdateOperationsInput | string | null
    arte_arte_iduTousuario?: arteUpdateManyWithoutUsuario_arte_iduTousuarioNestedInput
    cotizacion?: cotizacionUpdateManyWithoutUsuarioNestedInput
    datos?: datosUpdateManyWithoutUsuarioNestedInput
    factura?: facturaUpdateManyWithoutUsuarioNestedInput
    ordent?: ordentUpdateManyWithoutUsuarioNestedInput
    registrolaboral?: registrolaboralUpdateManyWithoutUsuarioNestedInput
    empresa?: empresaUpdateOneWithoutUsuarioNestedInput
    persona?: personaUpdateOneRequiredWithoutUsuarioNestedInput
    usurol?: usurolUpdateManyWithoutUsuarioNestedInput
  }

  export type usuarioUncheckedUpdateWithoutArte_arte_iduaTousuarioInput = {
    idu?: IntFieldUpdateOperationsInput | number
    sexo?: StringFieldUpdateOperationsInput | string
    foto?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    fecnac?: DateTimeFieldUpdateOperationsInput | Date | string
    idpe?: IntFieldUpdateOperationsInput | number
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    idem?: NullableIntFieldUpdateOperationsInput | number | null
    base64?: NullableStringFieldUpdateOperationsInput | string | null
    arte_arte_iduTousuario?: arteUncheckedUpdateManyWithoutUsuario_arte_iduTousuarioNestedInput
    cotizacion?: cotizacionUncheckedUpdateManyWithoutUsuarioNestedInput
    datos?: datosUncheckedUpdateManyWithoutUsuarioNestedInput
    factura?: facturaUncheckedUpdateManyWithoutUsuarioNestedInput
    ordent?: ordentUncheckedUpdateManyWithoutUsuarioNestedInput
    registrolaboral?: registrolaboralUncheckedUpdateManyWithoutUsuarioNestedInput
    usurol?: usurolUncheckedUpdateManyWithoutUsuarioNestedInput
  }

  export type personaCreateWithoutClienteInput = {
    ci: string
    nombre: string
    ap: string
    am?: string | null
    direccion?: string | null
    email?: string | null
    estado?: boolean | null
    base64?: string | null
    empresa?: empresaCreateNestedManyWithoutPersonaInput
    proveedor?: proveedorCreateNestedManyWithoutPersonaInput
    telefono?: telefonoCreateNestedManyWithoutPersonaInput
    usuario?: usuarioCreateNestedManyWithoutPersonaInput
  }

  export type personaUncheckedCreateWithoutClienteInput = {
    idpe?: number
    ci: string
    nombre: string
    ap: string
    am?: string | null
    direccion?: string | null
    email?: string | null
    estado?: boolean | null
    base64?: string | null
    empresa?: empresaUncheckedCreateNestedManyWithoutPersonaInput
    proveedor?: proveedorUncheckedCreateNestedManyWithoutPersonaInput
    telefono?: telefonoUncheckedCreateNestedManyWithoutPersonaInput
    usuario?: usuarioUncheckedCreateNestedManyWithoutPersonaInput
  }

  export type personaCreateOrConnectWithoutClienteInput = {
    where: personaWhereUniqueInput
    create: XOR<personaCreateWithoutClienteInput, personaUncheckedCreateWithoutClienteInput>
  }

  export type cotizacionCreateWithoutClienteInput = {
    fecha?: Date | string | null
    precio?: number | null
    descuento?: number | null
    preciofinal?: number | null
    tiempo?: number | null
    arte?: string | null
    obs?: string | null
    estado?: string | null
    usuario?: usuarioCreateNestedOneWithoutCotizacionInput
    detcot?: detcotCreateNestedManyWithoutCotizacionInput
    ordent?: ordentCreateNestedManyWithoutCotizacionInput
  }

  export type cotizacionUncheckedCreateWithoutClienteInput = {
    idcot?: number
    idu?: number | null
    fecha?: Date | string | null
    precio?: number | null
    descuento?: number | null
    preciofinal?: number | null
    tiempo?: number | null
    arte?: string | null
    obs?: string | null
    estado?: string | null
    detcot?: detcotUncheckedCreateNestedManyWithoutCotizacionInput
    ordent?: ordentUncheckedCreateNestedManyWithoutCotizacionInput
  }

  export type cotizacionCreateOrConnectWithoutClienteInput = {
    where: cotizacionWhereUniqueInput
    create: XOR<cotizacionCreateWithoutClienteInput, cotizacionUncheckedCreateWithoutClienteInput>
  }

  export type cotizacionCreateManyClienteInputEnvelope = {
    data: cotizacionCreateManyClienteInput | cotizacionCreateManyClienteInput[]
    skipDuplicates?: boolean
  }

  export type ordentCreateWithoutClienteInput = {
    fecha?: Date | string | null
    precio?: number | null
    descuento?: number | null
    preciofinal?: number | null
    tiempo?: number | null
    arte?: string | null
    obs?: string | null
    estado?: string | null
    factura?: string | null
    arte1?: arteCreateNestedManyWithoutOrdentInput
    detot?: detotCreateNestedManyWithoutOrdentInput
    factura1?: facturaCreateNestedManyWithoutOrdentInput
    cotizacion?: cotizacionCreateNestedOneWithoutOrdentInput
    usuario?: usuarioCreateNestedOneWithoutOrdentInput
    pago?: pagoCreateNestedManyWithoutOrdentInput
  }

  export type ordentUncheckedCreateWithoutClienteInput = {
    idot?: number
    idu?: number | null
    idcot?: number | null
    fecha?: Date | string | null
    precio?: number | null
    descuento?: number | null
    preciofinal?: number | null
    tiempo?: number | null
    arte?: string | null
    obs?: string | null
    estado?: string | null
    factura?: string | null
    arte1?: arteUncheckedCreateNestedManyWithoutOrdentInput
    detot?: detotUncheckedCreateNestedManyWithoutOrdentInput
    factura1?: facturaUncheckedCreateNestedManyWithoutOrdentInput
    pago?: pagoUncheckedCreateNestedManyWithoutOrdentInput
  }

  export type ordentCreateOrConnectWithoutClienteInput = {
    where: ordentWhereUniqueInput
    create: XOR<ordentCreateWithoutClienteInput, ordentUncheckedCreateWithoutClienteInput>
  }

  export type ordentCreateManyClienteInputEnvelope = {
    data: ordentCreateManyClienteInput | ordentCreateManyClienteInput[]
    skipDuplicates?: boolean
  }

  export type personaUpsertWithoutClienteInput = {
    update: XOR<personaUpdateWithoutClienteInput, personaUncheckedUpdateWithoutClienteInput>
    create: XOR<personaCreateWithoutClienteInput, personaUncheckedCreateWithoutClienteInput>
    where?: personaWhereInput
  }

  export type personaUpdateToOneWithWhereWithoutClienteInput = {
    where?: personaWhereInput
    data: XOR<personaUpdateWithoutClienteInput, personaUncheckedUpdateWithoutClienteInput>
  }

  export type personaUpdateWithoutClienteInput = {
    ci?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    ap?: StringFieldUpdateOperationsInput | string
    am?: NullableStringFieldUpdateOperationsInput | string | null
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    base64?: NullableStringFieldUpdateOperationsInput | string | null
    empresa?: empresaUpdateManyWithoutPersonaNestedInput
    proveedor?: proveedorUpdateManyWithoutPersonaNestedInput
    telefono?: telefonoUpdateManyWithoutPersonaNestedInput
    usuario?: usuarioUpdateManyWithoutPersonaNestedInput
  }

  export type personaUncheckedUpdateWithoutClienteInput = {
    idpe?: IntFieldUpdateOperationsInput | number
    ci?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    ap?: StringFieldUpdateOperationsInput | string
    am?: NullableStringFieldUpdateOperationsInput | string | null
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    base64?: NullableStringFieldUpdateOperationsInput | string | null
    empresa?: empresaUncheckedUpdateManyWithoutPersonaNestedInput
    proveedor?: proveedorUncheckedUpdateManyWithoutPersonaNestedInput
    telefono?: telefonoUncheckedUpdateManyWithoutPersonaNestedInput
    usuario?: usuarioUncheckedUpdateManyWithoutPersonaNestedInput
  }

  export type cotizacionUpsertWithWhereUniqueWithoutClienteInput = {
    where: cotizacionWhereUniqueInput
    update: XOR<cotizacionUpdateWithoutClienteInput, cotizacionUncheckedUpdateWithoutClienteInput>
    create: XOR<cotizacionCreateWithoutClienteInput, cotizacionUncheckedCreateWithoutClienteInput>
  }

  export type cotizacionUpdateWithWhereUniqueWithoutClienteInput = {
    where: cotizacionWhereUniqueInput
    data: XOR<cotizacionUpdateWithoutClienteInput, cotizacionUncheckedUpdateWithoutClienteInput>
  }

  export type cotizacionUpdateManyWithWhereWithoutClienteInput = {
    where: cotizacionScalarWhereInput
    data: XOR<cotizacionUpdateManyMutationInput, cotizacionUncheckedUpdateManyWithoutClienteInput>
  }

  export type cotizacionScalarWhereInput = {
    AND?: cotizacionScalarWhereInput | cotizacionScalarWhereInput[]
    OR?: cotizacionScalarWhereInput[]
    NOT?: cotizacionScalarWhereInput | cotizacionScalarWhereInput[]
    idcot?: IntFilter<"cotizacion"> | number
    idu?: IntNullableFilter<"cotizacion"> | number | null
    idcli?: IntNullableFilter<"cotizacion"> | number | null
    fecha?: DateTimeNullableFilter<"cotizacion"> | Date | string | null
    precio?: FloatNullableFilter<"cotizacion"> | number | null
    descuento?: FloatNullableFilter<"cotizacion"> | number | null
    preciofinal?: FloatNullableFilter<"cotizacion"> | number | null
    tiempo?: IntNullableFilter<"cotizacion"> | number | null
    arte?: StringNullableFilter<"cotizacion"> | string | null
    obs?: StringNullableFilter<"cotizacion"> | string | null
    estado?: StringNullableFilter<"cotizacion"> | string | null
  }

  export type ordentUpsertWithWhereUniqueWithoutClienteInput = {
    where: ordentWhereUniqueInput
    update: XOR<ordentUpdateWithoutClienteInput, ordentUncheckedUpdateWithoutClienteInput>
    create: XOR<ordentCreateWithoutClienteInput, ordentUncheckedCreateWithoutClienteInput>
  }

  export type ordentUpdateWithWhereUniqueWithoutClienteInput = {
    where: ordentWhereUniqueInput
    data: XOR<ordentUpdateWithoutClienteInput, ordentUncheckedUpdateWithoutClienteInput>
  }

  export type ordentUpdateManyWithWhereWithoutClienteInput = {
    where: ordentScalarWhereInput
    data: XOR<ordentUpdateManyMutationInput, ordentUncheckedUpdateManyWithoutClienteInput>
  }

  export type ordentScalarWhereInput = {
    AND?: ordentScalarWhereInput | ordentScalarWhereInput[]
    OR?: ordentScalarWhereInput[]
    NOT?: ordentScalarWhereInput | ordentScalarWhereInput[]
    idot?: IntFilter<"ordent"> | number
    idu?: IntNullableFilter<"ordent"> | number | null
    idcli?: IntNullableFilter<"ordent"> | number | null
    idcot?: IntNullableFilter<"ordent"> | number | null
    fecha?: DateTimeNullableFilter<"ordent"> | Date | string | null
    precio?: FloatNullableFilter<"ordent"> | number | null
    descuento?: FloatNullableFilter<"ordent"> | number | null
    preciofinal?: FloatNullableFilter<"ordent"> | number | null
    tiempo?: IntNullableFilter<"ordent"> | number | null
    arte?: StringNullableFilter<"ordent"> | string | null
    obs?: StringNullableFilter<"ordent"> | string | null
    estado?: StringNullableFilter<"ordent"> | string | null
    factura?: StringNullableFilter<"ordent"> | string | null
  }

  export type marcaCreateWithoutColorInput = {
    nom?: string | null
    des?: string | null
    estado?: boolean | null
    producto?: productoCreateNestedManyWithoutMarcaInput
    terminado?: terminadoCreateNestedManyWithoutMarcaInput
  }

  export type marcaUncheckedCreateWithoutColorInput = {
    idmar?: number
    nom?: string | null
    des?: string | null
    estado?: boolean | null
    producto?: productoUncheckedCreateNestedManyWithoutMarcaInput
    terminado?: terminadoUncheckedCreateNestedManyWithoutMarcaInput
  }

  export type marcaCreateOrConnectWithoutColorInput = {
    where: marcaWhereUniqueInput
    create: XOR<marcaCreateWithoutColorInput, marcaUncheckedCreateWithoutColorInput>
  }

  export type marcaUpsertWithoutColorInput = {
    update: XOR<marcaUpdateWithoutColorInput, marcaUncheckedUpdateWithoutColorInput>
    create: XOR<marcaCreateWithoutColorInput, marcaUncheckedCreateWithoutColorInput>
    where?: marcaWhereInput
  }

  export type marcaUpdateToOneWithWhereWithoutColorInput = {
    where?: marcaWhereInput
    data: XOR<marcaUpdateWithoutColorInput, marcaUncheckedUpdateWithoutColorInput>
  }

  export type marcaUpdateWithoutColorInput = {
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    des?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    producto?: productoUpdateManyWithoutMarcaNestedInput
    terminado?: terminadoUpdateManyWithoutMarcaNestedInput
  }

  export type marcaUncheckedUpdateWithoutColorInput = {
    idmar?: IntFieldUpdateOperationsInput | number
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    des?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    producto?: productoUncheckedUpdateManyWithoutMarcaNestedInput
    terminado?: terminadoUncheckedUpdateManyWithoutMarcaNestedInput
  }

  export type clienteCreateWithoutCotizacionInput = {
    estado?: boolean | null
    persona: personaCreateNestedOneWithoutClienteInput
    ordent?: ordentCreateNestedManyWithoutClienteInput
  }

  export type clienteUncheckedCreateWithoutCotizacionInput = {
    idcli?: number
    idpe: number
    estado?: boolean | null
    ordent?: ordentUncheckedCreateNestedManyWithoutClienteInput
  }

  export type clienteCreateOrConnectWithoutCotizacionInput = {
    where: clienteWhereUniqueInput
    create: XOR<clienteCreateWithoutCotizacionInput, clienteUncheckedCreateWithoutCotizacionInput>
  }

  export type usuarioCreateWithoutCotizacionInput = {
    sexo: string
    foto?: Buffer | null
    fecnac: Date | string
    estado?: boolean | null
    base64?: string | null
    arte_arte_iduTousuario?: arteCreateNestedManyWithoutUsuario_arte_iduTousuarioInput
    arte_arte_iduaTousuario?: arteCreateNestedManyWithoutUsuario_arte_iduaTousuarioInput
    datos?: datosCreateNestedManyWithoutUsuarioInput
    factura?: facturaCreateNestedManyWithoutUsuarioInput
    ordent?: ordentCreateNestedManyWithoutUsuarioInput
    registrolaboral?: registrolaboralCreateNestedManyWithoutUsuarioInput
    empresa?: empresaCreateNestedOneWithoutUsuarioInput
    persona: personaCreateNestedOneWithoutUsuarioInput
    usurol?: usurolCreateNestedManyWithoutUsuarioInput
  }

  export type usuarioUncheckedCreateWithoutCotizacionInput = {
    idu?: number
    sexo: string
    foto?: Buffer | null
    fecnac: Date | string
    idpe: number
    estado?: boolean | null
    idem?: number | null
    base64?: string | null
    arte_arte_iduTousuario?: arteUncheckedCreateNestedManyWithoutUsuario_arte_iduTousuarioInput
    arte_arte_iduaTousuario?: arteUncheckedCreateNestedManyWithoutUsuario_arte_iduaTousuarioInput
    datos?: datosUncheckedCreateNestedManyWithoutUsuarioInput
    factura?: facturaUncheckedCreateNestedManyWithoutUsuarioInput
    ordent?: ordentUncheckedCreateNestedManyWithoutUsuarioInput
    registrolaboral?: registrolaboralUncheckedCreateNestedManyWithoutUsuarioInput
    usurol?: usurolUncheckedCreateNestedManyWithoutUsuarioInput
  }

  export type usuarioCreateOrConnectWithoutCotizacionInput = {
    where: usuarioWhereUniqueInput
    create: XOR<usuarioCreateWithoutCotizacionInput, usuarioUncheckedCreateWithoutCotizacionInput>
  }

  export type detcotCreateWithoutCotizacionInput = {
    cant?: number | null
    punit?: number | null
    stotal?: number | null
    material?: string | null
    gr?: string | null
    tintas?: string | null
    estado?: boolean | null
    producto?: productoCreateNestedOneWithoutDetcotInput
  }

  export type detcotUncheckedCreateWithoutCotizacionInput = {
    iddetcot?: number
    idpro?: number | null
    cant?: number | null
    punit?: number | null
    stotal?: number | null
    material?: string | null
    gr?: string | null
    tintas?: string | null
    estado?: boolean | null
  }

  export type detcotCreateOrConnectWithoutCotizacionInput = {
    where: detcotWhereUniqueInput
    create: XOR<detcotCreateWithoutCotizacionInput, detcotUncheckedCreateWithoutCotizacionInput>
  }

  export type detcotCreateManyCotizacionInputEnvelope = {
    data: detcotCreateManyCotizacionInput | detcotCreateManyCotizacionInput[]
    skipDuplicates?: boolean
  }

  export type ordentCreateWithoutCotizacionInput = {
    fecha?: Date | string | null
    precio?: number | null
    descuento?: number | null
    preciofinal?: number | null
    tiempo?: number | null
    arte?: string | null
    obs?: string | null
    estado?: string | null
    factura?: string | null
    arte1?: arteCreateNestedManyWithoutOrdentInput
    detot?: detotCreateNestedManyWithoutOrdentInput
    factura1?: facturaCreateNestedManyWithoutOrdentInput
    cliente?: clienteCreateNestedOneWithoutOrdentInput
    usuario?: usuarioCreateNestedOneWithoutOrdentInput
    pago?: pagoCreateNestedManyWithoutOrdentInput
  }

  export type ordentUncheckedCreateWithoutCotizacionInput = {
    idot?: number
    idu?: number | null
    idcli?: number | null
    fecha?: Date | string | null
    precio?: number | null
    descuento?: number | null
    preciofinal?: number | null
    tiempo?: number | null
    arte?: string | null
    obs?: string | null
    estado?: string | null
    factura?: string | null
    arte1?: arteUncheckedCreateNestedManyWithoutOrdentInput
    detot?: detotUncheckedCreateNestedManyWithoutOrdentInput
    factura1?: facturaUncheckedCreateNestedManyWithoutOrdentInput
    pago?: pagoUncheckedCreateNestedManyWithoutOrdentInput
  }

  export type ordentCreateOrConnectWithoutCotizacionInput = {
    where: ordentWhereUniqueInput
    create: XOR<ordentCreateWithoutCotizacionInput, ordentUncheckedCreateWithoutCotizacionInput>
  }

  export type ordentCreateManyCotizacionInputEnvelope = {
    data: ordentCreateManyCotizacionInput | ordentCreateManyCotizacionInput[]
    skipDuplicates?: boolean
  }

  export type clienteUpsertWithoutCotizacionInput = {
    update: XOR<clienteUpdateWithoutCotizacionInput, clienteUncheckedUpdateWithoutCotizacionInput>
    create: XOR<clienteCreateWithoutCotizacionInput, clienteUncheckedCreateWithoutCotizacionInput>
    where?: clienteWhereInput
  }

  export type clienteUpdateToOneWithWhereWithoutCotizacionInput = {
    where?: clienteWhereInput
    data: XOR<clienteUpdateWithoutCotizacionInput, clienteUncheckedUpdateWithoutCotizacionInput>
  }

  export type clienteUpdateWithoutCotizacionInput = {
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    persona?: personaUpdateOneRequiredWithoutClienteNestedInput
    ordent?: ordentUpdateManyWithoutClienteNestedInput
  }

  export type clienteUncheckedUpdateWithoutCotizacionInput = {
    idcli?: IntFieldUpdateOperationsInput | number
    idpe?: IntFieldUpdateOperationsInput | number
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    ordent?: ordentUncheckedUpdateManyWithoutClienteNestedInput
  }

  export type usuarioUpsertWithoutCotizacionInput = {
    update: XOR<usuarioUpdateWithoutCotizacionInput, usuarioUncheckedUpdateWithoutCotizacionInput>
    create: XOR<usuarioCreateWithoutCotizacionInput, usuarioUncheckedCreateWithoutCotizacionInput>
    where?: usuarioWhereInput
  }

  export type usuarioUpdateToOneWithWhereWithoutCotizacionInput = {
    where?: usuarioWhereInput
    data: XOR<usuarioUpdateWithoutCotizacionInput, usuarioUncheckedUpdateWithoutCotizacionInput>
  }

  export type usuarioUpdateWithoutCotizacionInput = {
    sexo?: StringFieldUpdateOperationsInput | string
    foto?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    fecnac?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    base64?: NullableStringFieldUpdateOperationsInput | string | null
    arte_arte_iduTousuario?: arteUpdateManyWithoutUsuario_arte_iduTousuarioNestedInput
    arte_arte_iduaTousuario?: arteUpdateManyWithoutUsuario_arte_iduaTousuarioNestedInput
    datos?: datosUpdateManyWithoutUsuarioNestedInput
    factura?: facturaUpdateManyWithoutUsuarioNestedInput
    ordent?: ordentUpdateManyWithoutUsuarioNestedInput
    registrolaboral?: registrolaboralUpdateManyWithoutUsuarioNestedInput
    empresa?: empresaUpdateOneWithoutUsuarioNestedInput
    persona?: personaUpdateOneRequiredWithoutUsuarioNestedInput
    usurol?: usurolUpdateManyWithoutUsuarioNestedInput
  }

  export type usuarioUncheckedUpdateWithoutCotizacionInput = {
    idu?: IntFieldUpdateOperationsInput | number
    sexo?: StringFieldUpdateOperationsInput | string
    foto?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    fecnac?: DateTimeFieldUpdateOperationsInput | Date | string
    idpe?: IntFieldUpdateOperationsInput | number
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    idem?: NullableIntFieldUpdateOperationsInput | number | null
    base64?: NullableStringFieldUpdateOperationsInput | string | null
    arte_arte_iduTousuario?: arteUncheckedUpdateManyWithoutUsuario_arte_iduTousuarioNestedInput
    arte_arte_iduaTousuario?: arteUncheckedUpdateManyWithoutUsuario_arte_iduaTousuarioNestedInput
    datos?: datosUncheckedUpdateManyWithoutUsuarioNestedInput
    factura?: facturaUncheckedUpdateManyWithoutUsuarioNestedInput
    ordent?: ordentUncheckedUpdateManyWithoutUsuarioNestedInput
    registrolaboral?: registrolaboralUncheckedUpdateManyWithoutUsuarioNestedInput
    usurol?: usurolUncheckedUpdateManyWithoutUsuarioNestedInput
  }

  export type detcotUpsertWithWhereUniqueWithoutCotizacionInput = {
    where: detcotWhereUniqueInput
    update: XOR<detcotUpdateWithoutCotizacionInput, detcotUncheckedUpdateWithoutCotizacionInput>
    create: XOR<detcotCreateWithoutCotizacionInput, detcotUncheckedCreateWithoutCotizacionInput>
  }

  export type detcotUpdateWithWhereUniqueWithoutCotizacionInput = {
    where: detcotWhereUniqueInput
    data: XOR<detcotUpdateWithoutCotizacionInput, detcotUncheckedUpdateWithoutCotizacionInput>
  }

  export type detcotUpdateManyWithWhereWithoutCotizacionInput = {
    where: detcotScalarWhereInput
    data: XOR<detcotUpdateManyMutationInput, detcotUncheckedUpdateManyWithoutCotizacionInput>
  }

  export type detcotScalarWhereInput = {
    AND?: detcotScalarWhereInput | detcotScalarWhereInput[]
    OR?: detcotScalarWhereInput[]
    NOT?: detcotScalarWhereInput | detcotScalarWhereInput[]
    iddetcot?: IntFilter<"detcot"> | number
    idcot?: IntNullableFilter<"detcot"> | number | null
    idpro?: IntNullableFilter<"detcot"> | number | null
    cant?: IntNullableFilter<"detcot"> | number | null
    punit?: FloatNullableFilter<"detcot"> | number | null
    stotal?: FloatNullableFilter<"detcot"> | number | null
    material?: StringNullableFilter<"detcot"> | string | null
    gr?: StringNullableFilter<"detcot"> | string | null
    tintas?: StringNullableFilter<"detcot"> | string | null
    estado?: BoolNullableFilter<"detcot"> | boolean | null
  }

  export type ordentUpsertWithWhereUniqueWithoutCotizacionInput = {
    where: ordentWhereUniqueInput
    update: XOR<ordentUpdateWithoutCotizacionInput, ordentUncheckedUpdateWithoutCotizacionInput>
    create: XOR<ordentCreateWithoutCotizacionInput, ordentUncheckedCreateWithoutCotizacionInput>
  }

  export type ordentUpdateWithWhereUniqueWithoutCotizacionInput = {
    where: ordentWhereUniqueInput
    data: XOR<ordentUpdateWithoutCotizacionInput, ordentUncheckedUpdateWithoutCotizacionInput>
  }

  export type ordentUpdateManyWithWhereWithoutCotizacionInput = {
    where: ordentScalarWhereInput
    data: XOR<ordentUpdateManyMutationInput, ordentUncheckedUpdateManyWithoutCotizacionInput>
  }

  export type usuarioCreateWithoutDatosInput = {
    sexo: string
    foto?: Buffer | null
    fecnac: Date | string
    estado?: boolean | null
    base64?: string | null
    arte_arte_iduTousuario?: arteCreateNestedManyWithoutUsuario_arte_iduTousuarioInput
    arte_arte_iduaTousuario?: arteCreateNestedManyWithoutUsuario_arte_iduaTousuarioInput
    cotizacion?: cotizacionCreateNestedManyWithoutUsuarioInput
    factura?: facturaCreateNestedManyWithoutUsuarioInput
    ordent?: ordentCreateNestedManyWithoutUsuarioInput
    registrolaboral?: registrolaboralCreateNestedManyWithoutUsuarioInput
    empresa?: empresaCreateNestedOneWithoutUsuarioInput
    persona: personaCreateNestedOneWithoutUsuarioInput
    usurol?: usurolCreateNestedManyWithoutUsuarioInput
  }

  export type usuarioUncheckedCreateWithoutDatosInput = {
    idu?: number
    sexo: string
    foto?: Buffer | null
    fecnac: Date | string
    idpe: number
    estado?: boolean | null
    idem?: number | null
    base64?: string | null
    arte_arte_iduTousuario?: arteUncheckedCreateNestedManyWithoutUsuario_arte_iduTousuarioInput
    arte_arte_iduaTousuario?: arteUncheckedCreateNestedManyWithoutUsuario_arte_iduaTousuarioInput
    cotizacion?: cotizacionUncheckedCreateNestedManyWithoutUsuarioInput
    factura?: facturaUncheckedCreateNestedManyWithoutUsuarioInput
    ordent?: ordentUncheckedCreateNestedManyWithoutUsuarioInput
    registrolaboral?: registrolaboralUncheckedCreateNestedManyWithoutUsuarioInput
    usurol?: usurolUncheckedCreateNestedManyWithoutUsuarioInput
  }

  export type usuarioCreateOrConnectWithoutDatosInput = {
    where: usuarioWhereUniqueInput
    create: XOR<usuarioCreateWithoutDatosInput, usuarioUncheckedCreateWithoutDatosInput>
  }

  export type usuarioUpsertWithoutDatosInput = {
    update: XOR<usuarioUpdateWithoutDatosInput, usuarioUncheckedUpdateWithoutDatosInput>
    create: XOR<usuarioCreateWithoutDatosInput, usuarioUncheckedCreateWithoutDatosInput>
    where?: usuarioWhereInput
  }

  export type usuarioUpdateToOneWithWhereWithoutDatosInput = {
    where?: usuarioWhereInput
    data: XOR<usuarioUpdateWithoutDatosInput, usuarioUncheckedUpdateWithoutDatosInput>
  }

  export type usuarioUpdateWithoutDatosInput = {
    sexo?: StringFieldUpdateOperationsInput | string
    foto?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    fecnac?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    base64?: NullableStringFieldUpdateOperationsInput | string | null
    arte_arte_iduTousuario?: arteUpdateManyWithoutUsuario_arte_iduTousuarioNestedInput
    arte_arte_iduaTousuario?: arteUpdateManyWithoutUsuario_arte_iduaTousuarioNestedInput
    cotizacion?: cotizacionUpdateManyWithoutUsuarioNestedInput
    factura?: facturaUpdateManyWithoutUsuarioNestedInput
    ordent?: ordentUpdateManyWithoutUsuarioNestedInput
    registrolaboral?: registrolaboralUpdateManyWithoutUsuarioNestedInput
    empresa?: empresaUpdateOneWithoutUsuarioNestedInput
    persona?: personaUpdateOneRequiredWithoutUsuarioNestedInput
    usurol?: usurolUpdateManyWithoutUsuarioNestedInput
  }

  export type usuarioUncheckedUpdateWithoutDatosInput = {
    idu?: IntFieldUpdateOperationsInput | number
    sexo?: StringFieldUpdateOperationsInput | string
    foto?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    fecnac?: DateTimeFieldUpdateOperationsInput | Date | string
    idpe?: IntFieldUpdateOperationsInput | number
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    idem?: NullableIntFieldUpdateOperationsInput | number | null
    base64?: NullableStringFieldUpdateOperationsInput | string | null
    arte_arte_iduTousuario?: arteUncheckedUpdateManyWithoutUsuario_arte_iduTousuarioNestedInput
    arte_arte_iduaTousuario?: arteUncheckedUpdateManyWithoutUsuario_arte_iduaTousuarioNestedInput
    cotizacion?: cotizacionUncheckedUpdateManyWithoutUsuarioNestedInput
    factura?: facturaUncheckedUpdateManyWithoutUsuarioNestedInput
    ordent?: ordentUncheckedUpdateManyWithoutUsuarioNestedInput
    registrolaboral?: registrolaboralUncheckedUpdateManyWithoutUsuarioNestedInput
    usurol?: usurolUncheckedUpdateManyWithoutUsuarioNestedInput
  }

  export type cotizacionCreateWithoutDetcotInput = {
    fecha?: Date | string | null
    precio?: number | null
    descuento?: number | null
    preciofinal?: number | null
    tiempo?: number | null
    arte?: string | null
    obs?: string | null
    estado?: string | null
    cliente?: clienteCreateNestedOneWithoutCotizacionInput
    usuario?: usuarioCreateNestedOneWithoutCotizacionInput
    ordent?: ordentCreateNestedManyWithoutCotizacionInput
  }

  export type cotizacionUncheckedCreateWithoutDetcotInput = {
    idcot?: number
    idu?: number | null
    idcli?: number | null
    fecha?: Date | string | null
    precio?: number | null
    descuento?: number | null
    preciofinal?: number | null
    tiempo?: number | null
    arte?: string | null
    obs?: string | null
    estado?: string | null
    ordent?: ordentUncheckedCreateNestedManyWithoutCotizacionInput
  }

  export type cotizacionCreateOrConnectWithoutDetcotInput = {
    where: cotizacionWhereUniqueInput
    create: XOR<cotizacionCreateWithoutDetcotInput, cotizacionUncheckedCreateWithoutDetcotInput>
  }

  export type productoCreateWithoutDetcotInput = {
    nom?: string | null
    tam?: string | null
    des?: string | null
    preciov?: number | null
    precioc?: number | null
    cantidad?: number | null
    foto?: Buffer | null
    estado?: boolean | null
    base64?: string | null
    ranking?: number | null
    detot?: detotCreateNestedManyWithoutProductoInput
    marca?: marcaCreateNestedOneWithoutProductoInput
  }

  export type productoUncheckedCreateWithoutDetcotInput = {
    idpro?: number
    nom?: string | null
    tam?: string | null
    des?: string | null
    preciov?: number | null
    precioc?: number | null
    cantidad?: number | null
    foto?: Buffer | null
    idmar?: number | null
    estado?: boolean | null
    base64?: string | null
    ranking?: number | null
    detot?: detotUncheckedCreateNestedManyWithoutProductoInput
  }

  export type productoCreateOrConnectWithoutDetcotInput = {
    where: productoWhereUniqueInput
    create: XOR<productoCreateWithoutDetcotInput, productoUncheckedCreateWithoutDetcotInput>
  }

  export type cotizacionUpsertWithoutDetcotInput = {
    update: XOR<cotizacionUpdateWithoutDetcotInput, cotizacionUncheckedUpdateWithoutDetcotInput>
    create: XOR<cotizacionCreateWithoutDetcotInput, cotizacionUncheckedCreateWithoutDetcotInput>
    where?: cotizacionWhereInput
  }

  export type cotizacionUpdateToOneWithWhereWithoutDetcotInput = {
    where?: cotizacionWhereInput
    data: XOR<cotizacionUpdateWithoutDetcotInput, cotizacionUncheckedUpdateWithoutDetcotInput>
  }

  export type cotizacionUpdateWithoutDetcotInput = {
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    precio?: NullableFloatFieldUpdateOperationsInput | number | null
    descuento?: NullableFloatFieldUpdateOperationsInput | number | null
    preciofinal?: NullableFloatFieldUpdateOperationsInput | number | null
    tiempo?: NullableIntFieldUpdateOperationsInput | number | null
    arte?: NullableStringFieldUpdateOperationsInput | string | null
    obs?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableStringFieldUpdateOperationsInput | string | null
    cliente?: clienteUpdateOneWithoutCotizacionNestedInput
    usuario?: usuarioUpdateOneWithoutCotizacionNestedInput
    ordent?: ordentUpdateManyWithoutCotizacionNestedInput
  }

  export type cotizacionUncheckedUpdateWithoutDetcotInput = {
    idcot?: IntFieldUpdateOperationsInput | number
    idu?: NullableIntFieldUpdateOperationsInput | number | null
    idcli?: NullableIntFieldUpdateOperationsInput | number | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    precio?: NullableFloatFieldUpdateOperationsInput | number | null
    descuento?: NullableFloatFieldUpdateOperationsInput | number | null
    preciofinal?: NullableFloatFieldUpdateOperationsInput | number | null
    tiempo?: NullableIntFieldUpdateOperationsInput | number | null
    arte?: NullableStringFieldUpdateOperationsInput | string | null
    obs?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableStringFieldUpdateOperationsInput | string | null
    ordent?: ordentUncheckedUpdateManyWithoutCotizacionNestedInput
  }

  export type productoUpsertWithoutDetcotInput = {
    update: XOR<productoUpdateWithoutDetcotInput, productoUncheckedUpdateWithoutDetcotInput>
    create: XOR<productoCreateWithoutDetcotInput, productoUncheckedCreateWithoutDetcotInput>
    where?: productoWhereInput
  }

  export type productoUpdateToOneWithWhereWithoutDetcotInput = {
    where?: productoWhereInput
    data: XOR<productoUpdateWithoutDetcotInput, productoUncheckedUpdateWithoutDetcotInput>
  }

  export type productoUpdateWithoutDetcotInput = {
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    tam?: NullableStringFieldUpdateOperationsInput | string | null
    des?: NullableStringFieldUpdateOperationsInput | string | null
    preciov?: NullableFloatFieldUpdateOperationsInput | number | null
    precioc?: NullableFloatFieldUpdateOperationsInput | number | null
    cantidad?: NullableIntFieldUpdateOperationsInput | number | null
    foto?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    base64?: NullableStringFieldUpdateOperationsInput | string | null
    ranking?: NullableIntFieldUpdateOperationsInput | number | null
    detot?: detotUpdateManyWithoutProductoNestedInput
    marca?: marcaUpdateOneWithoutProductoNestedInput
  }

  export type productoUncheckedUpdateWithoutDetcotInput = {
    idpro?: IntFieldUpdateOperationsInput | number
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    tam?: NullableStringFieldUpdateOperationsInput | string | null
    des?: NullableStringFieldUpdateOperationsInput | string | null
    preciov?: NullableFloatFieldUpdateOperationsInput | number | null
    precioc?: NullableFloatFieldUpdateOperationsInput | number | null
    cantidad?: NullableIntFieldUpdateOperationsInput | number | null
    foto?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    idmar?: NullableIntFieldUpdateOperationsInput | number | null
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    base64?: NullableStringFieldUpdateOperationsInput | string | null
    ranking?: NullableIntFieldUpdateOperationsInput | number | null
    detot?: detotUncheckedUpdateManyWithoutProductoNestedInput
  }

  export type ordentCreateWithoutDetotInput = {
    fecha?: Date | string | null
    precio?: number | null
    descuento?: number | null
    preciofinal?: number | null
    tiempo?: number | null
    arte?: string | null
    obs?: string | null
    estado?: string | null
    factura?: string | null
    arte1?: arteCreateNestedManyWithoutOrdentInput
    factura1?: facturaCreateNestedManyWithoutOrdentInput
    cliente?: clienteCreateNestedOneWithoutOrdentInput
    cotizacion?: cotizacionCreateNestedOneWithoutOrdentInput
    usuario?: usuarioCreateNestedOneWithoutOrdentInput
    pago?: pagoCreateNestedManyWithoutOrdentInput
  }

  export type ordentUncheckedCreateWithoutDetotInput = {
    idot?: number
    idu?: number | null
    idcli?: number | null
    idcot?: number | null
    fecha?: Date | string | null
    precio?: number | null
    descuento?: number | null
    preciofinal?: number | null
    tiempo?: number | null
    arte?: string | null
    obs?: string | null
    estado?: string | null
    factura?: string | null
    arte1?: arteUncheckedCreateNestedManyWithoutOrdentInput
    factura1?: facturaUncheckedCreateNestedManyWithoutOrdentInput
    pago?: pagoUncheckedCreateNestedManyWithoutOrdentInput
  }

  export type ordentCreateOrConnectWithoutDetotInput = {
    where: ordentWhereUniqueInput
    create: XOR<ordentCreateWithoutDetotInput, ordentUncheckedCreateWithoutDetotInput>
  }

  export type productoCreateWithoutDetotInput = {
    nom?: string | null
    tam?: string | null
    des?: string | null
    preciov?: number | null
    precioc?: number | null
    cantidad?: number | null
    foto?: Buffer | null
    estado?: boolean | null
    base64?: string | null
    ranking?: number | null
    detcot?: detcotCreateNestedManyWithoutProductoInput
    marca?: marcaCreateNestedOneWithoutProductoInput
  }

  export type productoUncheckedCreateWithoutDetotInput = {
    idpro?: number
    nom?: string | null
    tam?: string | null
    des?: string | null
    preciov?: number | null
    precioc?: number | null
    cantidad?: number | null
    foto?: Buffer | null
    idmar?: number | null
    estado?: boolean | null
    base64?: string | null
    ranking?: number | null
    detcot?: detcotUncheckedCreateNestedManyWithoutProductoInput
  }

  export type productoCreateOrConnectWithoutDetotInput = {
    where: productoWhereUniqueInput
    create: XOR<productoCreateWithoutDetotInput, productoUncheckedCreateWithoutDetotInput>
  }

  export type ordentUpsertWithoutDetotInput = {
    update: XOR<ordentUpdateWithoutDetotInput, ordentUncheckedUpdateWithoutDetotInput>
    create: XOR<ordentCreateWithoutDetotInput, ordentUncheckedCreateWithoutDetotInput>
    where?: ordentWhereInput
  }

  export type ordentUpdateToOneWithWhereWithoutDetotInput = {
    where?: ordentWhereInput
    data: XOR<ordentUpdateWithoutDetotInput, ordentUncheckedUpdateWithoutDetotInput>
  }

  export type ordentUpdateWithoutDetotInput = {
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    precio?: NullableFloatFieldUpdateOperationsInput | number | null
    descuento?: NullableFloatFieldUpdateOperationsInput | number | null
    preciofinal?: NullableFloatFieldUpdateOperationsInput | number | null
    tiempo?: NullableIntFieldUpdateOperationsInput | number | null
    arte?: NullableStringFieldUpdateOperationsInput | string | null
    obs?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableStringFieldUpdateOperationsInput | string | null
    factura?: NullableStringFieldUpdateOperationsInput | string | null
    arte1?: arteUpdateManyWithoutOrdentNestedInput
    factura1?: facturaUpdateManyWithoutOrdentNestedInput
    cliente?: clienteUpdateOneWithoutOrdentNestedInput
    cotizacion?: cotizacionUpdateOneWithoutOrdentNestedInput
    usuario?: usuarioUpdateOneWithoutOrdentNestedInput
    pago?: pagoUpdateManyWithoutOrdentNestedInput
  }

  export type ordentUncheckedUpdateWithoutDetotInput = {
    idot?: IntFieldUpdateOperationsInput | number
    idu?: NullableIntFieldUpdateOperationsInput | number | null
    idcli?: NullableIntFieldUpdateOperationsInput | number | null
    idcot?: NullableIntFieldUpdateOperationsInput | number | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    precio?: NullableFloatFieldUpdateOperationsInput | number | null
    descuento?: NullableFloatFieldUpdateOperationsInput | number | null
    preciofinal?: NullableFloatFieldUpdateOperationsInput | number | null
    tiempo?: NullableIntFieldUpdateOperationsInput | number | null
    arte?: NullableStringFieldUpdateOperationsInput | string | null
    obs?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableStringFieldUpdateOperationsInput | string | null
    factura?: NullableStringFieldUpdateOperationsInput | string | null
    arte1?: arteUncheckedUpdateManyWithoutOrdentNestedInput
    factura1?: facturaUncheckedUpdateManyWithoutOrdentNestedInput
    pago?: pagoUncheckedUpdateManyWithoutOrdentNestedInput
  }

  export type productoUpsertWithoutDetotInput = {
    update: XOR<productoUpdateWithoutDetotInput, productoUncheckedUpdateWithoutDetotInput>
    create: XOR<productoCreateWithoutDetotInput, productoUncheckedCreateWithoutDetotInput>
    where?: productoWhereInput
  }

  export type productoUpdateToOneWithWhereWithoutDetotInput = {
    where?: productoWhereInput
    data: XOR<productoUpdateWithoutDetotInput, productoUncheckedUpdateWithoutDetotInput>
  }

  export type productoUpdateWithoutDetotInput = {
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    tam?: NullableStringFieldUpdateOperationsInput | string | null
    des?: NullableStringFieldUpdateOperationsInput | string | null
    preciov?: NullableFloatFieldUpdateOperationsInput | number | null
    precioc?: NullableFloatFieldUpdateOperationsInput | number | null
    cantidad?: NullableIntFieldUpdateOperationsInput | number | null
    foto?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    base64?: NullableStringFieldUpdateOperationsInput | string | null
    ranking?: NullableIntFieldUpdateOperationsInput | number | null
    detcot?: detcotUpdateManyWithoutProductoNestedInput
    marca?: marcaUpdateOneWithoutProductoNestedInput
  }

  export type productoUncheckedUpdateWithoutDetotInput = {
    idpro?: IntFieldUpdateOperationsInput | number
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    tam?: NullableStringFieldUpdateOperationsInput | string | null
    des?: NullableStringFieldUpdateOperationsInput | string | null
    preciov?: NullableFloatFieldUpdateOperationsInput | number | null
    precioc?: NullableFloatFieldUpdateOperationsInput | number | null
    cantidad?: NullableIntFieldUpdateOperationsInput | number | null
    foto?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    idmar?: NullableIntFieldUpdateOperationsInput | number | null
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    base64?: NullableStringFieldUpdateOperationsInput | string | null
    ranking?: NullableIntFieldUpdateOperationsInput | number | null
    detcot?: detcotUncheckedUpdateManyWithoutProductoNestedInput
  }

  export type personaCreateWithoutEmpresaInput = {
    ci: string
    nombre: string
    ap: string
    am?: string | null
    direccion?: string | null
    email?: string | null
    estado?: boolean | null
    base64?: string | null
    cliente?: clienteCreateNestedManyWithoutPersonaInput
    proveedor?: proveedorCreateNestedManyWithoutPersonaInput
    telefono?: telefonoCreateNestedManyWithoutPersonaInput
    usuario?: usuarioCreateNestedManyWithoutPersonaInput
  }

  export type personaUncheckedCreateWithoutEmpresaInput = {
    idpe?: number
    ci: string
    nombre: string
    ap: string
    am?: string | null
    direccion?: string | null
    email?: string | null
    estado?: boolean | null
    base64?: string | null
    cliente?: clienteUncheckedCreateNestedManyWithoutPersonaInput
    proveedor?: proveedorUncheckedCreateNestedManyWithoutPersonaInput
    telefono?: telefonoUncheckedCreateNestedManyWithoutPersonaInput
    usuario?: usuarioUncheckedCreateNestedManyWithoutPersonaInput
  }

  export type personaCreateOrConnectWithoutEmpresaInput = {
    where: personaWhereUniqueInput
    create: XOR<personaCreateWithoutEmpresaInput, personaUncheckedCreateWithoutEmpresaInput>
  }

  export type leyendaCreateWithoutEmpresaInput = {
    des?: string | null
    orden?: number | null
  }

  export type leyendaUncheckedCreateWithoutEmpresaInput = {
    idle?: number
    des?: string | null
    orden?: number | null
  }

  export type leyendaCreateOrConnectWithoutEmpresaInput = {
    where: leyendaWhereUniqueInput
    create: XOR<leyendaCreateWithoutEmpresaInput, leyendaUncheckedCreateWithoutEmpresaInput>
  }

  export type leyendaCreateManyEmpresaInputEnvelope = {
    data: leyendaCreateManyEmpresaInput | leyendaCreateManyEmpresaInput[]
    skipDuplicates?: boolean
  }

  export type usuarioCreateWithoutEmpresaInput = {
    sexo: string
    foto?: Buffer | null
    fecnac: Date | string
    estado?: boolean | null
    base64?: string | null
    arte_arte_iduTousuario?: arteCreateNestedManyWithoutUsuario_arte_iduTousuarioInput
    arte_arte_iduaTousuario?: arteCreateNestedManyWithoutUsuario_arte_iduaTousuarioInput
    cotizacion?: cotizacionCreateNestedManyWithoutUsuarioInput
    datos?: datosCreateNestedManyWithoutUsuarioInput
    factura?: facturaCreateNestedManyWithoutUsuarioInput
    ordent?: ordentCreateNestedManyWithoutUsuarioInput
    registrolaboral?: registrolaboralCreateNestedManyWithoutUsuarioInput
    persona: personaCreateNestedOneWithoutUsuarioInput
    usurol?: usurolCreateNestedManyWithoutUsuarioInput
  }

  export type usuarioUncheckedCreateWithoutEmpresaInput = {
    idu?: number
    sexo: string
    foto?: Buffer | null
    fecnac: Date | string
    idpe: number
    estado?: boolean | null
    base64?: string | null
    arte_arte_iduTousuario?: arteUncheckedCreateNestedManyWithoutUsuario_arte_iduTousuarioInput
    arte_arte_iduaTousuario?: arteUncheckedCreateNestedManyWithoutUsuario_arte_iduaTousuarioInput
    cotizacion?: cotizacionUncheckedCreateNestedManyWithoutUsuarioInput
    datos?: datosUncheckedCreateNestedManyWithoutUsuarioInput
    factura?: facturaUncheckedCreateNestedManyWithoutUsuarioInput
    ordent?: ordentUncheckedCreateNestedManyWithoutUsuarioInput
    registrolaboral?: registrolaboralUncheckedCreateNestedManyWithoutUsuarioInput
    usurol?: usurolUncheckedCreateNestedManyWithoutUsuarioInput
  }

  export type usuarioCreateOrConnectWithoutEmpresaInput = {
    where: usuarioWhereUniqueInput
    create: XOR<usuarioCreateWithoutEmpresaInput, usuarioUncheckedCreateWithoutEmpresaInput>
  }

  export type usuarioCreateManyEmpresaInputEnvelope = {
    data: usuarioCreateManyEmpresaInput | usuarioCreateManyEmpresaInput[]
    skipDuplicates?: boolean
  }

  export type personaUpsertWithoutEmpresaInput = {
    update: XOR<personaUpdateWithoutEmpresaInput, personaUncheckedUpdateWithoutEmpresaInput>
    create: XOR<personaCreateWithoutEmpresaInput, personaUncheckedCreateWithoutEmpresaInput>
    where?: personaWhereInput
  }

  export type personaUpdateToOneWithWhereWithoutEmpresaInput = {
    where?: personaWhereInput
    data: XOR<personaUpdateWithoutEmpresaInput, personaUncheckedUpdateWithoutEmpresaInput>
  }

  export type personaUpdateWithoutEmpresaInput = {
    ci?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    ap?: StringFieldUpdateOperationsInput | string
    am?: NullableStringFieldUpdateOperationsInput | string | null
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    base64?: NullableStringFieldUpdateOperationsInput | string | null
    cliente?: clienteUpdateManyWithoutPersonaNestedInput
    proveedor?: proveedorUpdateManyWithoutPersonaNestedInput
    telefono?: telefonoUpdateManyWithoutPersonaNestedInput
    usuario?: usuarioUpdateManyWithoutPersonaNestedInput
  }

  export type personaUncheckedUpdateWithoutEmpresaInput = {
    idpe?: IntFieldUpdateOperationsInput | number
    ci?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    ap?: StringFieldUpdateOperationsInput | string
    am?: NullableStringFieldUpdateOperationsInput | string | null
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    base64?: NullableStringFieldUpdateOperationsInput | string | null
    cliente?: clienteUncheckedUpdateManyWithoutPersonaNestedInput
    proveedor?: proveedorUncheckedUpdateManyWithoutPersonaNestedInput
    telefono?: telefonoUncheckedUpdateManyWithoutPersonaNestedInput
    usuario?: usuarioUncheckedUpdateManyWithoutPersonaNestedInput
  }

  export type leyendaUpsertWithWhereUniqueWithoutEmpresaInput = {
    where: leyendaWhereUniqueInput
    update: XOR<leyendaUpdateWithoutEmpresaInput, leyendaUncheckedUpdateWithoutEmpresaInput>
    create: XOR<leyendaCreateWithoutEmpresaInput, leyendaUncheckedCreateWithoutEmpresaInput>
  }

  export type leyendaUpdateWithWhereUniqueWithoutEmpresaInput = {
    where: leyendaWhereUniqueInput
    data: XOR<leyendaUpdateWithoutEmpresaInput, leyendaUncheckedUpdateWithoutEmpresaInput>
  }

  export type leyendaUpdateManyWithWhereWithoutEmpresaInput = {
    where: leyendaScalarWhereInput
    data: XOR<leyendaUpdateManyMutationInput, leyendaUncheckedUpdateManyWithoutEmpresaInput>
  }

  export type leyendaScalarWhereInput = {
    AND?: leyendaScalarWhereInput | leyendaScalarWhereInput[]
    OR?: leyendaScalarWhereInput[]
    NOT?: leyendaScalarWhereInput | leyendaScalarWhereInput[]
    idle?: IntFilter<"leyenda"> | number
    des?: StringNullableFilter<"leyenda"> | string | null
    orden?: IntNullableFilter<"leyenda"> | number | null
    idem?: IntNullableFilter<"leyenda"> | number | null
  }

  export type usuarioUpsertWithWhereUniqueWithoutEmpresaInput = {
    where: usuarioWhereUniqueInput
    update: XOR<usuarioUpdateWithoutEmpresaInput, usuarioUncheckedUpdateWithoutEmpresaInput>
    create: XOR<usuarioCreateWithoutEmpresaInput, usuarioUncheckedCreateWithoutEmpresaInput>
  }

  export type usuarioUpdateWithWhereUniqueWithoutEmpresaInput = {
    where: usuarioWhereUniqueInput
    data: XOR<usuarioUpdateWithoutEmpresaInput, usuarioUncheckedUpdateWithoutEmpresaInput>
  }

  export type usuarioUpdateManyWithWhereWithoutEmpresaInput = {
    where: usuarioScalarWhereInput
    data: XOR<usuarioUpdateManyMutationInput, usuarioUncheckedUpdateManyWithoutEmpresaInput>
  }

  export type usuarioScalarWhereInput = {
    AND?: usuarioScalarWhereInput | usuarioScalarWhereInput[]
    OR?: usuarioScalarWhereInput[]
    NOT?: usuarioScalarWhereInput | usuarioScalarWhereInput[]
    idu?: IntFilter<"usuario"> | number
    sexo?: StringFilter<"usuario"> | string
    foto?: BytesNullableFilter<"usuario"> | Buffer | null
    fecnac?: DateTimeFilter<"usuario"> | Date | string
    idpe?: IntFilter<"usuario"> | number
    estado?: BoolNullableFilter<"usuario"> | boolean | null
    idem?: IntNullableFilter<"usuario"> | number | null
    base64?: StringNullableFilter<"usuario"> | string | null
  }

  export type ordentCreateWithoutFactura1Input = {
    fecha?: Date | string | null
    precio?: number | null
    descuento?: number | null
    preciofinal?: number | null
    tiempo?: number | null
    arte?: string | null
    obs?: string | null
    estado?: string | null
    factura?: string | null
    arte1?: arteCreateNestedManyWithoutOrdentInput
    detot?: detotCreateNestedManyWithoutOrdentInput
    cliente?: clienteCreateNestedOneWithoutOrdentInput
    cotizacion?: cotizacionCreateNestedOneWithoutOrdentInput
    usuario?: usuarioCreateNestedOneWithoutOrdentInput
    pago?: pagoCreateNestedManyWithoutOrdentInput
  }

  export type ordentUncheckedCreateWithoutFactura1Input = {
    idot?: number
    idu?: number | null
    idcli?: number | null
    idcot?: number | null
    fecha?: Date | string | null
    precio?: number | null
    descuento?: number | null
    preciofinal?: number | null
    tiempo?: number | null
    arte?: string | null
    obs?: string | null
    estado?: string | null
    factura?: string | null
    arte1?: arteUncheckedCreateNestedManyWithoutOrdentInput
    detot?: detotUncheckedCreateNestedManyWithoutOrdentInput
    pago?: pagoUncheckedCreateNestedManyWithoutOrdentInput
  }

  export type ordentCreateOrConnectWithoutFactura1Input = {
    where: ordentWhereUniqueInput
    create: XOR<ordentCreateWithoutFactura1Input, ordentUncheckedCreateWithoutFactura1Input>
  }

  export type usuarioCreateWithoutFacturaInput = {
    sexo: string
    foto?: Buffer | null
    fecnac: Date | string
    estado?: boolean | null
    base64?: string | null
    arte_arte_iduTousuario?: arteCreateNestedManyWithoutUsuario_arte_iduTousuarioInput
    arte_arte_iduaTousuario?: arteCreateNestedManyWithoutUsuario_arte_iduaTousuarioInput
    cotizacion?: cotizacionCreateNestedManyWithoutUsuarioInput
    datos?: datosCreateNestedManyWithoutUsuarioInput
    ordent?: ordentCreateNestedManyWithoutUsuarioInput
    registrolaboral?: registrolaboralCreateNestedManyWithoutUsuarioInput
    empresa?: empresaCreateNestedOneWithoutUsuarioInput
    persona: personaCreateNestedOneWithoutUsuarioInput
    usurol?: usurolCreateNestedManyWithoutUsuarioInput
  }

  export type usuarioUncheckedCreateWithoutFacturaInput = {
    idu?: number
    sexo: string
    foto?: Buffer | null
    fecnac: Date | string
    idpe: number
    estado?: boolean | null
    idem?: number | null
    base64?: string | null
    arte_arte_iduTousuario?: arteUncheckedCreateNestedManyWithoutUsuario_arte_iduTousuarioInput
    arte_arte_iduaTousuario?: arteUncheckedCreateNestedManyWithoutUsuario_arte_iduaTousuarioInput
    cotizacion?: cotizacionUncheckedCreateNestedManyWithoutUsuarioInput
    datos?: datosUncheckedCreateNestedManyWithoutUsuarioInput
    ordent?: ordentUncheckedCreateNestedManyWithoutUsuarioInput
    registrolaboral?: registrolaboralUncheckedCreateNestedManyWithoutUsuarioInput
    usurol?: usurolUncheckedCreateNestedManyWithoutUsuarioInput
  }

  export type usuarioCreateOrConnectWithoutFacturaInput = {
    where: usuarioWhereUniqueInput
    create: XOR<usuarioCreateWithoutFacturaInput, usuarioUncheckedCreateWithoutFacturaInput>
  }

  export type ordentUpsertWithoutFactura1Input = {
    update: XOR<ordentUpdateWithoutFactura1Input, ordentUncheckedUpdateWithoutFactura1Input>
    create: XOR<ordentCreateWithoutFactura1Input, ordentUncheckedCreateWithoutFactura1Input>
    where?: ordentWhereInput
  }

  export type ordentUpdateToOneWithWhereWithoutFactura1Input = {
    where?: ordentWhereInput
    data: XOR<ordentUpdateWithoutFactura1Input, ordentUncheckedUpdateWithoutFactura1Input>
  }

  export type ordentUpdateWithoutFactura1Input = {
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    precio?: NullableFloatFieldUpdateOperationsInput | number | null
    descuento?: NullableFloatFieldUpdateOperationsInput | number | null
    preciofinal?: NullableFloatFieldUpdateOperationsInput | number | null
    tiempo?: NullableIntFieldUpdateOperationsInput | number | null
    arte?: NullableStringFieldUpdateOperationsInput | string | null
    obs?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableStringFieldUpdateOperationsInput | string | null
    factura?: NullableStringFieldUpdateOperationsInput | string | null
    arte1?: arteUpdateManyWithoutOrdentNestedInput
    detot?: detotUpdateManyWithoutOrdentNestedInput
    cliente?: clienteUpdateOneWithoutOrdentNestedInput
    cotizacion?: cotizacionUpdateOneWithoutOrdentNestedInput
    usuario?: usuarioUpdateOneWithoutOrdentNestedInput
    pago?: pagoUpdateManyWithoutOrdentNestedInput
  }

  export type ordentUncheckedUpdateWithoutFactura1Input = {
    idot?: IntFieldUpdateOperationsInput | number
    idu?: NullableIntFieldUpdateOperationsInput | number | null
    idcli?: NullableIntFieldUpdateOperationsInput | number | null
    idcot?: NullableIntFieldUpdateOperationsInput | number | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    precio?: NullableFloatFieldUpdateOperationsInput | number | null
    descuento?: NullableFloatFieldUpdateOperationsInput | number | null
    preciofinal?: NullableFloatFieldUpdateOperationsInput | number | null
    tiempo?: NullableIntFieldUpdateOperationsInput | number | null
    arte?: NullableStringFieldUpdateOperationsInput | string | null
    obs?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableStringFieldUpdateOperationsInput | string | null
    factura?: NullableStringFieldUpdateOperationsInput | string | null
    arte1?: arteUncheckedUpdateManyWithoutOrdentNestedInput
    detot?: detotUncheckedUpdateManyWithoutOrdentNestedInput
    pago?: pagoUncheckedUpdateManyWithoutOrdentNestedInput
  }

  export type usuarioUpsertWithoutFacturaInput = {
    update: XOR<usuarioUpdateWithoutFacturaInput, usuarioUncheckedUpdateWithoutFacturaInput>
    create: XOR<usuarioCreateWithoutFacturaInput, usuarioUncheckedCreateWithoutFacturaInput>
    where?: usuarioWhereInput
  }

  export type usuarioUpdateToOneWithWhereWithoutFacturaInput = {
    where?: usuarioWhereInput
    data: XOR<usuarioUpdateWithoutFacturaInput, usuarioUncheckedUpdateWithoutFacturaInput>
  }

  export type usuarioUpdateWithoutFacturaInput = {
    sexo?: StringFieldUpdateOperationsInput | string
    foto?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    fecnac?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    base64?: NullableStringFieldUpdateOperationsInput | string | null
    arte_arte_iduTousuario?: arteUpdateManyWithoutUsuario_arte_iduTousuarioNestedInput
    arte_arte_iduaTousuario?: arteUpdateManyWithoutUsuario_arte_iduaTousuarioNestedInput
    cotizacion?: cotizacionUpdateManyWithoutUsuarioNestedInput
    datos?: datosUpdateManyWithoutUsuarioNestedInput
    ordent?: ordentUpdateManyWithoutUsuarioNestedInput
    registrolaboral?: registrolaboralUpdateManyWithoutUsuarioNestedInput
    empresa?: empresaUpdateOneWithoutUsuarioNestedInput
    persona?: personaUpdateOneRequiredWithoutUsuarioNestedInput
    usurol?: usurolUpdateManyWithoutUsuarioNestedInput
  }

  export type usuarioUncheckedUpdateWithoutFacturaInput = {
    idu?: IntFieldUpdateOperationsInput | number
    sexo?: StringFieldUpdateOperationsInput | string
    foto?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    fecnac?: DateTimeFieldUpdateOperationsInput | Date | string
    idpe?: IntFieldUpdateOperationsInput | number
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    idem?: NullableIntFieldUpdateOperationsInput | number | null
    base64?: NullableStringFieldUpdateOperationsInput | string | null
    arte_arte_iduTousuario?: arteUncheckedUpdateManyWithoutUsuario_arte_iduTousuarioNestedInput
    arte_arte_iduaTousuario?: arteUncheckedUpdateManyWithoutUsuario_arte_iduaTousuarioNestedInput
    cotizacion?: cotizacionUncheckedUpdateManyWithoutUsuarioNestedInput
    datos?: datosUncheckedUpdateManyWithoutUsuarioNestedInput
    ordent?: ordentUncheckedUpdateManyWithoutUsuarioNestedInput
    registrolaboral?: registrolaboralUncheckedUpdateManyWithoutUsuarioNestedInput
    usurol?: usurolUncheckedUpdateManyWithoutUsuarioNestedInput
  }

  export type proveedorCreateWithoutInventarioInput = {
    nom?: string | null
    dir?: string | null
    dep?: string | null
    logo?: Buffer | null
    estado?: boolean | null
    nit?: string | null
    persona?: personaCreateNestedOneWithoutProveedorInput
  }

  export type proveedorUncheckedCreateWithoutInventarioInput = {
    idprov?: number
    nom?: string | null
    dir?: string | null
    dep?: string | null
    logo?: Buffer | null
    idpe?: number | null
    estado?: boolean | null
    nit?: string | null
  }

  export type proveedorCreateOrConnectWithoutInventarioInput = {
    where: proveedorWhereUniqueInput
    create: XOR<proveedorCreateWithoutInventarioInput, proveedorUncheckedCreateWithoutInventarioInput>
  }

  export type proveedorUpsertWithoutInventarioInput = {
    update: XOR<proveedorUpdateWithoutInventarioInput, proveedorUncheckedUpdateWithoutInventarioInput>
    create: XOR<proveedorCreateWithoutInventarioInput, proveedorUncheckedCreateWithoutInventarioInput>
    where?: proveedorWhereInput
  }

  export type proveedorUpdateToOneWithWhereWithoutInventarioInput = {
    where?: proveedorWhereInput
    data: XOR<proveedorUpdateWithoutInventarioInput, proveedorUncheckedUpdateWithoutInventarioInput>
  }

  export type proveedorUpdateWithoutInventarioInput = {
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    dir?: NullableStringFieldUpdateOperationsInput | string | null
    dep?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    nit?: NullableStringFieldUpdateOperationsInput | string | null
    persona?: personaUpdateOneWithoutProveedorNestedInput
  }

  export type proveedorUncheckedUpdateWithoutInventarioInput = {
    idprov?: IntFieldUpdateOperationsInput | number
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    dir?: NullableStringFieldUpdateOperationsInput | string | null
    dep?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    idpe?: NullableIntFieldUpdateOperationsInput | number | null
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    nit?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type empresaCreateWithoutLeyendaInput = {
    nom?: string | null
    dir?: string | null
    des?: string | null
    dep?: string | null
    logo?: Buffer | null
    nit?: string | null
    auto?: string | null
    base64?: string | null
    persona?: personaCreateNestedOneWithoutEmpresaInput
    usuario?: usuarioCreateNestedManyWithoutEmpresaInput
  }

  export type empresaUncheckedCreateWithoutLeyendaInput = {
    idem?: number
    nom?: string | null
    dir?: string | null
    des?: string | null
    dep?: string | null
    logo?: Buffer | null
    idpe?: number | null
    nit?: string | null
    auto?: string | null
    base64?: string | null
    usuario?: usuarioUncheckedCreateNestedManyWithoutEmpresaInput
  }

  export type empresaCreateOrConnectWithoutLeyendaInput = {
    where: empresaWhereUniqueInput
    create: XOR<empresaCreateWithoutLeyendaInput, empresaUncheckedCreateWithoutLeyendaInput>
  }

  export type empresaUpsertWithoutLeyendaInput = {
    update: XOR<empresaUpdateWithoutLeyendaInput, empresaUncheckedUpdateWithoutLeyendaInput>
    create: XOR<empresaCreateWithoutLeyendaInput, empresaUncheckedCreateWithoutLeyendaInput>
    where?: empresaWhereInput
  }

  export type empresaUpdateToOneWithWhereWithoutLeyendaInput = {
    where?: empresaWhereInput
    data: XOR<empresaUpdateWithoutLeyendaInput, empresaUncheckedUpdateWithoutLeyendaInput>
  }

  export type empresaUpdateWithoutLeyendaInput = {
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    dir?: NullableStringFieldUpdateOperationsInput | string | null
    des?: NullableStringFieldUpdateOperationsInput | string | null
    dep?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    nit?: NullableStringFieldUpdateOperationsInput | string | null
    auto?: NullableStringFieldUpdateOperationsInput | string | null
    base64?: NullableStringFieldUpdateOperationsInput | string | null
    persona?: personaUpdateOneWithoutEmpresaNestedInput
    usuario?: usuarioUpdateManyWithoutEmpresaNestedInput
  }

  export type empresaUncheckedUpdateWithoutLeyendaInput = {
    idem?: IntFieldUpdateOperationsInput | number
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    dir?: NullableStringFieldUpdateOperationsInput | string | null
    des?: NullableStringFieldUpdateOperationsInput | string | null
    dep?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    idpe?: NullableIntFieldUpdateOperationsInput | number | null
    nit?: NullableStringFieldUpdateOperationsInput | string | null
    auto?: NullableStringFieldUpdateOperationsInput | string | null
    base64?: NullableStringFieldUpdateOperationsInput | string | null
    usuario?: usuarioUncheckedUpdateManyWithoutEmpresaNestedInput
  }

  export type colorCreateWithoutMarcaInput = {
    nom?: string | null
    punit?: number | null
    estado?: boolean | null
    des?: string | null
  }

  export type colorUncheckedCreateWithoutMarcaInput = {
    idcolor?: number
    nom?: string | null
    punit?: number | null
    estado?: boolean | null
    des?: string | null
  }

  export type colorCreateOrConnectWithoutMarcaInput = {
    where: colorWhereUniqueInput
    create: XOR<colorCreateWithoutMarcaInput, colorUncheckedCreateWithoutMarcaInput>
  }

  export type colorCreateManyMarcaInputEnvelope = {
    data: colorCreateManyMarcaInput | colorCreateManyMarcaInput[]
    skipDuplicates?: boolean
  }

  export type productoCreateWithoutMarcaInput = {
    nom?: string | null
    tam?: string | null
    des?: string | null
    preciov?: number | null
    precioc?: number | null
    cantidad?: number | null
    foto?: Buffer | null
    estado?: boolean | null
    base64?: string | null
    ranking?: number | null
    detcot?: detcotCreateNestedManyWithoutProductoInput
    detot?: detotCreateNestedManyWithoutProductoInput
  }

  export type productoUncheckedCreateWithoutMarcaInput = {
    idpro?: number
    nom?: string | null
    tam?: string | null
    des?: string | null
    preciov?: number | null
    precioc?: number | null
    cantidad?: number | null
    foto?: Buffer | null
    estado?: boolean | null
    base64?: string | null
    ranking?: number | null
    detcot?: detcotUncheckedCreateNestedManyWithoutProductoInput
    detot?: detotUncheckedCreateNestedManyWithoutProductoInput
  }

  export type productoCreateOrConnectWithoutMarcaInput = {
    where: productoWhereUniqueInput
    create: XOR<productoCreateWithoutMarcaInput, productoUncheckedCreateWithoutMarcaInput>
  }

  export type productoCreateManyMarcaInputEnvelope = {
    data: productoCreateManyMarcaInput | productoCreateManyMarcaInput[]
    skipDuplicates?: boolean
  }

  export type terminadoCreateWithoutMarcaInput = {
    nom?: string | null
    punit?: number | null
    estado?: boolean | null
  }

  export type terminadoUncheckedCreateWithoutMarcaInput = {
    idter?: number
    nom?: string | null
    punit?: number | null
    estado?: boolean | null
  }

  export type terminadoCreateOrConnectWithoutMarcaInput = {
    where: terminadoWhereUniqueInput
    create: XOR<terminadoCreateWithoutMarcaInput, terminadoUncheckedCreateWithoutMarcaInput>
  }

  export type terminadoCreateManyMarcaInputEnvelope = {
    data: terminadoCreateManyMarcaInput | terminadoCreateManyMarcaInput[]
    skipDuplicates?: boolean
  }

  export type colorUpsertWithWhereUniqueWithoutMarcaInput = {
    where: colorWhereUniqueInput
    update: XOR<colorUpdateWithoutMarcaInput, colorUncheckedUpdateWithoutMarcaInput>
    create: XOR<colorCreateWithoutMarcaInput, colorUncheckedCreateWithoutMarcaInput>
  }

  export type colorUpdateWithWhereUniqueWithoutMarcaInput = {
    where: colorWhereUniqueInput
    data: XOR<colorUpdateWithoutMarcaInput, colorUncheckedUpdateWithoutMarcaInput>
  }

  export type colorUpdateManyWithWhereWithoutMarcaInput = {
    where: colorScalarWhereInput
    data: XOR<colorUpdateManyMutationInput, colorUncheckedUpdateManyWithoutMarcaInput>
  }

  export type colorScalarWhereInput = {
    AND?: colorScalarWhereInput | colorScalarWhereInput[]
    OR?: colorScalarWhereInput[]
    NOT?: colorScalarWhereInput | colorScalarWhereInput[]
    idcolor?: IntFilter<"color"> | number
    nom?: StringNullableFilter<"color"> | string | null
    punit?: FloatNullableFilter<"color"> | number | null
    idmar?: IntNullableFilter<"color"> | number | null
    estado?: BoolNullableFilter<"color"> | boolean | null
    des?: StringNullableFilter<"color"> | string | null
  }

  export type productoUpsertWithWhereUniqueWithoutMarcaInput = {
    where: productoWhereUniqueInput
    update: XOR<productoUpdateWithoutMarcaInput, productoUncheckedUpdateWithoutMarcaInput>
    create: XOR<productoCreateWithoutMarcaInput, productoUncheckedCreateWithoutMarcaInput>
  }

  export type productoUpdateWithWhereUniqueWithoutMarcaInput = {
    where: productoWhereUniqueInput
    data: XOR<productoUpdateWithoutMarcaInput, productoUncheckedUpdateWithoutMarcaInput>
  }

  export type productoUpdateManyWithWhereWithoutMarcaInput = {
    where: productoScalarWhereInput
    data: XOR<productoUpdateManyMutationInput, productoUncheckedUpdateManyWithoutMarcaInput>
  }

  export type productoScalarWhereInput = {
    AND?: productoScalarWhereInput | productoScalarWhereInput[]
    OR?: productoScalarWhereInput[]
    NOT?: productoScalarWhereInput | productoScalarWhereInput[]
    idpro?: IntFilter<"producto"> | number
    nom?: StringNullableFilter<"producto"> | string | null
    tam?: StringNullableFilter<"producto"> | string | null
    des?: StringNullableFilter<"producto"> | string | null
    preciov?: FloatNullableFilter<"producto"> | number | null
    precioc?: FloatNullableFilter<"producto"> | number | null
    cantidad?: IntNullableFilter<"producto"> | number | null
    foto?: BytesNullableFilter<"producto"> | Buffer | null
    idmar?: IntNullableFilter<"producto"> | number | null
    estado?: BoolNullableFilter<"producto"> | boolean | null
    base64?: StringNullableFilter<"producto"> | string | null
    ranking?: IntNullableFilter<"producto"> | number | null
  }

  export type terminadoUpsertWithWhereUniqueWithoutMarcaInput = {
    where: terminadoWhereUniqueInput
    update: XOR<terminadoUpdateWithoutMarcaInput, terminadoUncheckedUpdateWithoutMarcaInput>
    create: XOR<terminadoCreateWithoutMarcaInput, terminadoUncheckedCreateWithoutMarcaInput>
  }

  export type terminadoUpdateWithWhereUniqueWithoutMarcaInput = {
    where: terminadoWhereUniqueInput
    data: XOR<terminadoUpdateWithoutMarcaInput, terminadoUncheckedUpdateWithoutMarcaInput>
  }

  export type terminadoUpdateManyWithWhereWithoutMarcaInput = {
    where: terminadoScalarWhereInput
    data: XOR<terminadoUpdateManyMutationInput, terminadoUncheckedUpdateManyWithoutMarcaInput>
  }

  export type terminadoScalarWhereInput = {
    AND?: terminadoScalarWhereInput | terminadoScalarWhereInput[]
    OR?: terminadoScalarWhereInput[]
    NOT?: terminadoScalarWhereInput | terminadoScalarWhereInput[]
    idter?: IntFilter<"terminado"> | number
    nom?: StringNullableFilter<"terminado"> | string | null
    punit?: FloatNullableFilter<"terminado"> | number | null
    idmar?: IntNullableFilter<"terminado"> | number | null
    estado?: BoolNullableFilter<"terminado"> | boolean | null
  }

  export type rolmenuCreateWithoutMenuInput = {
    roles: rolesCreateNestedOneWithoutRolmenuInput
  }

  export type rolmenuUncheckedCreateWithoutMenuInput = {
    idr: number
  }

  export type rolmenuCreateOrConnectWithoutMenuInput = {
    where: rolmenuWhereUniqueInput
    create: XOR<rolmenuCreateWithoutMenuInput, rolmenuUncheckedCreateWithoutMenuInput>
  }

  export type rolmenuCreateManyMenuInputEnvelope = {
    data: rolmenuCreateManyMenuInput | rolmenuCreateManyMenuInput[]
    skipDuplicates?: boolean
  }

  export type rolmenuUpsertWithWhereUniqueWithoutMenuInput = {
    where: rolmenuWhereUniqueInput
    update: XOR<rolmenuUpdateWithoutMenuInput, rolmenuUncheckedUpdateWithoutMenuInput>
    create: XOR<rolmenuCreateWithoutMenuInput, rolmenuUncheckedCreateWithoutMenuInput>
  }

  export type rolmenuUpdateWithWhereUniqueWithoutMenuInput = {
    where: rolmenuWhereUniqueInput
    data: XOR<rolmenuUpdateWithoutMenuInput, rolmenuUncheckedUpdateWithoutMenuInput>
  }

  export type rolmenuUpdateManyWithWhereWithoutMenuInput = {
    where: rolmenuScalarWhereInput
    data: XOR<rolmenuUpdateManyMutationInput, rolmenuUncheckedUpdateManyWithoutMenuInput>
  }

  export type rolmenuScalarWhereInput = {
    AND?: rolmenuScalarWhereInput | rolmenuScalarWhereInput[]
    OR?: rolmenuScalarWhereInput[]
    NOT?: rolmenuScalarWhereInput | rolmenuScalarWhereInput[]
    idr?: IntFilter<"rolmenu"> | number
    idm?: IntFilter<"rolmenu"> | number
  }

  export type arteCreateWithoutOrdentInput = {
    fechar?: Date | string | null
    fechaa?: Date | string | null
    estado?: string | null
    obs?: string | null
    precio?: number | null
    usuario_arte_iduTousuario?: usuarioCreateNestedOneWithoutArte_arte_iduTousuarioInput
    usuario_arte_iduaTousuario?: usuarioCreateNestedOneWithoutArte_arte_iduaTousuarioInput
  }

  export type arteUncheckedCreateWithoutOrdentInput = {
    idar?: number
    idu?: number | null
    fechar?: Date | string | null
    fechaa?: Date | string | null
    idua?: number | null
    estado?: string | null
    obs?: string | null
    precio?: number | null
  }

  export type arteCreateOrConnectWithoutOrdentInput = {
    where: arteWhereUniqueInput
    create: XOR<arteCreateWithoutOrdentInput, arteUncheckedCreateWithoutOrdentInput>
  }

  export type arteCreateManyOrdentInputEnvelope = {
    data: arteCreateManyOrdentInput | arteCreateManyOrdentInput[]
    skipDuplicates?: boolean
  }

  export type detotCreateWithoutOrdentInput = {
    cant?: number | null
    punit?: number | null
    stotal?: number | null
    material?: string | null
    gr?: string | null
    tintas?: string | null
    estado?: boolean | null
    producto?: productoCreateNestedOneWithoutDetotInput
  }

  export type detotUncheckedCreateWithoutOrdentInput = {
    iddetot?: number
    idpro?: number | null
    cant?: number | null
    punit?: number | null
    stotal?: number | null
    material?: string | null
    gr?: string | null
    tintas?: string | null
    estado?: boolean | null
  }

  export type detotCreateOrConnectWithoutOrdentInput = {
    where: detotWhereUniqueInput
    create: XOR<detotCreateWithoutOrdentInput, detotUncheckedCreateWithoutOrdentInput>
  }

  export type detotCreateManyOrdentInputEnvelope = {
    data: detotCreateManyOrdentInput | detotCreateManyOrdentInput[]
    skipDuplicates?: boolean
  }

  export type facturaCreateWithoutOrdentInput = {
    monto?: number | null
    fecha?: Date | string | null
    aux?: string | null
    aux1?: string | null
    usuario?: usuarioCreateNestedOneWithoutFacturaInput
  }

  export type facturaUncheckedCreateWithoutOrdentInput = {
    idfac?: number
    idu?: number | null
    monto?: number | null
    fecha?: Date | string | null
    aux?: string | null
    aux1?: string | null
  }

  export type facturaCreateOrConnectWithoutOrdentInput = {
    where: facturaWhereUniqueInput
    create: XOR<facturaCreateWithoutOrdentInput, facturaUncheckedCreateWithoutOrdentInput>
  }

  export type facturaCreateManyOrdentInputEnvelope = {
    data: facturaCreateManyOrdentInput | facturaCreateManyOrdentInput[]
    skipDuplicates?: boolean
  }

  export type clienteCreateWithoutOrdentInput = {
    estado?: boolean | null
    persona: personaCreateNestedOneWithoutClienteInput
    cotizacion?: cotizacionCreateNestedManyWithoutClienteInput
  }

  export type clienteUncheckedCreateWithoutOrdentInput = {
    idcli?: number
    idpe: number
    estado?: boolean | null
    cotizacion?: cotizacionUncheckedCreateNestedManyWithoutClienteInput
  }

  export type clienteCreateOrConnectWithoutOrdentInput = {
    where: clienteWhereUniqueInput
    create: XOR<clienteCreateWithoutOrdentInput, clienteUncheckedCreateWithoutOrdentInput>
  }

  export type cotizacionCreateWithoutOrdentInput = {
    fecha?: Date | string | null
    precio?: number | null
    descuento?: number | null
    preciofinal?: number | null
    tiempo?: number | null
    arte?: string | null
    obs?: string | null
    estado?: string | null
    cliente?: clienteCreateNestedOneWithoutCotizacionInput
    usuario?: usuarioCreateNestedOneWithoutCotizacionInput
    detcot?: detcotCreateNestedManyWithoutCotizacionInput
  }

  export type cotizacionUncheckedCreateWithoutOrdentInput = {
    idcot?: number
    idu?: number | null
    idcli?: number | null
    fecha?: Date | string | null
    precio?: number | null
    descuento?: number | null
    preciofinal?: number | null
    tiempo?: number | null
    arte?: string | null
    obs?: string | null
    estado?: string | null
    detcot?: detcotUncheckedCreateNestedManyWithoutCotizacionInput
  }

  export type cotizacionCreateOrConnectWithoutOrdentInput = {
    where: cotizacionWhereUniqueInput
    create: XOR<cotizacionCreateWithoutOrdentInput, cotizacionUncheckedCreateWithoutOrdentInput>
  }

  export type usuarioCreateWithoutOrdentInput = {
    sexo: string
    foto?: Buffer | null
    fecnac: Date | string
    estado?: boolean | null
    base64?: string | null
    arte_arte_iduTousuario?: arteCreateNestedManyWithoutUsuario_arte_iduTousuarioInput
    arte_arte_iduaTousuario?: arteCreateNestedManyWithoutUsuario_arte_iduaTousuarioInput
    cotizacion?: cotizacionCreateNestedManyWithoutUsuarioInput
    datos?: datosCreateNestedManyWithoutUsuarioInput
    factura?: facturaCreateNestedManyWithoutUsuarioInput
    registrolaboral?: registrolaboralCreateNestedManyWithoutUsuarioInput
    empresa?: empresaCreateNestedOneWithoutUsuarioInput
    persona: personaCreateNestedOneWithoutUsuarioInput
    usurol?: usurolCreateNestedManyWithoutUsuarioInput
  }

  export type usuarioUncheckedCreateWithoutOrdentInput = {
    idu?: number
    sexo: string
    foto?: Buffer | null
    fecnac: Date | string
    idpe: number
    estado?: boolean | null
    idem?: number | null
    base64?: string | null
    arte_arte_iduTousuario?: arteUncheckedCreateNestedManyWithoutUsuario_arte_iduTousuarioInput
    arte_arte_iduaTousuario?: arteUncheckedCreateNestedManyWithoutUsuario_arte_iduaTousuarioInput
    cotizacion?: cotizacionUncheckedCreateNestedManyWithoutUsuarioInput
    datos?: datosUncheckedCreateNestedManyWithoutUsuarioInput
    factura?: facturaUncheckedCreateNestedManyWithoutUsuarioInput
    registrolaboral?: registrolaboralUncheckedCreateNestedManyWithoutUsuarioInput
    usurol?: usurolUncheckedCreateNestedManyWithoutUsuarioInput
  }

  export type usuarioCreateOrConnectWithoutOrdentInput = {
    where: usuarioWhereUniqueInput
    create: XOR<usuarioCreateWithoutOrdentInput, usuarioUncheckedCreateWithoutOrdentInput>
  }

  export type pagoCreateWithoutOrdentInput = {
    fecha?: Date | string | null
    preciof?: number | null
    pago?: number | null
    saldo?: number | null
    des?: string | null
    comprobante?: Buffer | null
  }

  export type pagoUncheckedCreateWithoutOrdentInput = {
    idpagp?: number
    fecha?: Date | string | null
    preciof?: number | null
    pago?: number | null
    saldo?: number | null
    des?: string | null
    comprobante?: Buffer | null
  }

  export type pagoCreateOrConnectWithoutOrdentInput = {
    where: pagoWhereUniqueInput
    create: XOR<pagoCreateWithoutOrdentInput, pagoUncheckedCreateWithoutOrdentInput>
  }

  export type pagoCreateManyOrdentInputEnvelope = {
    data: pagoCreateManyOrdentInput | pagoCreateManyOrdentInput[]
    skipDuplicates?: boolean
  }

  export type arteUpsertWithWhereUniqueWithoutOrdentInput = {
    where: arteWhereUniqueInput
    update: XOR<arteUpdateWithoutOrdentInput, arteUncheckedUpdateWithoutOrdentInput>
    create: XOR<arteCreateWithoutOrdentInput, arteUncheckedCreateWithoutOrdentInput>
  }

  export type arteUpdateWithWhereUniqueWithoutOrdentInput = {
    where: arteWhereUniqueInput
    data: XOR<arteUpdateWithoutOrdentInput, arteUncheckedUpdateWithoutOrdentInput>
  }

  export type arteUpdateManyWithWhereWithoutOrdentInput = {
    where: arteScalarWhereInput
    data: XOR<arteUpdateManyMutationInput, arteUncheckedUpdateManyWithoutOrdentInput>
  }

  export type arteScalarWhereInput = {
    AND?: arteScalarWhereInput | arteScalarWhereInput[]
    OR?: arteScalarWhereInput[]
    NOT?: arteScalarWhereInput | arteScalarWhereInput[]
    idar?: IntFilter<"arte"> | number
    idu?: IntNullableFilter<"arte"> | number | null
    idot?: IntNullableFilter<"arte"> | number | null
    fechar?: DateTimeNullableFilter<"arte"> | Date | string | null
    fechaa?: DateTimeNullableFilter<"arte"> | Date | string | null
    idua?: IntNullableFilter<"arte"> | number | null
    estado?: StringNullableFilter<"arte"> | string | null
    obs?: StringNullableFilter<"arte"> | string | null
    precio?: FloatNullableFilter<"arte"> | number | null
  }

  export type detotUpsertWithWhereUniqueWithoutOrdentInput = {
    where: detotWhereUniqueInput
    update: XOR<detotUpdateWithoutOrdentInput, detotUncheckedUpdateWithoutOrdentInput>
    create: XOR<detotCreateWithoutOrdentInput, detotUncheckedCreateWithoutOrdentInput>
  }

  export type detotUpdateWithWhereUniqueWithoutOrdentInput = {
    where: detotWhereUniqueInput
    data: XOR<detotUpdateWithoutOrdentInput, detotUncheckedUpdateWithoutOrdentInput>
  }

  export type detotUpdateManyWithWhereWithoutOrdentInput = {
    where: detotScalarWhereInput
    data: XOR<detotUpdateManyMutationInput, detotUncheckedUpdateManyWithoutOrdentInput>
  }

  export type detotScalarWhereInput = {
    AND?: detotScalarWhereInput | detotScalarWhereInput[]
    OR?: detotScalarWhereInput[]
    NOT?: detotScalarWhereInput | detotScalarWhereInput[]
    iddetot?: IntFilter<"detot"> | number
    idot?: IntNullableFilter<"detot"> | number | null
    idpro?: IntNullableFilter<"detot"> | number | null
    cant?: IntNullableFilter<"detot"> | number | null
    punit?: FloatNullableFilter<"detot"> | number | null
    stotal?: FloatNullableFilter<"detot"> | number | null
    material?: StringNullableFilter<"detot"> | string | null
    gr?: StringNullableFilter<"detot"> | string | null
    tintas?: StringNullableFilter<"detot"> | string | null
    estado?: BoolNullableFilter<"detot"> | boolean | null
  }

  export type facturaUpsertWithWhereUniqueWithoutOrdentInput = {
    where: facturaWhereUniqueInput
    update: XOR<facturaUpdateWithoutOrdentInput, facturaUncheckedUpdateWithoutOrdentInput>
    create: XOR<facturaCreateWithoutOrdentInput, facturaUncheckedCreateWithoutOrdentInput>
  }

  export type facturaUpdateWithWhereUniqueWithoutOrdentInput = {
    where: facturaWhereUniqueInput
    data: XOR<facturaUpdateWithoutOrdentInput, facturaUncheckedUpdateWithoutOrdentInput>
  }

  export type facturaUpdateManyWithWhereWithoutOrdentInput = {
    where: facturaScalarWhereInput
    data: XOR<facturaUpdateManyMutationInput, facturaUncheckedUpdateManyWithoutOrdentInput>
  }

  export type facturaScalarWhereInput = {
    AND?: facturaScalarWhereInput | facturaScalarWhereInput[]
    OR?: facturaScalarWhereInput[]
    NOT?: facturaScalarWhereInput | facturaScalarWhereInput[]
    idfac?: IntFilter<"factura"> | number
    idot?: IntNullableFilter<"factura"> | number | null
    idu?: IntNullableFilter<"factura"> | number | null
    monto?: FloatNullableFilter<"factura"> | number | null
    fecha?: DateTimeNullableFilter<"factura"> | Date | string | null
    aux?: StringNullableFilter<"factura"> | string | null
    aux1?: StringNullableFilter<"factura"> | string | null
  }

  export type clienteUpsertWithoutOrdentInput = {
    update: XOR<clienteUpdateWithoutOrdentInput, clienteUncheckedUpdateWithoutOrdentInput>
    create: XOR<clienteCreateWithoutOrdentInput, clienteUncheckedCreateWithoutOrdentInput>
    where?: clienteWhereInput
  }

  export type clienteUpdateToOneWithWhereWithoutOrdentInput = {
    where?: clienteWhereInput
    data: XOR<clienteUpdateWithoutOrdentInput, clienteUncheckedUpdateWithoutOrdentInput>
  }

  export type clienteUpdateWithoutOrdentInput = {
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    persona?: personaUpdateOneRequiredWithoutClienteNestedInput
    cotizacion?: cotizacionUpdateManyWithoutClienteNestedInput
  }

  export type clienteUncheckedUpdateWithoutOrdentInput = {
    idcli?: IntFieldUpdateOperationsInput | number
    idpe?: IntFieldUpdateOperationsInput | number
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    cotizacion?: cotizacionUncheckedUpdateManyWithoutClienteNestedInput
  }

  export type cotizacionUpsertWithoutOrdentInput = {
    update: XOR<cotizacionUpdateWithoutOrdentInput, cotizacionUncheckedUpdateWithoutOrdentInput>
    create: XOR<cotizacionCreateWithoutOrdentInput, cotizacionUncheckedCreateWithoutOrdentInput>
    where?: cotizacionWhereInput
  }

  export type cotizacionUpdateToOneWithWhereWithoutOrdentInput = {
    where?: cotizacionWhereInput
    data: XOR<cotizacionUpdateWithoutOrdentInput, cotizacionUncheckedUpdateWithoutOrdentInput>
  }

  export type cotizacionUpdateWithoutOrdentInput = {
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    precio?: NullableFloatFieldUpdateOperationsInput | number | null
    descuento?: NullableFloatFieldUpdateOperationsInput | number | null
    preciofinal?: NullableFloatFieldUpdateOperationsInput | number | null
    tiempo?: NullableIntFieldUpdateOperationsInput | number | null
    arte?: NullableStringFieldUpdateOperationsInput | string | null
    obs?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableStringFieldUpdateOperationsInput | string | null
    cliente?: clienteUpdateOneWithoutCotizacionNestedInput
    usuario?: usuarioUpdateOneWithoutCotizacionNestedInput
    detcot?: detcotUpdateManyWithoutCotizacionNestedInput
  }

  export type cotizacionUncheckedUpdateWithoutOrdentInput = {
    idcot?: IntFieldUpdateOperationsInput | number
    idu?: NullableIntFieldUpdateOperationsInput | number | null
    idcli?: NullableIntFieldUpdateOperationsInput | number | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    precio?: NullableFloatFieldUpdateOperationsInput | number | null
    descuento?: NullableFloatFieldUpdateOperationsInput | number | null
    preciofinal?: NullableFloatFieldUpdateOperationsInput | number | null
    tiempo?: NullableIntFieldUpdateOperationsInput | number | null
    arte?: NullableStringFieldUpdateOperationsInput | string | null
    obs?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableStringFieldUpdateOperationsInput | string | null
    detcot?: detcotUncheckedUpdateManyWithoutCotizacionNestedInput
  }

  export type usuarioUpsertWithoutOrdentInput = {
    update: XOR<usuarioUpdateWithoutOrdentInput, usuarioUncheckedUpdateWithoutOrdentInput>
    create: XOR<usuarioCreateWithoutOrdentInput, usuarioUncheckedCreateWithoutOrdentInput>
    where?: usuarioWhereInput
  }

  export type usuarioUpdateToOneWithWhereWithoutOrdentInput = {
    where?: usuarioWhereInput
    data: XOR<usuarioUpdateWithoutOrdentInput, usuarioUncheckedUpdateWithoutOrdentInput>
  }

  export type usuarioUpdateWithoutOrdentInput = {
    sexo?: StringFieldUpdateOperationsInput | string
    foto?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    fecnac?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    base64?: NullableStringFieldUpdateOperationsInput | string | null
    arte_arte_iduTousuario?: arteUpdateManyWithoutUsuario_arte_iduTousuarioNestedInput
    arte_arte_iduaTousuario?: arteUpdateManyWithoutUsuario_arte_iduaTousuarioNestedInput
    cotizacion?: cotizacionUpdateManyWithoutUsuarioNestedInput
    datos?: datosUpdateManyWithoutUsuarioNestedInput
    factura?: facturaUpdateManyWithoutUsuarioNestedInput
    registrolaboral?: registrolaboralUpdateManyWithoutUsuarioNestedInput
    empresa?: empresaUpdateOneWithoutUsuarioNestedInput
    persona?: personaUpdateOneRequiredWithoutUsuarioNestedInput
    usurol?: usurolUpdateManyWithoutUsuarioNestedInput
  }

  export type usuarioUncheckedUpdateWithoutOrdentInput = {
    idu?: IntFieldUpdateOperationsInput | number
    sexo?: StringFieldUpdateOperationsInput | string
    foto?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    fecnac?: DateTimeFieldUpdateOperationsInput | Date | string
    idpe?: IntFieldUpdateOperationsInput | number
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    idem?: NullableIntFieldUpdateOperationsInput | number | null
    base64?: NullableStringFieldUpdateOperationsInput | string | null
    arte_arte_iduTousuario?: arteUncheckedUpdateManyWithoutUsuario_arte_iduTousuarioNestedInput
    arte_arte_iduaTousuario?: arteUncheckedUpdateManyWithoutUsuario_arte_iduaTousuarioNestedInput
    cotizacion?: cotizacionUncheckedUpdateManyWithoutUsuarioNestedInput
    datos?: datosUncheckedUpdateManyWithoutUsuarioNestedInput
    factura?: facturaUncheckedUpdateManyWithoutUsuarioNestedInput
    registrolaboral?: registrolaboralUncheckedUpdateManyWithoutUsuarioNestedInput
    usurol?: usurolUncheckedUpdateManyWithoutUsuarioNestedInput
  }

  export type pagoUpsertWithWhereUniqueWithoutOrdentInput = {
    where: pagoWhereUniqueInput
    update: XOR<pagoUpdateWithoutOrdentInput, pagoUncheckedUpdateWithoutOrdentInput>
    create: XOR<pagoCreateWithoutOrdentInput, pagoUncheckedCreateWithoutOrdentInput>
  }

  export type pagoUpdateWithWhereUniqueWithoutOrdentInput = {
    where: pagoWhereUniqueInput
    data: XOR<pagoUpdateWithoutOrdentInput, pagoUncheckedUpdateWithoutOrdentInput>
  }

  export type pagoUpdateManyWithWhereWithoutOrdentInput = {
    where: pagoScalarWhereInput
    data: XOR<pagoUpdateManyMutationInput, pagoUncheckedUpdateManyWithoutOrdentInput>
  }

  export type pagoScalarWhereInput = {
    AND?: pagoScalarWhereInput | pagoScalarWhereInput[]
    OR?: pagoScalarWhereInput[]
    NOT?: pagoScalarWhereInput | pagoScalarWhereInput[]
    idpagp?: IntFilter<"pago"> | number
    idot?: IntNullableFilter<"pago"> | number | null
    fecha?: DateTimeNullableFilter<"pago"> | Date | string | null
    preciof?: FloatNullableFilter<"pago"> | number | null
    pago?: FloatNullableFilter<"pago"> | number | null
    saldo?: FloatNullableFilter<"pago"> | number | null
    des?: StringNullableFilter<"pago"> | string | null
    comprobante?: BytesNullableFilter<"pago"> | Buffer | null
  }

  export type ordentCreateWithoutPagoInput = {
    fecha?: Date | string | null
    precio?: number | null
    descuento?: number | null
    preciofinal?: number | null
    tiempo?: number | null
    arte?: string | null
    obs?: string | null
    estado?: string | null
    factura?: string | null
    arte1?: arteCreateNestedManyWithoutOrdentInput
    detot?: detotCreateNestedManyWithoutOrdentInput
    factura1?: facturaCreateNestedManyWithoutOrdentInput
    cliente?: clienteCreateNestedOneWithoutOrdentInput
    cotizacion?: cotizacionCreateNestedOneWithoutOrdentInput
    usuario?: usuarioCreateNestedOneWithoutOrdentInput
  }

  export type ordentUncheckedCreateWithoutPagoInput = {
    idot?: number
    idu?: number | null
    idcli?: number | null
    idcot?: number | null
    fecha?: Date | string | null
    precio?: number | null
    descuento?: number | null
    preciofinal?: number | null
    tiempo?: number | null
    arte?: string | null
    obs?: string | null
    estado?: string | null
    factura?: string | null
    arte1?: arteUncheckedCreateNestedManyWithoutOrdentInput
    detot?: detotUncheckedCreateNestedManyWithoutOrdentInput
    factura1?: facturaUncheckedCreateNestedManyWithoutOrdentInput
  }

  export type ordentCreateOrConnectWithoutPagoInput = {
    where: ordentWhereUniqueInput
    create: XOR<ordentCreateWithoutPagoInput, ordentUncheckedCreateWithoutPagoInput>
  }

  export type ordentUpsertWithoutPagoInput = {
    update: XOR<ordentUpdateWithoutPagoInput, ordentUncheckedUpdateWithoutPagoInput>
    create: XOR<ordentCreateWithoutPagoInput, ordentUncheckedCreateWithoutPagoInput>
    where?: ordentWhereInput
  }

  export type ordentUpdateToOneWithWhereWithoutPagoInput = {
    where?: ordentWhereInput
    data: XOR<ordentUpdateWithoutPagoInput, ordentUncheckedUpdateWithoutPagoInput>
  }

  export type ordentUpdateWithoutPagoInput = {
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    precio?: NullableFloatFieldUpdateOperationsInput | number | null
    descuento?: NullableFloatFieldUpdateOperationsInput | number | null
    preciofinal?: NullableFloatFieldUpdateOperationsInput | number | null
    tiempo?: NullableIntFieldUpdateOperationsInput | number | null
    arte?: NullableStringFieldUpdateOperationsInput | string | null
    obs?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableStringFieldUpdateOperationsInput | string | null
    factura?: NullableStringFieldUpdateOperationsInput | string | null
    arte1?: arteUpdateManyWithoutOrdentNestedInput
    detot?: detotUpdateManyWithoutOrdentNestedInput
    factura1?: facturaUpdateManyWithoutOrdentNestedInput
    cliente?: clienteUpdateOneWithoutOrdentNestedInput
    cotizacion?: cotizacionUpdateOneWithoutOrdentNestedInput
    usuario?: usuarioUpdateOneWithoutOrdentNestedInput
  }

  export type ordentUncheckedUpdateWithoutPagoInput = {
    idot?: IntFieldUpdateOperationsInput | number
    idu?: NullableIntFieldUpdateOperationsInput | number | null
    idcli?: NullableIntFieldUpdateOperationsInput | number | null
    idcot?: NullableIntFieldUpdateOperationsInput | number | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    precio?: NullableFloatFieldUpdateOperationsInput | number | null
    descuento?: NullableFloatFieldUpdateOperationsInput | number | null
    preciofinal?: NullableFloatFieldUpdateOperationsInput | number | null
    tiempo?: NullableIntFieldUpdateOperationsInput | number | null
    arte?: NullableStringFieldUpdateOperationsInput | string | null
    obs?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableStringFieldUpdateOperationsInput | string | null
    factura?: NullableStringFieldUpdateOperationsInput | string | null
    arte1?: arteUncheckedUpdateManyWithoutOrdentNestedInput
    detot?: detotUncheckedUpdateManyWithoutOrdentNestedInput
    factura1?: facturaUncheckedUpdateManyWithoutOrdentNestedInput
  }

  export type clienteCreateWithoutPersonaInput = {
    estado?: boolean | null
    cotizacion?: cotizacionCreateNestedManyWithoutClienteInput
    ordent?: ordentCreateNestedManyWithoutClienteInput
  }

  export type clienteUncheckedCreateWithoutPersonaInput = {
    idcli?: number
    estado?: boolean | null
    cotizacion?: cotizacionUncheckedCreateNestedManyWithoutClienteInput
    ordent?: ordentUncheckedCreateNestedManyWithoutClienteInput
  }

  export type clienteCreateOrConnectWithoutPersonaInput = {
    where: clienteWhereUniqueInput
    create: XOR<clienteCreateWithoutPersonaInput, clienteUncheckedCreateWithoutPersonaInput>
  }

  export type clienteCreateManyPersonaInputEnvelope = {
    data: clienteCreateManyPersonaInput | clienteCreateManyPersonaInput[]
    skipDuplicates?: boolean
  }

  export type empresaCreateWithoutPersonaInput = {
    nom?: string | null
    dir?: string | null
    des?: string | null
    dep?: string | null
    logo?: Buffer | null
    nit?: string | null
    auto?: string | null
    base64?: string | null
    leyenda?: leyendaCreateNestedManyWithoutEmpresaInput
    usuario?: usuarioCreateNestedManyWithoutEmpresaInput
  }

  export type empresaUncheckedCreateWithoutPersonaInput = {
    idem?: number
    nom?: string | null
    dir?: string | null
    des?: string | null
    dep?: string | null
    logo?: Buffer | null
    nit?: string | null
    auto?: string | null
    base64?: string | null
    leyenda?: leyendaUncheckedCreateNestedManyWithoutEmpresaInput
    usuario?: usuarioUncheckedCreateNestedManyWithoutEmpresaInput
  }

  export type empresaCreateOrConnectWithoutPersonaInput = {
    where: empresaWhereUniqueInput
    create: XOR<empresaCreateWithoutPersonaInput, empresaUncheckedCreateWithoutPersonaInput>
  }

  export type empresaCreateManyPersonaInputEnvelope = {
    data: empresaCreateManyPersonaInput | empresaCreateManyPersonaInput[]
    skipDuplicates?: boolean
  }

  export type proveedorCreateWithoutPersonaInput = {
    nom?: string | null
    dir?: string | null
    dep?: string | null
    logo?: Buffer | null
    estado?: boolean | null
    nit?: string | null
    inventario?: inventarioCreateNestedManyWithoutProveedorInput
  }

  export type proveedorUncheckedCreateWithoutPersonaInput = {
    idprov?: number
    nom?: string | null
    dir?: string | null
    dep?: string | null
    logo?: Buffer | null
    estado?: boolean | null
    nit?: string | null
    inventario?: inventarioUncheckedCreateNestedManyWithoutProveedorInput
  }

  export type proveedorCreateOrConnectWithoutPersonaInput = {
    where: proveedorWhereUniqueInput
    create: XOR<proveedorCreateWithoutPersonaInput, proveedorUncheckedCreateWithoutPersonaInput>
  }

  export type proveedorCreateManyPersonaInputEnvelope = {
    data: proveedorCreateManyPersonaInput | proveedorCreateManyPersonaInput[]
    skipDuplicates?: boolean
  }

  export type telefonoCreateWithoutPersonaInput = {
    numero: string
    estado?: boolean | null
  }

  export type telefonoUncheckedCreateWithoutPersonaInput = {
    idtel?: number
    numero: string
    estado?: boolean | null
  }

  export type telefonoCreateOrConnectWithoutPersonaInput = {
    where: telefonoWhereUniqueInput
    create: XOR<telefonoCreateWithoutPersonaInput, telefonoUncheckedCreateWithoutPersonaInput>
  }

  export type telefonoCreateManyPersonaInputEnvelope = {
    data: telefonoCreateManyPersonaInput | telefonoCreateManyPersonaInput[]
    skipDuplicates?: boolean
  }

  export type usuarioCreateWithoutPersonaInput = {
    sexo: string
    foto?: Buffer | null
    fecnac: Date | string
    estado?: boolean | null
    base64?: string | null
    arte_arte_iduTousuario?: arteCreateNestedManyWithoutUsuario_arte_iduTousuarioInput
    arte_arte_iduaTousuario?: arteCreateNestedManyWithoutUsuario_arte_iduaTousuarioInput
    cotizacion?: cotizacionCreateNestedManyWithoutUsuarioInput
    datos?: datosCreateNestedManyWithoutUsuarioInput
    factura?: facturaCreateNestedManyWithoutUsuarioInput
    ordent?: ordentCreateNestedManyWithoutUsuarioInput
    registrolaboral?: registrolaboralCreateNestedManyWithoutUsuarioInput
    empresa?: empresaCreateNestedOneWithoutUsuarioInput
    usurol?: usurolCreateNestedManyWithoutUsuarioInput
  }

  export type usuarioUncheckedCreateWithoutPersonaInput = {
    idu?: number
    sexo: string
    foto?: Buffer | null
    fecnac: Date | string
    estado?: boolean | null
    idem?: number | null
    base64?: string | null
    arte_arte_iduTousuario?: arteUncheckedCreateNestedManyWithoutUsuario_arte_iduTousuarioInput
    arte_arte_iduaTousuario?: arteUncheckedCreateNestedManyWithoutUsuario_arte_iduaTousuarioInput
    cotizacion?: cotizacionUncheckedCreateNestedManyWithoutUsuarioInput
    datos?: datosUncheckedCreateNestedManyWithoutUsuarioInput
    factura?: facturaUncheckedCreateNestedManyWithoutUsuarioInput
    ordent?: ordentUncheckedCreateNestedManyWithoutUsuarioInput
    registrolaboral?: registrolaboralUncheckedCreateNestedManyWithoutUsuarioInput
    usurol?: usurolUncheckedCreateNestedManyWithoutUsuarioInput
  }

  export type usuarioCreateOrConnectWithoutPersonaInput = {
    where: usuarioWhereUniqueInput
    create: XOR<usuarioCreateWithoutPersonaInput, usuarioUncheckedCreateWithoutPersonaInput>
  }

  export type usuarioCreateManyPersonaInputEnvelope = {
    data: usuarioCreateManyPersonaInput | usuarioCreateManyPersonaInput[]
    skipDuplicates?: boolean
  }

  export type clienteUpsertWithWhereUniqueWithoutPersonaInput = {
    where: clienteWhereUniqueInput
    update: XOR<clienteUpdateWithoutPersonaInput, clienteUncheckedUpdateWithoutPersonaInput>
    create: XOR<clienteCreateWithoutPersonaInput, clienteUncheckedCreateWithoutPersonaInput>
  }

  export type clienteUpdateWithWhereUniqueWithoutPersonaInput = {
    where: clienteWhereUniqueInput
    data: XOR<clienteUpdateWithoutPersonaInput, clienteUncheckedUpdateWithoutPersonaInput>
  }

  export type clienteUpdateManyWithWhereWithoutPersonaInput = {
    where: clienteScalarWhereInput
    data: XOR<clienteUpdateManyMutationInput, clienteUncheckedUpdateManyWithoutPersonaInput>
  }

  export type clienteScalarWhereInput = {
    AND?: clienteScalarWhereInput | clienteScalarWhereInput[]
    OR?: clienteScalarWhereInput[]
    NOT?: clienteScalarWhereInput | clienteScalarWhereInput[]
    idcli?: IntFilter<"cliente"> | number
    idpe?: IntFilter<"cliente"> | number
    estado?: BoolNullableFilter<"cliente"> | boolean | null
  }

  export type empresaUpsertWithWhereUniqueWithoutPersonaInput = {
    where: empresaWhereUniqueInput
    update: XOR<empresaUpdateWithoutPersonaInput, empresaUncheckedUpdateWithoutPersonaInput>
    create: XOR<empresaCreateWithoutPersonaInput, empresaUncheckedCreateWithoutPersonaInput>
  }

  export type empresaUpdateWithWhereUniqueWithoutPersonaInput = {
    where: empresaWhereUniqueInput
    data: XOR<empresaUpdateWithoutPersonaInput, empresaUncheckedUpdateWithoutPersonaInput>
  }

  export type empresaUpdateManyWithWhereWithoutPersonaInput = {
    where: empresaScalarWhereInput
    data: XOR<empresaUpdateManyMutationInput, empresaUncheckedUpdateManyWithoutPersonaInput>
  }

  export type empresaScalarWhereInput = {
    AND?: empresaScalarWhereInput | empresaScalarWhereInput[]
    OR?: empresaScalarWhereInput[]
    NOT?: empresaScalarWhereInput | empresaScalarWhereInput[]
    idem?: IntFilter<"empresa"> | number
    nom?: StringNullableFilter<"empresa"> | string | null
    dir?: StringNullableFilter<"empresa"> | string | null
    des?: StringNullableFilter<"empresa"> | string | null
    dep?: StringNullableFilter<"empresa"> | string | null
    logo?: BytesNullableFilter<"empresa"> | Buffer | null
    idpe?: IntNullableFilter<"empresa"> | number | null
    nit?: StringNullableFilter<"empresa"> | string | null
    auto?: StringNullableFilter<"empresa"> | string | null
    base64?: StringNullableFilter<"empresa"> | string | null
  }

  export type proveedorUpsertWithWhereUniqueWithoutPersonaInput = {
    where: proveedorWhereUniqueInput
    update: XOR<proveedorUpdateWithoutPersonaInput, proveedorUncheckedUpdateWithoutPersonaInput>
    create: XOR<proveedorCreateWithoutPersonaInput, proveedorUncheckedCreateWithoutPersonaInput>
  }

  export type proveedorUpdateWithWhereUniqueWithoutPersonaInput = {
    where: proveedorWhereUniqueInput
    data: XOR<proveedorUpdateWithoutPersonaInput, proveedorUncheckedUpdateWithoutPersonaInput>
  }

  export type proveedorUpdateManyWithWhereWithoutPersonaInput = {
    where: proveedorScalarWhereInput
    data: XOR<proveedorUpdateManyMutationInput, proveedorUncheckedUpdateManyWithoutPersonaInput>
  }

  export type proveedorScalarWhereInput = {
    AND?: proveedorScalarWhereInput | proveedorScalarWhereInput[]
    OR?: proveedorScalarWhereInput[]
    NOT?: proveedorScalarWhereInput | proveedorScalarWhereInput[]
    idprov?: IntFilter<"proveedor"> | number
    nom?: StringNullableFilter<"proveedor"> | string | null
    dir?: StringNullableFilter<"proveedor"> | string | null
    dep?: StringNullableFilter<"proveedor"> | string | null
    logo?: BytesNullableFilter<"proveedor"> | Buffer | null
    idpe?: IntNullableFilter<"proveedor"> | number | null
    estado?: BoolNullableFilter<"proveedor"> | boolean | null
    nit?: StringNullableFilter<"proveedor"> | string | null
  }

  export type telefonoUpsertWithWhereUniqueWithoutPersonaInput = {
    where: telefonoWhereUniqueInput
    update: XOR<telefonoUpdateWithoutPersonaInput, telefonoUncheckedUpdateWithoutPersonaInput>
    create: XOR<telefonoCreateWithoutPersonaInput, telefonoUncheckedCreateWithoutPersonaInput>
  }

  export type telefonoUpdateWithWhereUniqueWithoutPersonaInput = {
    where: telefonoWhereUniqueInput
    data: XOR<telefonoUpdateWithoutPersonaInput, telefonoUncheckedUpdateWithoutPersonaInput>
  }

  export type telefonoUpdateManyWithWhereWithoutPersonaInput = {
    where: telefonoScalarWhereInput
    data: XOR<telefonoUpdateManyMutationInput, telefonoUncheckedUpdateManyWithoutPersonaInput>
  }

  export type telefonoScalarWhereInput = {
    AND?: telefonoScalarWhereInput | telefonoScalarWhereInput[]
    OR?: telefonoScalarWhereInput[]
    NOT?: telefonoScalarWhereInput | telefonoScalarWhereInput[]
    idtel?: IntFilter<"telefono"> | number
    idpe?: IntFilter<"telefono"> | number
    numero?: StringFilter<"telefono"> | string
    estado?: BoolNullableFilter<"telefono"> | boolean | null
  }

  export type usuarioUpsertWithWhereUniqueWithoutPersonaInput = {
    where: usuarioWhereUniqueInput
    update: XOR<usuarioUpdateWithoutPersonaInput, usuarioUncheckedUpdateWithoutPersonaInput>
    create: XOR<usuarioCreateWithoutPersonaInput, usuarioUncheckedCreateWithoutPersonaInput>
  }

  export type usuarioUpdateWithWhereUniqueWithoutPersonaInput = {
    where: usuarioWhereUniqueInput
    data: XOR<usuarioUpdateWithoutPersonaInput, usuarioUncheckedUpdateWithoutPersonaInput>
  }

  export type usuarioUpdateManyWithWhereWithoutPersonaInput = {
    where: usuarioScalarWhereInput
    data: XOR<usuarioUpdateManyMutationInput, usuarioUncheckedUpdateManyWithoutPersonaInput>
  }

  export type detcotCreateWithoutProductoInput = {
    cant?: number | null
    punit?: number | null
    stotal?: number | null
    material?: string | null
    gr?: string | null
    tintas?: string | null
    estado?: boolean | null
    cotizacion?: cotizacionCreateNestedOneWithoutDetcotInput
  }

  export type detcotUncheckedCreateWithoutProductoInput = {
    iddetcot?: number
    idcot?: number | null
    cant?: number | null
    punit?: number | null
    stotal?: number | null
    material?: string | null
    gr?: string | null
    tintas?: string | null
    estado?: boolean | null
  }

  export type detcotCreateOrConnectWithoutProductoInput = {
    where: detcotWhereUniqueInput
    create: XOR<detcotCreateWithoutProductoInput, detcotUncheckedCreateWithoutProductoInput>
  }

  export type detcotCreateManyProductoInputEnvelope = {
    data: detcotCreateManyProductoInput | detcotCreateManyProductoInput[]
    skipDuplicates?: boolean
  }

  export type detotCreateWithoutProductoInput = {
    cant?: number | null
    punit?: number | null
    stotal?: number | null
    material?: string | null
    gr?: string | null
    tintas?: string | null
    estado?: boolean | null
    ordent?: ordentCreateNestedOneWithoutDetotInput
  }

  export type detotUncheckedCreateWithoutProductoInput = {
    iddetot?: number
    idot?: number | null
    cant?: number | null
    punit?: number | null
    stotal?: number | null
    material?: string | null
    gr?: string | null
    tintas?: string | null
    estado?: boolean | null
  }

  export type detotCreateOrConnectWithoutProductoInput = {
    where: detotWhereUniqueInput
    create: XOR<detotCreateWithoutProductoInput, detotUncheckedCreateWithoutProductoInput>
  }

  export type detotCreateManyProductoInputEnvelope = {
    data: detotCreateManyProductoInput | detotCreateManyProductoInput[]
    skipDuplicates?: boolean
  }

  export type marcaCreateWithoutProductoInput = {
    nom?: string | null
    des?: string | null
    estado?: boolean | null
    color?: colorCreateNestedManyWithoutMarcaInput
    terminado?: terminadoCreateNestedManyWithoutMarcaInput
  }

  export type marcaUncheckedCreateWithoutProductoInput = {
    idmar?: number
    nom?: string | null
    des?: string | null
    estado?: boolean | null
    color?: colorUncheckedCreateNestedManyWithoutMarcaInput
    terminado?: terminadoUncheckedCreateNestedManyWithoutMarcaInput
  }

  export type marcaCreateOrConnectWithoutProductoInput = {
    where: marcaWhereUniqueInput
    create: XOR<marcaCreateWithoutProductoInput, marcaUncheckedCreateWithoutProductoInput>
  }

  export type detcotUpsertWithWhereUniqueWithoutProductoInput = {
    where: detcotWhereUniqueInput
    update: XOR<detcotUpdateWithoutProductoInput, detcotUncheckedUpdateWithoutProductoInput>
    create: XOR<detcotCreateWithoutProductoInput, detcotUncheckedCreateWithoutProductoInput>
  }

  export type detcotUpdateWithWhereUniqueWithoutProductoInput = {
    where: detcotWhereUniqueInput
    data: XOR<detcotUpdateWithoutProductoInput, detcotUncheckedUpdateWithoutProductoInput>
  }

  export type detcotUpdateManyWithWhereWithoutProductoInput = {
    where: detcotScalarWhereInput
    data: XOR<detcotUpdateManyMutationInput, detcotUncheckedUpdateManyWithoutProductoInput>
  }

  export type detotUpsertWithWhereUniqueWithoutProductoInput = {
    where: detotWhereUniqueInput
    update: XOR<detotUpdateWithoutProductoInput, detotUncheckedUpdateWithoutProductoInput>
    create: XOR<detotCreateWithoutProductoInput, detotUncheckedCreateWithoutProductoInput>
  }

  export type detotUpdateWithWhereUniqueWithoutProductoInput = {
    where: detotWhereUniqueInput
    data: XOR<detotUpdateWithoutProductoInput, detotUncheckedUpdateWithoutProductoInput>
  }

  export type detotUpdateManyWithWhereWithoutProductoInput = {
    where: detotScalarWhereInput
    data: XOR<detotUpdateManyMutationInput, detotUncheckedUpdateManyWithoutProductoInput>
  }

  export type marcaUpsertWithoutProductoInput = {
    update: XOR<marcaUpdateWithoutProductoInput, marcaUncheckedUpdateWithoutProductoInput>
    create: XOR<marcaCreateWithoutProductoInput, marcaUncheckedCreateWithoutProductoInput>
    where?: marcaWhereInput
  }

  export type marcaUpdateToOneWithWhereWithoutProductoInput = {
    where?: marcaWhereInput
    data: XOR<marcaUpdateWithoutProductoInput, marcaUncheckedUpdateWithoutProductoInput>
  }

  export type marcaUpdateWithoutProductoInput = {
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    des?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    color?: colorUpdateManyWithoutMarcaNestedInput
    terminado?: terminadoUpdateManyWithoutMarcaNestedInput
  }

  export type marcaUncheckedUpdateWithoutProductoInput = {
    idmar?: IntFieldUpdateOperationsInput | number
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    des?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    color?: colorUncheckedUpdateManyWithoutMarcaNestedInput
    terminado?: terminadoUncheckedUpdateManyWithoutMarcaNestedInput
  }

  export type inventarioCreateWithoutProveedorInput = {
    codigo?: string | null
    nom?: string | null
    precio?: number | null
    gr?: number | null
    tam?: string | null
    des?: string | null
    cant?: number | null
    estado?: boolean | null
  }

  export type inventarioUncheckedCreateWithoutProveedorInput = {
    idin?: number
    codigo?: string | null
    nom?: string | null
    precio?: number | null
    gr?: number | null
    tam?: string | null
    des?: string | null
    cant?: number | null
    estado?: boolean | null
  }

  export type inventarioCreateOrConnectWithoutProveedorInput = {
    where: inventarioWhereUniqueInput
    create: XOR<inventarioCreateWithoutProveedorInput, inventarioUncheckedCreateWithoutProveedorInput>
  }

  export type inventarioCreateManyProveedorInputEnvelope = {
    data: inventarioCreateManyProveedorInput | inventarioCreateManyProveedorInput[]
    skipDuplicates?: boolean
  }

  export type personaCreateWithoutProveedorInput = {
    ci: string
    nombre: string
    ap: string
    am?: string | null
    direccion?: string | null
    email?: string | null
    estado?: boolean | null
    base64?: string | null
    cliente?: clienteCreateNestedManyWithoutPersonaInput
    empresa?: empresaCreateNestedManyWithoutPersonaInput
    telefono?: telefonoCreateNestedManyWithoutPersonaInput
    usuario?: usuarioCreateNestedManyWithoutPersonaInput
  }

  export type personaUncheckedCreateWithoutProveedorInput = {
    idpe?: number
    ci: string
    nombre: string
    ap: string
    am?: string | null
    direccion?: string | null
    email?: string | null
    estado?: boolean | null
    base64?: string | null
    cliente?: clienteUncheckedCreateNestedManyWithoutPersonaInput
    empresa?: empresaUncheckedCreateNestedManyWithoutPersonaInput
    telefono?: telefonoUncheckedCreateNestedManyWithoutPersonaInput
    usuario?: usuarioUncheckedCreateNestedManyWithoutPersonaInput
  }

  export type personaCreateOrConnectWithoutProveedorInput = {
    where: personaWhereUniqueInput
    create: XOR<personaCreateWithoutProveedorInput, personaUncheckedCreateWithoutProveedorInput>
  }

  export type inventarioUpsertWithWhereUniqueWithoutProveedorInput = {
    where: inventarioWhereUniqueInput
    update: XOR<inventarioUpdateWithoutProveedorInput, inventarioUncheckedUpdateWithoutProveedorInput>
    create: XOR<inventarioCreateWithoutProveedorInput, inventarioUncheckedCreateWithoutProveedorInput>
  }

  export type inventarioUpdateWithWhereUniqueWithoutProveedorInput = {
    where: inventarioWhereUniqueInput
    data: XOR<inventarioUpdateWithoutProveedorInput, inventarioUncheckedUpdateWithoutProveedorInput>
  }

  export type inventarioUpdateManyWithWhereWithoutProveedorInput = {
    where: inventarioScalarWhereInput
    data: XOR<inventarioUpdateManyMutationInput, inventarioUncheckedUpdateManyWithoutProveedorInput>
  }

  export type inventarioScalarWhereInput = {
    AND?: inventarioScalarWhereInput | inventarioScalarWhereInput[]
    OR?: inventarioScalarWhereInput[]
    NOT?: inventarioScalarWhereInput | inventarioScalarWhereInput[]
    idin?: IntFilter<"inventario"> | number
    idprov?: IntNullableFilter<"inventario"> | number | null
    codigo?: StringNullableFilter<"inventario"> | string | null
    nom?: StringNullableFilter<"inventario"> | string | null
    precio?: FloatNullableFilter<"inventario"> | number | null
    gr?: FloatNullableFilter<"inventario"> | number | null
    tam?: StringNullableFilter<"inventario"> | string | null
    des?: StringNullableFilter<"inventario"> | string | null
    cant?: IntNullableFilter<"inventario"> | number | null
    estado?: BoolNullableFilter<"inventario"> | boolean | null
  }

  export type personaUpsertWithoutProveedorInput = {
    update: XOR<personaUpdateWithoutProveedorInput, personaUncheckedUpdateWithoutProveedorInput>
    create: XOR<personaCreateWithoutProveedorInput, personaUncheckedCreateWithoutProveedorInput>
    where?: personaWhereInput
  }

  export type personaUpdateToOneWithWhereWithoutProveedorInput = {
    where?: personaWhereInput
    data: XOR<personaUpdateWithoutProveedorInput, personaUncheckedUpdateWithoutProveedorInput>
  }

  export type personaUpdateWithoutProveedorInput = {
    ci?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    ap?: StringFieldUpdateOperationsInput | string
    am?: NullableStringFieldUpdateOperationsInput | string | null
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    base64?: NullableStringFieldUpdateOperationsInput | string | null
    cliente?: clienteUpdateManyWithoutPersonaNestedInput
    empresa?: empresaUpdateManyWithoutPersonaNestedInput
    telefono?: telefonoUpdateManyWithoutPersonaNestedInput
    usuario?: usuarioUpdateManyWithoutPersonaNestedInput
  }

  export type personaUncheckedUpdateWithoutProveedorInput = {
    idpe?: IntFieldUpdateOperationsInput | number
    ci?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    ap?: StringFieldUpdateOperationsInput | string
    am?: NullableStringFieldUpdateOperationsInput | string | null
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    base64?: NullableStringFieldUpdateOperationsInput | string | null
    cliente?: clienteUncheckedUpdateManyWithoutPersonaNestedInput
    empresa?: empresaUncheckedUpdateManyWithoutPersonaNestedInput
    telefono?: telefonoUncheckedUpdateManyWithoutPersonaNestedInput
    usuario?: usuarioUncheckedUpdateManyWithoutPersonaNestedInput
  }

  export type usuarioCreateWithoutRegistrolaboralInput = {
    sexo: string
    foto?: Buffer | null
    fecnac: Date | string
    estado?: boolean | null
    base64?: string | null
    arte_arte_iduTousuario?: arteCreateNestedManyWithoutUsuario_arte_iduTousuarioInput
    arte_arte_iduaTousuario?: arteCreateNestedManyWithoutUsuario_arte_iduaTousuarioInput
    cotizacion?: cotizacionCreateNestedManyWithoutUsuarioInput
    datos?: datosCreateNestedManyWithoutUsuarioInput
    factura?: facturaCreateNestedManyWithoutUsuarioInput
    ordent?: ordentCreateNestedManyWithoutUsuarioInput
    empresa?: empresaCreateNestedOneWithoutUsuarioInput
    persona: personaCreateNestedOneWithoutUsuarioInput
    usurol?: usurolCreateNestedManyWithoutUsuarioInput
  }

  export type usuarioUncheckedCreateWithoutRegistrolaboralInput = {
    idu?: number
    sexo: string
    foto?: Buffer | null
    fecnac: Date | string
    idpe: number
    estado?: boolean | null
    idem?: number | null
    base64?: string | null
    arte_arte_iduTousuario?: arteUncheckedCreateNestedManyWithoutUsuario_arte_iduTousuarioInput
    arte_arte_iduaTousuario?: arteUncheckedCreateNestedManyWithoutUsuario_arte_iduaTousuarioInput
    cotizacion?: cotizacionUncheckedCreateNestedManyWithoutUsuarioInput
    datos?: datosUncheckedCreateNestedManyWithoutUsuarioInput
    factura?: facturaUncheckedCreateNestedManyWithoutUsuarioInput
    ordent?: ordentUncheckedCreateNestedManyWithoutUsuarioInput
    usurol?: usurolUncheckedCreateNestedManyWithoutUsuarioInput
  }

  export type usuarioCreateOrConnectWithoutRegistrolaboralInput = {
    where: usuarioWhereUniqueInput
    create: XOR<usuarioCreateWithoutRegistrolaboralInput, usuarioUncheckedCreateWithoutRegistrolaboralInput>
  }

  export type usuarioUpsertWithoutRegistrolaboralInput = {
    update: XOR<usuarioUpdateWithoutRegistrolaboralInput, usuarioUncheckedUpdateWithoutRegistrolaboralInput>
    create: XOR<usuarioCreateWithoutRegistrolaboralInput, usuarioUncheckedCreateWithoutRegistrolaboralInput>
    where?: usuarioWhereInput
  }

  export type usuarioUpdateToOneWithWhereWithoutRegistrolaboralInput = {
    where?: usuarioWhereInput
    data: XOR<usuarioUpdateWithoutRegistrolaboralInput, usuarioUncheckedUpdateWithoutRegistrolaboralInput>
  }

  export type usuarioUpdateWithoutRegistrolaboralInput = {
    sexo?: StringFieldUpdateOperationsInput | string
    foto?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    fecnac?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    base64?: NullableStringFieldUpdateOperationsInput | string | null
    arte_arte_iduTousuario?: arteUpdateManyWithoutUsuario_arte_iduTousuarioNestedInput
    arte_arte_iduaTousuario?: arteUpdateManyWithoutUsuario_arte_iduaTousuarioNestedInput
    cotizacion?: cotizacionUpdateManyWithoutUsuarioNestedInput
    datos?: datosUpdateManyWithoutUsuarioNestedInput
    factura?: facturaUpdateManyWithoutUsuarioNestedInput
    ordent?: ordentUpdateManyWithoutUsuarioNestedInput
    empresa?: empresaUpdateOneWithoutUsuarioNestedInput
    persona?: personaUpdateOneRequiredWithoutUsuarioNestedInput
    usurol?: usurolUpdateManyWithoutUsuarioNestedInput
  }

  export type usuarioUncheckedUpdateWithoutRegistrolaboralInput = {
    idu?: IntFieldUpdateOperationsInput | number
    sexo?: StringFieldUpdateOperationsInput | string
    foto?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    fecnac?: DateTimeFieldUpdateOperationsInput | Date | string
    idpe?: IntFieldUpdateOperationsInput | number
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    idem?: NullableIntFieldUpdateOperationsInput | number | null
    base64?: NullableStringFieldUpdateOperationsInput | string | null
    arte_arte_iduTousuario?: arteUncheckedUpdateManyWithoutUsuario_arte_iduTousuarioNestedInput
    arte_arte_iduaTousuario?: arteUncheckedUpdateManyWithoutUsuario_arte_iduaTousuarioNestedInput
    cotizacion?: cotizacionUncheckedUpdateManyWithoutUsuarioNestedInput
    datos?: datosUncheckedUpdateManyWithoutUsuarioNestedInput
    factura?: facturaUncheckedUpdateManyWithoutUsuarioNestedInput
    ordent?: ordentUncheckedUpdateManyWithoutUsuarioNestedInput
    usurol?: usurolUncheckedUpdateManyWithoutUsuarioNestedInput
  }

  export type rolmenuCreateWithoutRolesInput = {
    menu: menuCreateNestedOneWithoutRolmenuInput
  }

  export type rolmenuUncheckedCreateWithoutRolesInput = {
    idm: number
  }

  export type rolmenuCreateOrConnectWithoutRolesInput = {
    where: rolmenuWhereUniqueInput
    create: XOR<rolmenuCreateWithoutRolesInput, rolmenuUncheckedCreateWithoutRolesInput>
  }

  export type rolmenuCreateManyRolesInputEnvelope = {
    data: rolmenuCreateManyRolesInput | rolmenuCreateManyRolesInput[]
    skipDuplicates?: boolean
  }

  export type usurolCreateWithoutRolesInput = {
    usuario: usuarioCreateNestedOneWithoutUsurolInput
  }

  export type usurolUncheckedCreateWithoutRolesInput = {
    idu: number
  }

  export type usurolCreateOrConnectWithoutRolesInput = {
    where: usurolWhereUniqueInput
    create: XOR<usurolCreateWithoutRolesInput, usurolUncheckedCreateWithoutRolesInput>
  }

  export type usurolCreateManyRolesInputEnvelope = {
    data: usurolCreateManyRolesInput | usurolCreateManyRolesInput[]
    skipDuplicates?: boolean
  }

  export type rolmenuUpsertWithWhereUniqueWithoutRolesInput = {
    where: rolmenuWhereUniqueInput
    update: XOR<rolmenuUpdateWithoutRolesInput, rolmenuUncheckedUpdateWithoutRolesInput>
    create: XOR<rolmenuCreateWithoutRolesInput, rolmenuUncheckedCreateWithoutRolesInput>
  }

  export type rolmenuUpdateWithWhereUniqueWithoutRolesInput = {
    where: rolmenuWhereUniqueInput
    data: XOR<rolmenuUpdateWithoutRolesInput, rolmenuUncheckedUpdateWithoutRolesInput>
  }

  export type rolmenuUpdateManyWithWhereWithoutRolesInput = {
    where: rolmenuScalarWhereInput
    data: XOR<rolmenuUpdateManyMutationInput, rolmenuUncheckedUpdateManyWithoutRolesInput>
  }

  export type usurolUpsertWithWhereUniqueWithoutRolesInput = {
    where: usurolWhereUniqueInput
    update: XOR<usurolUpdateWithoutRolesInput, usurolUncheckedUpdateWithoutRolesInput>
    create: XOR<usurolCreateWithoutRolesInput, usurolUncheckedCreateWithoutRolesInput>
  }

  export type usurolUpdateWithWhereUniqueWithoutRolesInput = {
    where: usurolWhereUniqueInput
    data: XOR<usurolUpdateWithoutRolesInput, usurolUncheckedUpdateWithoutRolesInput>
  }

  export type usurolUpdateManyWithWhereWithoutRolesInput = {
    where: usurolScalarWhereInput
    data: XOR<usurolUpdateManyMutationInput, usurolUncheckedUpdateManyWithoutRolesInput>
  }

  export type usurolScalarWhereInput = {
    AND?: usurolScalarWhereInput | usurolScalarWhereInput[]
    OR?: usurolScalarWhereInput[]
    NOT?: usurolScalarWhereInput | usurolScalarWhereInput[]
    idr?: IntFilter<"usurol"> | number
    idu?: IntFilter<"usurol"> | number
  }

  export type menuCreateWithoutRolmenuInput = {
    nom: string
    url: string
    estado?: boolean | null
  }

  export type menuUncheckedCreateWithoutRolmenuInput = {
    idm?: number
    nom: string
    url: string
    estado?: boolean | null
  }

  export type menuCreateOrConnectWithoutRolmenuInput = {
    where: menuWhereUniqueInput
    create: XOR<menuCreateWithoutRolmenuInput, menuUncheckedCreateWithoutRolmenuInput>
  }

  export type rolesCreateWithoutRolmenuInput = {
    nombre: string
    descrip: string
    jerarquia: number
    estado?: boolean
    usurol?: usurolCreateNestedManyWithoutRolesInput
  }

  export type rolesUncheckedCreateWithoutRolmenuInput = {
    idr?: number
    nombre: string
    descrip: string
    jerarquia: number
    estado?: boolean
    usurol?: usurolUncheckedCreateNestedManyWithoutRolesInput
  }

  export type rolesCreateOrConnectWithoutRolmenuInput = {
    where: rolesWhereUniqueInput
    create: XOR<rolesCreateWithoutRolmenuInput, rolesUncheckedCreateWithoutRolmenuInput>
  }

  export type menuUpsertWithoutRolmenuInput = {
    update: XOR<menuUpdateWithoutRolmenuInput, menuUncheckedUpdateWithoutRolmenuInput>
    create: XOR<menuCreateWithoutRolmenuInput, menuUncheckedCreateWithoutRolmenuInput>
    where?: menuWhereInput
  }

  export type menuUpdateToOneWithWhereWithoutRolmenuInput = {
    where?: menuWhereInput
    data: XOR<menuUpdateWithoutRolmenuInput, menuUncheckedUpdateWithoutRolmenuInput>
  }

  export type menuUpdateWithoutRolmenuInput = {
    nom?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type menuUncheckedUpdateWithoutRolmenuInput = {
    idm?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type rolesUpsertWithoutRolmenuInput = {
    update: XOR<rolesUpdateWithoutRolmenuInput, rolesUncheckedUpdateWithoutRolmenuInput>
    create: XOR<rolesCreateWithoutRolmenuInput, rolesUncheckedCreateWithoutRolmenuInput>
    where?: rolesWhereInput
  }

  export type rolesUpdateToOneWithWhereWithoutRolmenuInput = {
    where?: rolesWhereInput
    data: XOR<rolesUpdateWithoutRolmenuInput, rolesUncheckedUpdateWithoutRolmenuInput>
  }

  export type rolesUpdateWithoutRolmenuInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    descrip?: StringFieldUpdateOperationsInput | string
    jerarquia?: IntFieldUpdateOperationsInput | number
    estado?: BoolFieldUpdateOperationsInput | boolean
    usurol?: usurolUpdateManyWithoutRolesNestedInput
  }

  export type rolesUncheckedUpdateWithoutRolmenuInput = {
    idr?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    descrip?: StringFieldUpdateOperationsInput | string
    jerarquia?: IntFieldUpdateOperationsInput | number
    estado?: BoolFieldUpdateOperationsInput | boolean
    usurol?: usurolUncheckedUpdateManyWithoutRolesNestedInput
  }

  export type personaCreateWithoutTelefonoInput = {
    ci: string
    nombre: string
    ap: string
    am?: string | null
    direccion?: string | null
    email?: string | null
    estado?: boolean | null
    base64?: string | null
    cliente?: clienteCreateNestedManyWithoutPersonaInput
    empresa?: empresaCreateNestedManyWithoutPersonaInput
    proveedor?: proveedorCreateNestedManyWithoutPersonaInput
    usuario?: usuarioCreateNestedManyWithoutPersonaInput
  }

  export type personaUncheckedCreateWithoutTelefonoInput = {
    idpe?: number
    ci: string
    nombre: string
    ap: string
    am?: string | null
    direccion?: string | null
    email?: string | null
    estado?: boolean | null
    base64?: string | null
    cliente?: clienteUncheckedCreateNestedManyWithoutPersonaInput
    empresa?: empresaUncheckedCreateNestedManyWithoutPersonaInput
    proveedor?: proveedorUncheckedCreateNestedManyWithoutPersonaInput
    usuario?: usuarioUncheckedCreateNestedManyWithoutPersonaInput
  }

  export type personaCreateOrConnectWithoutTelefonoInput = {
    where: personaWhereUniqueInput
    create: XOR<personaCreateWithoutTelefonoInput, personaUncheckedCreateWithoutTelefonoInput>
  }

  export type personaUpsertWithoutTelefonoInput = {
    update: XOR<personaUpdateWithoutTelefonoInput, personaUncheckedUpdateWithoutTelefonoInput>
    create: XOR<personaCreateWithoutTelefonoInput, personaUncheckedCreateWithoutTelefonoInput>
    where?: personaWhereInput
  }

  export type personaUpdateToOneWithWhereWithoutTelefonoInput = {
    where?: personaWhereInput
    data: XOR<personaUpdateWithoutTelefonoInput, personaUncheckedUpdateWithoutTelefonoInput>
  }

  export type personaUpdateWithoutTelefonoInput = {
    ci?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    ap?: StringFieldUpdateOperationsInput | string
    am?: NullableStringFieldUpdateOperationsInput | string | null
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    base64?: NullableStringFieldUpdateOperationsInput | string | null
    cliente?: clienteUpdateManyWithoutPersonaNestedInput
    empresa?: empresaUpdateManyWithoutPersonaNestedInput
    proveedor?: proveedorUpdateManyWithoutPersonaNestedInput
    usuario?: usuarioUpdateManyWithoutPersonaNestedInput
  }

  export type personaUncheckedUpdateWithoutTelefonoInput = {
    idpe?: IntFieldUpdateOperationsInput | number
    ci?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    ap?: StringFieldUpdateOperationsInput | string
    am?: NullableStringFieldUpdateOperationsInput | string | null
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    base64?: NullableStringFieldUpdateOperationsInput | string | null
    cliente?: clienteUncheckedUpdateManyWithoutPersonaNestedInput
    empresa?: empresaUncheckedUpdateManyWithoutPersonaNestedInput
    proveedor?: proveedorUncheckedUpdateManyWithoutPersonaNestedInput
    usuario?: usuarioUncheckedUpdateManyWithoutPersonaNestedInput
  }

  export type marcaCreateWithoutTerminadoInput = {
    nom?: string | null
    des?: string | null
    estado?: boolean | null
    color?: colorCreateNestedManyWithoutMarcaInput
    producto?: productoCreateNestedManyWithoutMarcaInput
  }

  export type marcaUncheckedCreateWithoutTerminadoInput = {
    idmar?: number
    nom?: string | null
    des?: string | null
    estado?: boolean | null
    color?: colorUncheckedCreateNestedManyWithoutMarcaInput
    producto?: productoUncheckedCreateNestedManyWithoutMarcaInput
  }

  export type marcaCreateOrConnectWithoutTerminadoInput = {
    where: marcaWhereUniqueInput
    create: XOR<marcaCreateWithoutTerminadoInput, marcaUncheckedCreateWithoutTerminadoInput>
  }

  export type marcaUpsertWithoutTerminadoInput = {
    update: XOR<marcaUpdateWithoutTerminadoInput, marcaUncheckedUpdateWithoutTerminadoInput>
    create: XOR<marcaCreateWithoutTerminadoInput, marcaUncheckedCreateWithoutTerminadoInput>
    where?: marcaWhereInput
  }

  export type marcaUpdateToOneWithWhereWithoutTerminadoInput = {
    where?: marcaWhereInput
    data: XOR<marcaUpdateWithoutTerminadoInput, marcaUncheckedUpdateWithoutTerminadoInput>
  }

  export type marcaUpdateWithoutTerminadoInput = {
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    des?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    color?: colorUpdateManyWithoutMarcaNestedInput
    producto?: productoUpdateManyWithoutMarcaNestedInput
  }

  export type marcaUncheckedUpdateWithoutTerminadoInput = {
    idmar?: IntFieldUpdateOperationsInput | number
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    des?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    color?: colorUncheckedUpdateManyWithoutMarcaNestedInput
    producto?: productoUncheckedUpdateManyWithoutMarcaNestedInput
  }

  export type arteCreateWithoutUsuario_arte_iduTousuarioInput = {
    fechar?: Date | string | null
    fechaa?: Date | string | null
    estado?: string | null
    obs?: string | null
    precio?: number | null
    ordent?: ordentCreateNestedOneWithoutArte1Input
    usuario_arte_iduaTousuario?: usuarioCreateNestedOneWithoutArte_arte_iduaTousuarioInput
  }

  export type arteUncheckedCreateWithoutUsuario_arte_iduTousuarioInput = {
    idar?: number
    idot?: number | null
    fechar?: Date | string | null
    fechaa?: Date | string | null
    idua?: number | null
    estado?: string | null
    obs?: string | null
    precio?: number | null
  }

  export type arteCreateOrConnectWithoutUsuario_arte_iduTousuarioInput = {
    where: arteWhereUniqueInput
    create: XOR<arteCreateWithoutUsuario_arte_iduTousuarioInput, arteUncheckedCreateWithoutUsuario_arte_iduTousuarioInput>
  }

  export type arteCreateManyUsuario_arte_iduTousuarioInputEnvelope = {
    data: arteCreateManyUsuario_arte_iduTousuarioInput | arteCreateManyUsuario_arte_iduTousuarioInput[]
    skipDuplicates?: boolean
  }

  export type arteCreateWithoutUsuario_arte_iduaTousuarioInput = {
    fechar?: Date | string | null
    fechaa?: Date | string | null
    estado?: string | null
    obs?: string | null
    precio?: number | null
    ordent?: ordentCreateNestedOneWithoutArte1Input
    usuario_arte_iduTousuario?: usuarioCreateNestedOneWithoutArte_arte_iduTousuarioInput
  }

  export type arteUncheckedCreateWithoutUsuario_arte_iduaTousuarioInput = {
    idar?: number
    idu?: number | null
    idot?: number | null
    fechar?: Date | string | null
    fechaa?: Date | string | null
    estado?: string | null
    obs?: string | null
    precio?: number | null
  }

  export type arteCreateOrConnectWithoutUsuario_arte_iduaTousuarioInput = {
    where: arteWhereUniqueInput
    create: XOR<arteCreateWithoutUsuario_arte_iduaTousuarioInput, arteUncheckedCreateWithoutUsuario_arte_iduaTousuarioInput>
  }

  export type arteCreateManyUsuario_arte_iduaTousuarioInputEnvelope = {
    data: arteCreateManyUsuario_arte_iduaTousuarioInput | arteCreateManyUsuario_arte_iduaTousuarioInput[]
    skipDuplicates?: boolean
  }

  export type cotizacionCreateWithoutUsuarioInput = {
    fecha?: Date | string | null
    precio?: number | null
    descuento?: number | null
    preciofinal?: number | null
    tiempo?: number | null
    arte?: string | null
    obs?: string | null
    estado?: string | null
    cliente?: clienteCreateNestedOneWithoutCotizacionInput
    detcot?: detcotCreateNestedManyWithoutCotizacionInput
    ordent?: ordentCreateNestedManyWithoutCotizacionInput
  }

  export type cotizacionUncheckedCreateWithoutUsuarioInput = {
    idcot?: number
    idcli?: number | null
    fecha?: Date | string | null
    precio?: number | null
    descuento?: number | null
    preciofinal?: number | null
    tiempo?: number | null
    arte?: string | null
    obs?: string | null
    estado?: string | null
    detcot?: detcotUncheckedCreateNestedManyWithoutCotizacionInput
    ordent?: ordentUncheckedCreateNestedManyWithoutCotizacionInput
  }

  export type cotizacionCreateOrConnectWithoutUsuarioInput = {
    where: cotizacionWhereUniqueInput
    create: XOR<cotizacionCreateWithoutUsuarioInput, cotizacionUncheckedCreateWithoutUsuarioInput>
  }

  export type cotizacionCreateManyUsuarioInputEnvelope = {
    data: cotizacionCreateManyUsuarioInput | cotizacionCreateManyUsuarioInput[]
    skipDuplicates?: boolean
  }

  export type datosCreateWithoutUsuarioInput = {
    login: string
    contrasenia: string
  }

  export type datosUncheckedCreateWithoutUsuarioInput = {
    login: string
    contrasenia: string
  }

  export type datosCreateOrConnectWithoutUsuarioInput = {
    where: datosWhereUniqueInput
    create: XOR<datosCreateWithoutUsuarioInput, datosUncheckedCreateWithoutUsuarioInput>
  }

  export type datosCreateManyUsuarioInputEnvelope = {
    data: datosCreateManyUsuarioInput | datosCreateManyUsuarioInput[]
    skipDuplicates?: boolean
  }

  export type facturaCreateWithoutUsuarioInput = {
    monto?: number | null
    fecha?: Date | string | null
    aux?: string | null
    aux1?: string | null
    ordent?: ordentCreateNestedOneWithoutFactura1Input
  }

  export type facturaUncheckedCreateWithoutUsuarioInput = {
    idfac?: number
    idot?: number | null
    monto?: number | null
    fecha?: Date | string | null
    aux?: string | null
    aux1?: string | null
  }

  export type facturaCreateOrConnectWithoutUsuarioInput = {
    where: facturaWhereUniqueInput
    create: XOR<facturaCreateWithoutUsuarioInput, facturaUncheckedCreateWithoutUsuarioInput>
  }

  export type facturaCreateManyUsuarioInputEnvelope = {
    data: facturaCreateManyUsuarioInput | facturaCreateManyUsuarioInput[]
    skipDuplicates?: boolean
  }

  export type ordentCreateWithoutUsuarioInput = {
    fecha?: Date | string | null
    precio?: number | null
    descuento?: number | null
    preciofinal?: number | null
    tiempo?: number | null
    arte?: string | null
    obs?: string | null
    estado?: string | null
    factura?: string | null
    arte1?: arteCreateNestedManyWithoutOrdentInput
    detot?: detotCreateNestedManyWithoutOrdentInput
    factura1?: facturaCreateNestedManyWithoutOrdentInput
    cliente?: clienteCreateNestedOneWithoutOrdentInput
    cotizacion?: cotizacionCreateNestedOneWithoutOrdentInput
    pago?: pagoCreateNestedManyWithoutOrdentInput
  }

  export type ordentUncheckedCreateWithoutUsuarioInput = {
    idot?: number
    idcli?: number | null
    idcot?: number | null
    fecha?: Date | string | null
    precio?: number | null
    descuento?: number | null
    preciofinal?: number | null
    tiempo?: number | null
    arte?: string | null
    obs?: string | null
    estado?: string | null
    factura?: string | null
    arte1?: arteUncheckedCreateNestedManyWithoutOrdentInput
    detot?: detotUncheckedCreateNestedManyWithoutOrdentInput
    factura1?: facturaUncheckedCreateNestedManyWithoutOrdentInput
    pago?: pagoUncheckedCreateNestedManyWithoutOrdentInput
  }

  export type ordentCreateOrConnectWithoutUsuarioInput = {
    where: ordentWhereUniqueInput
    create: XOR<ordentCreateWithoutUsuarioInput, ordentUncheckedCreateWithoutUsuarioInput>
  }

  export type ordentCreateManyUsuarioInputEnvelope = {
    data: ordentCreateManyUsuarioInput | ordentCreateManyUsuarioInput[]
    skipDuplicates?: boolean
  }

  export type registrolaboralCreateWithoutUsuarioInput = {
    tiporegistro?: string | null
    fecha?: Date | string | null
    hora?: Date | string | null
    mes?: string | null
    estado?: string | null
    adicional?: string | null
    adicional2?: string | null
    atraso?: Date | string | null
  }

  export type registrolaboralUncheckedCreateWithoutUsuarioInput = {
    idre?: number
    tiporegistro?: string | null
    fecha?: Date | string | null
    hora?: Date | string | null
    mes?: string | null
    estado?: string | null
    adicional?: string | null
    adicional2?: string | null
    atraso?: Date | string | null
  }

  export type registrolaboralCreateOrConnectWithoutUsuarioInput = {
    where: registrolaboralWhereUniqueInput
    create: XOR<registrolaboralCreateWithoutUsuarioInput, registrolaboralUncheckedCreateWithoutUsuarioInput>
  }

  export type registrolaboralCreateManyUsuarioInputEnvelope = {
    data: registrolaboralCreateManyUsuarioInput | registrolaboralCreateManyUsuarioInput[]
    skipDuplicates?: boolean
  }

  export type empresaCreateWithoutUsuarioInput = {
    nom?: string | null
    dir?: string | null
    des?: string | null
    dep?: string | null
    logo?: Buffer | null
    nit?: string | null
    auto?: string | null
    base64?: string | null
    persona?: personaCreateNestedOneWithoutEmpresaInput
    leyenda?: leyendaCreateNestedManyWithoutEmpresaInput
  }

  export type empresaUncheckedCreateWithoutUsuarioInput = {
    idem?: number
    nom?: string | null
    dir?: string | null
    des?: string | null
    dep?: string | null
    logo?: Buffer | null
    idpe?: number | null
    nit?: string | null
    auto?: string | null
    base64?: string | null
    leyenda?: leyendaUncheckedCreateNestedManyWithoutEmpresaInput
  }

  export type empresaCreateOrConnectWithoutUsuarioInput = {
    where: empresaWhereUniqueInput
    create: XOR<empresaCreateWithoutUsuarioInput, empresaUncheckedCreateWithoutUsuarioInput>
  }

  export type personaCreateWithoutUsuarioInput = {
    ci: string
    nombre: string
    ap: string
    am?: string | null
    direccion?: string | null
    email?: string | null
    estado?: boolean | null
    base64?: string | null
    cliente?: clienteCreateNestedManyWithoutPersonaInput
    empresa?: empresaCreateNestedManyWithoutPersonaInput
    proveedor?: proveedorCreateNestedManyWithoutPersonaInput
    telefono?: telefonoCreateNestedManyWithoutPersonaInput
  }

  export type personaUncheckedCreateWithoutUsuarioInput = {
    idpe?: number
    ci: string
    nombre: string
    ap: string
    am?: string | null
    direccion?: string | null
    email?: string | null
    estado?: boolean | null
    base64?: string | null
    cliente?: clienteUncheckedCreateNestedManyWithoutPersonaInput
    empresa?: empresaUncheckedCreateNestedManyWithoutPersonaInput
    proveedor?: proveedorUncheckedCreateNestedManyWithoutPersonaInput
    telefono?: telefonoUncheckedCreateNestedManyWithoutPersonaInput
  }

  export type personaCreateOrConnectWithoutUsuarioInput = {
    where: personaWhereUniqueInput
    create: XOR<personaCreateWithoutUsuarioInput, personaUncheckedCreateWithoutUsuarioInput>
  }

  export type usurolCreateWithoutUsuarioInput = {
    roles: rolesCreateNestedOneWithoutUsurolInput
  }

  export type usurolUncheckedCreateWithoutUsuarioInput = {
    idr: number
  }

  export type usurolCreateOrConnectWithoutUsuarioInput = {
    where: usurolWhereUniqueInput
    create: XOR<usurolCreateWithoutUsuarioInput, usurolUncheckedCreateWithoutUsuarioInput>
  }

  export type usurolCreateManyUsuarioInputEnvelope = {
    data: usurolCreateManyUsuarioInput | usurolCreateManyUsuarioInput[]
    skipDuplicates?: boolean
  }

  export type arteUpsertWithWhereUniqueWithoutUsuario_arte_iduTousuarioInput = {
    where: arteWhereUniqueInput
    update: XOR<arteUpdateWithoutUsuario_arte_iduTousuarioInput, arteUncheckedUpdateWithoutUsuario_arte_iduTousuarioInput>
    create: XOR<arteCreateWithoutUsuario_arte_iduTousuarioInput, arteUncheckedCreateWithoutUsuario_arte_iduTousuarioInput>
  }

  export type arteUpdateWithWhereUniqueWithoutUsuario_arte_iduTousuarioInput = {
    where: arteWhereUniqueInput
    data: XOR<arteUpdateWithoutUsuario_arte_iduTousuarioInput, arteUncheckedUpdateWithoutUsuario_arte_iduTousuarioInput>
  }

  export type arteUpdateManyWithWhereWithoutUsuario_arte_iduTousuarioInput = {
    where: arteScalarWhereInput
    data: XOR<arteUpdateManyMutationInput, arteUncheckedUpdateManyWithoutUsuario_arte_iduTousuarioInput>
  }

  export type arteUpsertWithWhereUniqueWithoutUsuario_arte_iduaTousuarioInput = {
    where: arteWhereUniqueInput
    update: XOR<arteUpdateWithoutUsuario_arte_iduaTousuarioInput, arteUncheckedUpdateWithoutUsuario_arte_iduaTousuarioInput>
    create: XOR<arteCreateWithoutUsuario_arte_iduaTousuarioInput, arteUncheckedCreateWithoutUsuario_arte_iduaTousuarioInput>
  }

  export type arteUpdateWithWhereUniqueWithoutUsuario_arte_iduaTousuarioInput = {
    where: arteWhereUniqueInput
    data: XOR<arteUpdateWithoutUsuario_arte_iduaTousuarioInput, arteUncheckedUpdateWithoutUsuario_arte_iduaTousuarioInput>
  }

  export type arteUpdateManyWithWhereWithoutUsuario_arte_iduaTousuarioInput = {
    where: arteScalarWhereInput
    data: XOR<arteUpdateManyMutationInput, arteUncheckedUpdateManyWithoutUsuario_arte_iduaTousuarioInput>
  }

  export type cotizacionUpsertWithWhereUniqueWithoutUsuarioInput = {
    where: cotizacionWhereUniqueInput
    update: XOR<cotizacionUpdateWithoutUsuarioInput, cotizacionUncheckedUpdateWithoutUsuarioInput>
    create: XOR<cotizacionCreateWithoutUsuarioInput, cotizacionUncheckedCreateWithoutUsuarioInput>
  }

  export type cotizacionUpdateWithWhereUniqueWithoutUsuarioInput = {
    where: cotizacionWhereUniqueInput
    data: XOR<cotizacionUpdateWithoutUsuarioInput, cotizacionUncheckedUpdateWithoutUsuarioInput>
  }

  export type cotizacionUpdateManyWithWhereWithoutUsuarioInput = {
    where: cotizacionScalarWhereInput
    data: XOR<cotizacionUpdateManyMutationInput, cotizacionUncheckedUpdateManyWithoutUsuarioInput>
  }

  export type datosUpsertWithWhereUniqueWithoutUsuarioInput = {
    where: datosWhereUniqueInput
    update: XOR<datosUpdateWithoutUsuarioInput, datosUncheckedUpdateWithoutUsuarioInput>
    create: XOR<datosCreateWithoutUsuarioInput, datosUncheckedCreateWithoutUsuarioInput>
  }

  export type datosUpdateWithWhereUniqueWithoutUsuarioInput = {
    where: datosWhereUniqueInput
    data: XOR<datosUpdateWithoutUsuarioInput, datosUncheckedUpdateWithoutUsuarioInput>
  }

  export type datosUpdateManyWithWhereWithoutUsuarioInput = {
    where: datosScalarWhereInput
    data: XOR<datosUpdateManyMutationInput, datosUncheckedUpdateManyWithoutUsuarioInput>
  }

  export type datosScalarWhereInput = {
    AND?: datosScalarWhereInput | datosScalarWhereInput[]
    OR?: datosScalarWhereInput[]
    NOT?: datosScalarWhereInput | datosScalarWhereInput[]
    idu?: IntFilter<"datos"> | number
    login?: StringFilter<"datos"> | string
    contrasenia?: StringFilter<"datos"> | string
  }

  export type facturaUpsertWithWhereUniqueWithoutUsuarioInput = {
    where: facturaWhereUniqueInput
    update: XOR<facturaUpdateWithoutUsuarioInput, facturaUncheckedUpdateWithoutUsuarioInput>
    create: XOR<facturaCreateWithoutUsuarioInput, facturaUncheckedCreateWithoutUsuarioInput>
  }

  export type facturaUpdateWithWhereUniqueWithoutUsuarioInput = {
    where: facturaWhereUniqueInput
    data: XOR<facturaUpdateWithoutUsuarioInput, facturaUncheckedUpdateWithoutUsuarioInput>
  }

  export type facturaUpdateManyWithWhereWithoutUsuarioInput = {
    where: facturaScalarWhereInput
    data: XOR<facturaUpdateManyMutationInput, facturaUncheckedUpdateManyWithoutUsuarioInput>
  }

  export type ordentUpsertWithWhereUniqueWithoutUsuarioInput = {
    where: ordentWhereUniqueInput
    update: XOR<ordentUpdateWithoutUsuarioInput, ordentUncheckedUpdateWithoutUsuarioInput>
    create: XOR<ordentCreateWithoutUsuarioInput, ordentUncheckedCreateWithoutUsuarioInput>
  }

  export type ordentUpdateWithWhereUniqueWithoutUsuarioInput = {
    where: ordentWhereUniqueInput
    data: XOR<ordentUpdateWithoutUsuarioInput, ordentUncheckedUpdateWithoutUsuarioInput>
  }

  export type ordentUpdateManyWithWhereWithoutUsuarioInput = {
    where: ordentScalarWhereInput
    data: XOR<ordentUpdateManyMutationInput, ordentUncheckedUpdateManyWithoutUsuarioInput>
  }

  export type registrolaboralUpsertWithWhereUniqueWithoutUsuarioInput = {
    where: registrolaboralWhereUniqueInput
    update: XOR<registrolaboralUpdateWithoutUsuarioInput, registrolaboralUncheckedUpdateWithoutUsuarioInput>
    create: XOR<registrolaboralCreateWithoutUsuarioInput, registrolaboralUncheckedCreateWithoutUsuarioInput>
  }

  export type registrolaboralUpdateWithWhereUniqueWithoutUsuarioInput = {
    where: registrolaboralWhereUniqueInput
    data: XOR<registrolaboralUpdateWithoutUsuarioInput, registrolaboralUncheckedUpdateWithoutUsuarioInput>
  }

  export type registrolaboralUpdateManyWithWhereWithoutUsuarioInput = {
    where: registrolaboralScalarWhereInput
    data: XOR<registrolaboralUpdateManyMutationInput, registrolaboralUncheckedUpdateManyWithoutUsuarioInput>
  }

  export type registrolaboralScalarWhereInput = {
    AND?: registrolaboralScalarWhereInput | registrolaboralScalarWhereInput[]
    OR?: registrolaboralScalarWhereInput[]
    NOT?: registrolaboralScalarWhereInput | registrolaboralScalarWhereInput[]
    idre?: IntFilter<"registrolaboral"> | number
    idu?: IntNullableFilter<"registrolaboral"> | number | null
    tiporegistro?: StringNullableFilter<"registrolaboral"> | string | null
    fecha?: DateTimeNullableFilter<"registrolaboral"> | Date | string | null
    hora?: DateTimeNullableFilter<"registrolaboral"> | Date | string | null
    mes?: StringNullableFilter<"registrolaboral"> | string | null
    estado?: StringNullableFilter<"registrolaboral"> | string | null
    adicional?: StringNullableFilter<"registrolaboral"> | string | null
    adicional2?: StringNullableFilter<"registrolaboral"> | string | null
    atraso?: DateTimeNullableFilter<"registrolaboral"> | Date | string | null
  }

  export type empresaUpsertWithoutUsuarioInput = {
    update: XOR<empresaUpdateWithoutUsuarioInput, empresaUncheckedUpdateWithoutUsuarioInput>
    create: XOR<empresaCreateWithoutUsuarioInput, empresaUncheckedCreateWithoutUsuarioInput>
    where?: empresaWhereInput
  }

  export type empresaUpdateToOneWithWhereWithoutUsuarioInput = {
    where?: empresaWhereInput
    data: XOR<empresaUpdateWithoutUsuarioInput, empresaUncheckedUpdateWithoutUsuarioInput>
  }

  export type empresaUpdateWithoutUsuarioInput = {
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    dir?: NullableStringFieldUpdateOperationsInput | string | null
    des?: NullableStringFieldUpdateOperationsInput | string | null
    dep?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    nit?: NullableStringFieldUpdateOperationsInput | string | null
    auto?: NullableStringFieldUpdateOperationsInput | string | null
    base64?: NullableStringFieldUpdateOperationsInput | string | null
    persona?: personaUpdateOneWithoutEmpresaNestedInput
    leyenda?: leyendaUpdateManyWithoutEmpresaNestedInput
  }

  export type empresaUncheckedUpdateWithoutUsuarioInput = {
    idem?: IntFieldUpdateOperationsInput | number
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    dir?: NullableStringFieldUpdateOperationsInput | string | null
    des?: NullableStringFieldUpdateOperationsInput | string | null
    dep?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    idpe?: NullableIntFieldUpdateOperationsInput | number | null
    nit?: NullableStringFieldUpdateOperationsInput | string | null
    auto?: NullableStringFieldUpdateOperationsInput | string | null
    base64?: NullableStringFieldUpdateOperationsInput | string | null
    leyenda?: leyendaUncheckedUpdateManyWithoutEmpresaNestedInput
  }

  export type personaUpsertWithoutUsuarioInput = {
    update: XOR<personaUpdateWithoutUsuarioInput, personaUncheckedUpdateWithoutUsuarioInput>
    create: XOR<personaCreateWithoutUsuarioInput, personaUncheckedCreateWithoutUsuarioInput>
    where?: personaWhereInput
  }

  export type personaUpdateToOneWithWhereWithoutUsuarioInput = {
    where?: personaWhereInput
    data: XOR<personaUpdateWithoutUsuarioInput, personaUncheckedUpdateWithoutUsuarioInput>
  }

  export type personaUpdateWithoutUsuarioInput = {
    ci?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    ap?: StringFieldUpdateOperationsInput | string
    am?: NullableStringFieldUpdateOperationsInput | string | null
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    base64?: NullableStringFieldUpdateOperationsInput | string | null
    cliente?: clienteUpdateManyWithoutPersonaNestedInput
    empresa?: empresaUpdateManyWithoutPersonaNestedInput
    proveedor?: proveedorUpdateManyWithoutPersonaNestedInput
    telefono?: telefonoUpdateManyWithoutPersonaNestedInput
  }

  export type personaUncheckedUpdateWithoutUsuarioInput = {
    idpe?: IntFieldUpdateOperationsInput | number
    ci?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    ap?: StringFieldUpdateOperationsInput | string
    am?: NullableStringFieldUpdateOperationsInput | string | null
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    base64?: NullableStringFieldUpdateOperationsInput | string | null
    cliente?: clienteUncheckedUpdateManyWithoutPersonaNestedInput
    empresa?: empresaUncheckedUpdateManyWithoutPersonaNestedInput
    proveedor?: proveedorUncheckedUpdateManyWithoutPersonaNestedInput
    telefono?: telefonoUncheckedUpdateManyWithoutPersonaNestedInput
  }

  export type usurolUpsertWithWhereUniqueWithoutUsuarioInput = {
    where: usurolWhereUniqueInput
    update: XOR<usurolUpdateWithoutUsuarioInput, usurolUncheckedUpdateWithoutUsuarioInput>
    create: XOR<usurolCreateWithoutUsuarioInput, usurolUncheckedCreateWithoutUsuarioInput>
  }

  export type usurolUpdateWithWhereUniqueWithoutUsuarioInput = {
    where: usurolWhereUniqueInput
    data: XOR<usurolUpdateWithoutUsuarioInput, usurolUncheckedUpdateWithoutUsuarioInput>
  }

  export type usurolUpdateManyWithWhereWithoutUsuarioInput = {
    where: usurolScalarWhereInput
    data: XOR<usurolUpdateManyMutationInput, usurolUncheckedUpdateManyWithoutUsuarioInput>
  }

  export type rolesCreateWithoutUsurolInput = {
    nombre: string
    descrip: string
    jerarquia: number
    estado?: boolean
    rolmenu?: rolmenuCreateNestedManyWithoutRolesInput
  }

  export type rolesUncheckedCreateWithoutUsurolInput = {
    idr?: number
    nombre: string
    descrip: string
    jerarquia: number
    estado?: boolean
    rolmenu?: rolmenuUncheckedCreateNestedManyWithoutRolesInput
  }

  export type rolesCreateOrConnectWithoutUsurolInput = {
    where: rolesWhereUniqueInput
    create: XOR<rolesCreateWithoutUsurolInput, rolesUncheckedCreateWithoutUsurolInput>
  }

  export type usuarioCreateWithoutUsurolInput = {
    sexo: string
    foto?: Buffer | null
    fecnac: Date | string
    estado?: boolean | null
    base64?: string | null
    arte_arte_iduTousuario?: arteCreateNestedManyWithoutUsuario_arte_iduTousuarioInput
    arte_arte_iduaTousuario?: arteCreateNestedManyWithoutUsuario_arte_iduaTousuarioInput
    cotizacion?: cotizacionCreateNestedManyWithoutUsuarioInput
    datos?: datosCreateNestedManyWithoutUsuarioInput
    factura?: facturaCreateNestedManyWithoutUsuarioInput
    ordent?: ordentCreateNestedManyWithoutUsuarioInput
    registrolaboral?: registrolaboralCreateNestedManyWithoutUsuarioInput
    empresa?: empresaCreateNestedOneWithoutUsuarioInput
    persona: personaCreateNestedOneWithoutUsuarioInput
  }

  export type usuarioUncheckedCreateWithoutUsurolInput = {
    idu?: number
    sexo: string
    foto?: Buffer | null
    fecnac: Date | string
    idpe: number
    estado?: boolean | null
    idem?: number | null
    base64?: string | null
    arte_arte_iduTousuario?: arteUncheckedCreateNestedManyWithoutUsuario_arte_iduTousuarioInput
    arte_arte_iduaTousuario?: arteUncheckedCreateNestedManyWithoutUsuario_arte_iduaTousuarioInput
    cotizacion?: cotizacionUncheckedCreateNestedManyWithoutUsuarioInput
    datos?: datosUncheckedCreateNestedManyWithoutUsuarioInput
    factura?: facturaUncheckedCreateNestedManyWithoutUsuarioInput
    ordent?: ordentUncheckedCreateNestedManyWithoutUsuarioInput
    registrolaboral?: registrolaboralUncheckedCreateNestedManyWithoutUsuarioInput
  }

  export type usuarioCreateOrConnectWithoutUsurolInput = {
    where: usuarioWhereUniqueInput
    create: XOR<usuarioCreateWithoutUsurolInput, usuarioUncheckedCreateWithoutUsurolInput>
  }

  export type rolesUpsertWithoutUsurolInput = {
    update: XOR<rolesUpdateWithoutUsurolInput, rolesUncheckedUpdateWithoutUsurolInput>
    create: XOR<rolesCreateWithoutUsurolInput, rolesUncheckedCreateWithoutUsurolInput>
    where?: rolesWhereInput
  }

  export type rolesUpdateToOneWithWhereWithoutUsurolInput = {
    where?: rolesWhereInput
    data: XOR<rolesUpdateWithoutUsurolInput, rolesUncheckedUpdateWithoutUsurolInput>
  }

  export type rolesUpdateWithoutUsurolInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    descrip?: StringFieldUpdateOperationsInput | string
    jerarquia?: IntFieldUpdateOperationsInput | number
    estado?: BoolFieldUpdateOperationsInput | boolean
    rolmenu?: rolmenuUpdateManyWithoutRolesNestedInput
  }

  export type rolesUncheckedUpdateWithoutUsurolInput = {
    idr?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    descrip?: StringFieldUpdateOperationsInput | string
    jerarquia?: IntFieldUpdateOperationsInput | number
    estado?: BoolFieldUpdateOperationsInput | boolean
    rolmenu?: rolmenuUncheckedUpdateManyWithoutRolesNestedInput
  }

  export type usuarioUpsertWithoutUsurolInput = {
    update: XOR<usuarioUpdateWithoutUsurolInput, usuarioUncheckedUpdateWithoutUsurolInput>
    create: XOR<usuarioCreateWithoutUsurolInput, usuarioUncheckedCreateWithoutUsurolInput>
    where?: usuarioWhereInput
  }

  export type usuarioUpdateToOneWithWhereWithoutUsurolInput = {
    where?: usuarioWhereInput
    data: XOR<usuarioUpdateWithoutUsurolInput, usuarioUncheckedUpdateWithoutUsurolInput>
  }

  export type usuarioUpdateWithoutUsurolInput = {
    sexo?: StringFieldUpdateOperationsInput | string
    foto?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    fecnac?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    base64?: NullableStringFieldUpdateOperationsInput | string | null
    arte_arte_iduTousuario?: arteUpdateManyWithoutUsuario_arte_iduTousuarioNestedInput
    arte_arte_iduaTousuario?: arteUpdateManyWithoutUsuario_arte_iduaTousuarioNestedInput
    cotizacion?: cotizacionUpdateManyWithoutUsuarioNestedInput
    datos?: datosUpdateManyWithoutUsuarioNestedInput
    factura?: facturaUpdateManyWithoutUsuarioNestedInput
    ordent?: ordentUpdateManyWithoutUsuarioNestedInput
    registrolaboral?: registrolaboralUpdateManyWithoutUsuarioNestedInput
    empresa?: empresaUpdateOneWithoutUsuarioNestedInput
    persona?: personaUpdateOneRequiredWithoutUsuarioNestedInput
  }

  export type usuarioUncheckedUpdateWithoutUsurolInput = {
    idu?: IntFieldUpdateOperationsInput | number
    sexo?: StringFieldUpdateOperationsInput | string
    foto?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    fecnac?: DateTimeFieldUpdateOperationsInput | Date | string
    idpe?: IntFieldUpdateOperationsInput | number
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    idem?: NullableIntFieldUpdateOperationsInput | number | null
    base64?: NullableStringFieldUpdateOperationsInput | string | null
    arte_arte_iduTousuario?: arteUncheckedUpdateManyWithoutUsuario_arte_iduTousuarioNestedInput
    arte_arte_iduaTousuario?: arteUncheckedUpdateManyWithoutUsuario_arte_iduaTousuarioNestedInput
    cotizacion?: cotizacionUncheckedUpdateManyWithoutUsuarioNestedInput
    datos?: datosUncheckedUpdateManyWithoutUsuarioNestedInput
    factura?: facturaUncheckedUpdateManyWithoutUsuarioNestedInput
    ordent?: ordentUncheckedUpdateManyWithoutUsuarioNestedInput
    registrolaboral?: registrolaboralUncheckedUpdateManyWithoutUsuarioNestedInput
  }

  export type cotizacionCreateManyClienteInput = {
    idcot?: number
    idu?: number | null
    fecha?: Date | string | null
    precio?: number | null
    descuento?: number | null
    preciofinal?: number | null
    tiempo?: number | null
    arte?: string | null
    obs?: string | null
    estado?: string | null
  }

  export type ordentCreateManyClienteInput = {
    idot?: number
    idu?: number | null
    idcot?: number | null
    fecha?: Date | string | null
    precio?: number | null
    descuento?: number | null
    preciofinal?: number | null
    tiempo?: number | null
    arte?: string | null
    obs?: string | null
    estado?: string | null
    factura?: string | null
  }

  export type cotizacionUpdateWithoutClienteInput = {
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    precio?: NullableFloatFieldUpdateOperationsInput | number | null
    descuento?: NullableFloatFieldUpdateOperationsInput | number | null
    preciofinal?: NullableFloatFieldUpdateOperationsInput | number | null
    tiempo?: NullableIntFieldUpdateOperationsInput | number | null
    arte?: NullableStringFieldUpdateOperationsInput | string | null
    obs?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableStringFieldUpdateOperationsInput | string | null
    usuario?: usuarioUpdateOneWithoutCotizacionNestedInput
    detcot?: detcotUpdateManyWithoutCotizacionNestedInput
    ordent?: ordentUpdateManyWithoutCotizacionNestedInput
  }

  export type cotizacionUncheckedUpdateWithoutClienteInput = {
    idcot?: IntFieldUpdateOperationsInput | number
    idu?: NullableIntFieldUpdateOperationsInput | number | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    precio?: NullableFloatFieldUpdateOperationsInput | number | null
    descuento?: NullableFloatFieldUpdateOperationsInput | number | null
    preciofinal?: NullableFloatFieldUpdateOperationsInput | number | null
    tiempo?: NullableIntFieldUpdateOperationsInput | number | null
    arte?: NullableStringFieldUpdateOperationsInput | string | null
    obs?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableStringFieldUpdateOperationsInput | string | null
    detcot?: detcotUncheckedUpdateManyWithoutCotizacionNestedInput
    ordent?: ordentUncheckedUpdateManyWithoutCotizacionNestedInput
  }

  export type cotizacionUncheckedUpdateManyWithoutClienteInput = {
    idcot?: IntFieldUpdateOperationsInput | number
    idu?: NullableIntFieldUpdateOperationsInput | number | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    precio?: NullableFloatFieldUpdateOperationsInput | number | null
    descuento?: NullableFloatFieldUpdateOperationsInput | number | null
    preciofinal?: NullableFloatFieldUpdateOperationsInput | number | null
    tiempo?: NullableIntFieldUpdateOperationsInput | number | null
    arte?: NullableStringFieldUpdateOperationsInput | string | null
    obs?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ordentUpdateWithoutClienteInput = {
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    precio?: NullableFloatFieldUpdateOperationsInput | number | null
    descuento?: NullableFloatFieldUpdateOperationsInput | number | null
    preciofinal?: NullableFloatFieldUpdateOperationsInput | number | null
    tiempo?: NullableIntFieldUpdateOperationsInput | number | null
    arte?: NullableStringFieldUpdateOperationsInput | string | null
    obs?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableStringFieldUpdateOperationsInput | string | null
    factura?: NullableStringFieldUpdateOperationsInput | string | null
    arte1?: arteUpdateManyWithoutOrdentNestedInput
    detot?: detotUpdateManyWithoutOrdentNestedInput
    factura1?: facturaUpdateManyWithoutOrdentNestedInput
    cotizacion?: cotizacionUpdateOneWithoutOrdentNestedInput
    usuario?: usuarioUpdateOneWithoutOrdentNestedInput
    pago?: pagoUpdateManyWithoutOrdentNestedInput
  }

  export type ordentUncheckedUpdateWithoutClienteInput = {
    idot?: IntFieldUpdateOperationsInput | number
    idu?: NullableIntFieldUpdateOperationsInput | number | null
    idcot?: NullableIntFieldUpdateOperationsInput | number | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    precio?: NullableFloatFieldUpdateOperationsInput | number | null
    descuento?: NullableFloatFieldUpdateOperationsInput | number | null
    preciofinal?: NullableFloatFieldUpdateOperationsInput | number | null
    tiempo?: NullableIntFieldUpdateOperationsInput | number | null
    arte?: NullableStringFieldUpdateOperationsInput | string | null
    obs?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableStringFieldUpdateOperationsInput | string | null
    factura?: NullableStringFieldUpdateOperationsInput | string | null
    arte1?: arteUncheckedUpdateManyWithoutOrdentNestedInput
    detot?: detotUncheckedUpdateManyWithoutOrdentNestedInput
    factura1?: facturaUncheckedUpdateManyWithoutOrdentNestedInput
    pago?: pagoUncheckedUpdateManyWithoutOrdentNestedInput
  }

  export type ordentUncheckedUpdateManyWithoutClienteInput = {
    idot?: IntFieldUpdateOperationsInput | number
    idu?: NullableIntFieldUpdateOperationsInput | number | null
    idcot?: NullableIntFieldUpdateOperationsInput | number | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    precio?: NullableFloatFieldUpdateOperationsInput | number | null
    descuento?: NullableFloatFieldUpdateOperationsInput | number | null
    preciofinal?: NullableFloatFieldUpdateOperationsInput | number | null
    tiempo?: NullableIntFieldUpdateOperationsInput | number | null
    arte?: NullableStringFieldUpdateOperationsInput | string | null
    obs?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableStringFieldUpdateOperationsInput | string | null
    factura?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type detcotCreateManyCotizacionInput = {
    iddetcot?: number
    idpro?: number | null
    cant?: number | null
    punit?: number | null
    stotal?: number | null
    material?: string | null
    gr?: string | null
    tintas?: string | null
    estado?: boolean | null
  }

  export type ordentCreateManyCotizacionInput = {
    idot?: number
    idu?: number | null
    idcli?: number | null
    fecha?: Date | string | null
    precio?: number | null
    descuento?: number | null
    preciofinal?: number | null
    tiempo?: number | null
    arte?: string | null
    obs?: string | null
    estado?: string | null
    factura?: string | null
  }

  export type detcotUpdateWithoutCotizacionInput = {
    cant?: NullableIntFieldUpdateOperationsInput | number | null
    punit?: NullableFloatFieldUpdateOperationsInput | number | null
    stotal?: NullableFloatFieldUpdateOperationsInput | number | null
    material?: NullableStringFieldUpdateOperationsInput | string | null
    gr?: NullableStringFieldUpdateOperationsInput | string | null
    tintas?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    producto?: productoUpdateOneWithoutDetcotNestedInput
  }

  export type detcotUncheckedUpdateWithoutCotizacionInput = {
    iddetcot?: IntFieldUpdateOperationsInput | number
    idpro?: NullableIntFieldUpdateOperationsInput | number | null
    cant?: NullableIntFieldUpdateOperationsInput | number | null
    punit?: NullableFloatFieldUpdateOperationsInput | number | null
    stotal?: NullableFloatFieldUpdateOperationsInput | number | null
    material?: NullableStringFieldUpdateOperationsInput | string | null
    gr?: NullableStringFieldUpdateOperationsInput | string | null
    tintas?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type detcotUncheckedUpdateManyWithoutCotizacionInput = {
    iddetcot?: IntFieldUpdateOperationsInput | number
    idpro?: NullableIntFieldUpdateOperationsInput | number | null
    cant?: NullableIntFieldUpdateOperationsInput | number | null
    punit?: NullableFloatFieldUpdateOperationsInput | number | null
    stotal?: NullableFloatFieldUpdateOperationsInput | number | null
    material?: NullableStringFieldUpdateOperationsInput | string | null
    gr?: NullableStringFieldUpdateOperationsInput | string | null
    tintas?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type ordentUpdateWithoutCotizacionInput = {
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    precio?: NullableFloatFieldUpdateOperationsInput | number | null
    descuento?: NullableFloatFieldUpdateOperationsInput | number | null
    preciofinal?: NullableFloatFieldUpdateOperationsInput | number | null
    tiempo?: NullableIntFieldUpdateOperationsInput | number | null
    arte?: NullableStringFieldUpdateOperationsInput | string | null
    obs?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableStringFieldUpdateOperationsInput | string | null
    factura?: NullableStringFieldUpdateOperationsInput | string | null
    arte1?: arteUpdateManyWithoutOrdentNestedInput
    detot?: detotUpdateManyWithoutOrdentNestedInput
    factura1?: facturaUpdateManyWithoutOrdentNestedInput
    cliente?: clienteUpdateOneWithoutOrdentNestedInput
    usuario?: usuarioUpdateOneWithoutOrdentNestedInput
    pago?: pagoUpdateManyWithoutOrdentNestedInput
  }

  export type ordentUncheckedUpdateWithoutCotizacionInput = {
    idot?: IntFieldUpdateOperationsInput | number
    idu?: NullableIntFieldUpdateOperationsInput | number | null
    idcli?: NullableIntFieldUpdateOperationsInput | number | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    precio?: NullableFloatFieldUpdateOperationsInput | number | null
    descuento?: NullableFloatFieldUpdateOperationsInput | number | null
    preciofinal?: NullableFloatFieldUpdateOperationsInput | number | null
    tiempo?: NullableIntFieldUpdateOperationsInput | number | null
    arte?: NullableStringFieldUpdateOperationsInput | string | null
    obs?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableStringFieldUpdateOperationsInput | string | null
    factura?: NullableStringFieldUpdateOperationsInput | string | null
    arte1?: arteUncheckedUpdateManyWithoutOrdentNestedInput
    detot?: detotUncheckedUpdateManyWithoutOrdentNestedInput
    factura1?: facturaUncheckedUpdateManyWithoutOrdentNestedInput
    pago?: pagoUncheckedUpdateManyWithoutOrdentNestedInput
  }

  export type ordentUncheckedUpdateManyWithoutCotizacionInput = {
    idot?: IntFieldUpdateOperationsInput | number
    idu?: NullableIntFieldUpdateOperationsInput | number | null
    idcli?: NullableIntFieldUpdateOperationsInput | number | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    precio?: NullableFloatFieldUpdateOperationsInput | number | null
    descuento?: NullableFloatFieldUpdateOperationsInput | number | null
    preciofinal?: NullableFloatFieldUpdateOperationsInput | number | null
    tiempo?: NullableIntFieldUpdateOperationsInput | number | null
    arte?: NullableStringFieldUpdateOperationsInput | string | null
    obs?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableStringFieldUpdateOperationsInput | string | null
    factura?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type leyendaCreateManyEmpresaInput = {
    idle?: number
    des?: string | null
    orden?: number | null
  }

  export type usuarioCreateManyEmpresaInput = {
    idu?: number
    sexo: string
    foto?: Buffer | null
    fecnac: Date | string
    idpe: number
    estado?: boolean | null
    base64?: string | null
  }

  export type leyendaUpdateWithoutEmpresaInput = {
    des?: NullableStringFieldUpdateOperationsInput | string | null
    orden?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type leyendaUncheckedUpdateWithoutEmpresaInput = {
    idle?: IntFieldUpdateOperationsInput | number
    des?: NullableStringFieldUpdateOperationsInput | string | null
    orden?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type leyendaUncheckedUpdateManyWithoutEmpresaInput = {
    idle?: IntFieldUpdateOperationsInput | number
    des?: NullableStringFieldUpdateOperationsInput | string | null
    orden?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type usuarioUpdateWithoutEmpresaInput = {
    sexo?: StringFieldUpdateOperationsInput | string
    foto?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    fecnac?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    base64?: NullableStringFieldUpdateOperationsInput | string | null
    arte_arte_iduTousuario?: arteUpdateManyWithoutUsuario_arte_iduTousuarioNestedInput
    arte_arte_iduaTousuario?: arteUpdateManyWithoutUsuario_arte_iduaTousuarioNestedInput
    cotizacion?: cotizacionUpdateManyWithoutUsuarioNestedInput
    datos?: datosUpdateManyWithoutUsuarioNestedInput
    factura?: facturaUpdateManyWithoutUsuarioNestedInput
    ordent?: ordentUpdateManyWithoutUsuarioNestedInput
    registrolaboral?: registrolaboralUpdateManyWithoutUsuarioNestedInput
    persona?: personaUpdateOneRequiredWithoutUsuarioNestedInput
    usurol?: usurolUpdateManyWithoutUsuarioNestedInput
  }

  export type usuarioUncheckedUpdateWithoutEmpresaInput = {
    idu?: IntFieldUpdateOperationsInput | number
    sexo?: StringFieldUpdateOperationsInput | string
    foto?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    fecnac?: DateTimeFieldUpdateOperationsInput | Date | string
    idpe?: IntFieldUpdateOperationsInput | number
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    base64?: NullableStringFieldUpdateOperationsInput | string | null
    arte_arte_iduTousuario?: arteUncheckedUpdateManyWithoutUsuario_arte_iduTousuarioNestedInput
    arte_arte_iduaTousuario?: arteUncheckedUpdateManyWithoutUsuario_arte_iduaTousuarioNestedInput
    cotizacion?: cotizacionUncheckedUpdateManyWithoutUsuarioNestedInput
    datos?: datosUncheckedUpdateManyWithoutUsuarioNestedInput
    factura?: facturaUncheckedUpdateManyWithoutUsuarioNestedInput
    ordent?: ordentUncheckedUpdateManyWithoutUsuarioNestedInput
    registrolaboral?: registrolaboralUncheckedUpdateManyWithoutUsuarioNestedInput
    usurol?: usurolUncheckedUpdateManyWithoutUsuarioNestedInput
  }

  export type usuarioUncheckedUpdateManyWithoutEmpresaInput = {
    idu?: IntFieldUpdateOperationsInput | number
    sexo?: StringFieldUpdateOperationsInput | string
    foto?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    fecnac?: DateTimeFieldUpdateOperationsInput | Date | string
    idpe?: IntFieldUpdateOperationsInput | number
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    base64?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type colorCreateManyMarcaInput = {
    idcolor?: number
    nom?: string | null
    punit?: number | null
    estado?: boolean | null
    des?: string | null
  }

  export type productoCreateManyMarcaInput = {
    idpro?: number
    nom?: string | null
    tam?: string | null
    des?: string | null
    preciov?: number | null
    precioc?: number | null
    cantidad?: number | null
    foto?: Buffer | null
    estado?: boolean | null
    base64?: string | null
    ranking?: number | null
  }

  export type terminadoCreateManyMarcaInput = {
    idter?: number
    nom?: string | null
    punit?: number | null
    estado?: boolean | null
  }

  export type colorUpdateWithoutMarcaInput = {
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    punit?: NullableFloatFieldUpdateOperationsInput | number | null
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    des?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type colorUncheckedUpdateWithoutMarcaInput = {
    idcolor?: IntFieldUpdateOperationsInput | number
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    punit?: NullableFloatFieldUpdateOperationsInput | number | null
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    des?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type colorUncheckedUpdateManyWithoutMarcaInput = {
    idcolor?: IntFieldUpdateOperationsInput | number
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    punit?: NullableFloatFieldUpdateOperationsInput | number | null
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    des?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type productoUpdateWithoutMarcaInput = {
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    tam?: NullableStringFieldUpdateOperationsInput | string | null
    des?: NullableStringFieldUpdateOperationsInput | string | null
    preciov?: NullableFloatFieldUpdateOperationsInput | number | null
    precioc?: NullableFloatFieldUpdateOperationsInput | number | null
    cantidad?: NullableIntFieldUpdateOperationsInput | number | null
    foto?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    base64?: NullableStringFieldUpdateOperationsInput | string | null
    ranking?: NullableIntFieldUpdateOperationsInput | number | null
    detcot?: detcotUpdateManyWithoutProductoNestedInput
    detot?: detotUpdateManyWithoutProductoNestedInput
  }

  export type productoUncheckedUpdateWithoutMarcaInput = {
    idpro?: IntFieldUpdateOperationsInput | number
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    tam?: NullableStringFieldUpdateOperationsInput | string | null
    des?: NullableStringFieldUpdateOperationsInput | string | null
    preciov?: NullableFloatFieldUpdateOperationsInput | number | null
    precioc?: NullableFloatFieldUpdateOperationsInput | number | null
    cantidad?: NullableIntFieldUpdateOperationsInput | number | null
    foto?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    base64?: NullableStringFieldUpdateOperationsInput | string | null
    ranking?: NullableIntFieldUpdateOperationsInput | number | null
    detcot?: detcotUncheckedUpdateManyWithoutProductoNestedInput
    detot?: detotUncheckedUpdateManyWithoutProductoNestedInput
  }

  export type productoUncheckedUpdateManyWithoutMarcaInput = {
    idpro?: IntFieldUpdateOperationsInput | number
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    tam?: NullableStringFieldUpdateOperationsInput | string | null
    des?: NullableStringFieldUpdateOperationsInput | string | null
    preciov?: NullableFloatFieldUpdateOperationsInput | number | null
    precioc?: NullableFloatFieldUpdateOperationsInput | number | null
    cantidad?: NullableIntFieldUpdateOperationsInput | number | null
    foto?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    base64?: NullableStringFieldUpdateOperationsInput | string | null
    ranking?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type terminadoUpdateWithoutMarcaInput = {
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    punit?: NullableFloatFieldUpdateOperationsInput | number | null
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type terminadoUncheckedUpdateWithoutMarcaInput = {
    idter?: IntFieldUpdateOperationsInput | number
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    punit?: NullableFloatFieldUpdateOperationsInput | number | null
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type terminadoUncheckedUpdateManyWithoutMarcaInput = {
    idter?: IntFieldUpdateOperationsInput | number
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    punit?: NullableFloatFieldUpdateOperationsInput | number | null
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type rolmenuCreateManyMenuInput = {
    idr: number
  }

  export type rolmenuUpdateWithoutMenuInput = {
    roles?: rolesUpdateOneRequiredWithoutRolmenuNestedInput
  }

  export type rolmenuUncheckedUpdateWithoutMenuInput = {
    idr?: IntFieldUpdateOperationsInput | number
  }

  export type rolmenuUncheckedUpdateManyWithoutMenuInput = {
    idr?: IntFieldUpdateOperationsInput | number
  }

  export type arteCreateManyOrdentInput = {
    idar?: number
    idu?: number | null
    fechar?: Date | string | null
    fechaa?: Date | string | null
    idua?: number | null
    estado?: string | null
    obs?: string | null
    precio?: number | null
  }

  export type detotCreateManyOrdentInput = {
    iddetot?: number
    idpro?: number | null
    cant?: number | null
    punit?: number | null
    stotal?: number | null
    material?: string | null
    gr?: string | null
    tintas?: string | null
    estado?: boolean | null
  }

  export type facturaCreateManyOrdentInput = {
    idfac?: number
    idu?: number | null
    monto?: number | null
    fecha?: Date | string | null
    aux?: string | null
    aux1?: string | null
  }

  export type pagoCreateManyOrdentInput = {
    idpagp?: number
    fecha?: Date | string | null
    preciof?: number | null
    pago?: number | null
    saldo?: number | null
    des?: string | null
    comprobante?: Buffer | null
  }

  export type arteUpdateWithoutOrdentInput = {
    fechar?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fechaa?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estado?: NullableStringFieldUpdateOperationsInput | string | null
    obs?: NullableStringFieldUpdateOperationsInput | string | null
    precio?: NullableFloatFieldUpdateOperationsInput | number | null
    usuario_arte_iduTousuario?: usuarioUpdateOneWithoutArte_arte_iduTousuarioNestedInput
    usuario_arte_iduaTousuario?: usuarioUpdateOneWithoutArte_arte_iduaTousuarioNestedInput
  }

  export type arteUncheckedUpdateWithoutOrdentInput = {
    idar?: IntFieldUpdateOperationsInput | number
    idu?: NullableIntFieldUpdateOperationsInput | number | null
    fechar?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fechaa?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    idua?: NullableIntFieldUpdateOperationsInput | number | null
    estado?: NullableStringFieldUpdateOperationsInput | string | null
    obs?: NullableStringFieldUpdateOperationsInput | string | null
    precio?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type arteUncheckedUpdateManyWithoutOrdentInput = {
    idar?: IntFieldUpdateOperationsInput | number
    idu?: NullableIntFieldUpdateOperationsInput | number | null
    fechar?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fechaa?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    idua?: NullableIntFieldUpdateOperationsInput | number | null
    estado?: NullableStringFieldUpdateOperationsInput | string | null
    obs?: NullableStringFieldUpdateOperationsInput | string | null
    precio?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type detotUpdateWithoutOrdentInput = {
    cant?: NullableIntFieldUpdateOperationsInput | number | null
    punit?: NullableFloatFieldUpdateOperationsInput | number | null
    stotal?: NullableFloatFieldUpdateOperationsInput | number | null
    material?: NullableStringFieldUpdateOperationsInput | string | null
    gr?: NullableStringFieldUpdateOperationsInput | string | null
    tintas?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    producto?: productoUpdateOneWithoutDetotNestedInput
  }

  export type detotUncheckedUpdateWithoutOrdentInput = {
    iddetot?: IntFieldUpdateOperationsInput | number
    idpro?: NullableIntFieldUpdateOperationsInput | number | null
    cant?: NullableIntFieldUpdateOperationsInput | number | null
    punit?: NullableFloatFieldUpdateOperationsInput | number | null
    stotal?: NullableFloatFieldUpdateOperationsInput | number | null
    material?: NullableStringFieldUpdateOperationsInput | string | null
    gr?: NullableStringFieldUpdateOperationsInput | string | null
    tintas?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type detotUncheckedUpdateManyWithoutOrdentInput = {
    iddetot?: IntFieldUpdateOperationsInput | number
    idpro?: NullableIntFieldUpdateOperationsInput | number | null
    cant?: NullableIntFieldUpdateOperationsInput | number | null
    punit?: NullableFloatFieldUpdateOperationsInput | number | null
    stotal?: NullableFloatFieldUpdateOperationsInput | number | null
    material?: NullableStringFieldUpdateOperationsInput | string | null
    gr?: NullableStringFieldUpdateOperationsInput | string | null
    tintas?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type facturaUpdateWithoutOrdentInput = {
    monto?: NullableFloatFieldUpdateOperationsInput | number | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    aux?: NullableStringFieldUpdateOperationsInput | string | null
    aux1?: NullableStringFieldUpdateOperationsInput | string | null
    usuario?: usuarioUpdateOneWithoutFacturaNestedInput
  }

  export type facturaUncheckedUpdateWithoutOrdentInput = {
    idfac?: IntFieldUpdateOperationsInput | number
    idu?: NullableIntFieldUpdateOperationsInput | number | null
    monto?: NullableFloatFieldUpdateOperationsInput | number | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    aux?: NullableStringFieldUpdateOperationsInput | string | null
    aux1?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type facturaUncheckedUpdateManyWithoutOrdentInput = {
    idfac?: IntFieldUpdateOperationsInput | number
    idu?: NullableIntFieldUpdateOperationsInput | number | null
    monto?: NullableFloatFieldUpdateOperationsInput | number | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    aux?: NullableStringFieldUpdateOperationsInput | string | null
    aux1?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type pagoUpdateWithoutOrdentInput = {
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preciof?: NullableFloatFieldUpdateOperationsInput | number | null
    pago?: NullableFloatFieldUpdateOperationsInput | number | null
    saldo?: NullableFloatFieldUpdateOperationsInput | number | null
    des?: NullableStringFieldUpdateOperationsInput | string | null
    comprobante?: NullableBytesFieldUpdateOperationsInput | Buffer | null
  }

  export type pagoUncheckedUpdateWithoutOrdentInput = {
    idpagp?: IntFieldUpdateOperationsInput | number
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preciof?: NullableFloatFieldUpdateOperationsInput | number | null
    pago?: NullableFloatFieldUpdateOperationsInput | number | null
    saldo?: NullableFloatFieldUpdateOperationsInput | number | null
    des?: NullableStringFieldUpdateOperationsInput | string | null
    comprobante?: NullableBytesFieldUpdateOperationsInput | Buffer | null
  }

  export type pagoUncheckedUpdateManyWithoutOrdentInput = {
    idpagp?: IntFieldUpdateOperationsInput | number
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preciof?: NullableFloatFieldUpdateOperationsInput | number | null
    pago?: NullableFloatFieldUpdateOperationsInput | number | null
    saldo?: NullableFloatFieldUpdateOperationsInput | number | null
    des?: NullableStringFieldUpdateOperationsInput | string | null
    comprobante?: NullableBytesFieldUpdateOperationsInput | Buffer | null
  }

  export type clienteCreateManyPersonaInput = {
    idcli?: number
    estado?: boolean | null
  }

  export type empresaCreateManyPersonaInput = {
    idem?: number
    nom?: string | null
    dir?: string | null
    des?: string | null
    dep?: string | null
    logo?: Buffer | null
    nit?: string | null
    auto?: string | null
    base64?: string | null
  }

  export type proveedorCreateManyPersonaInput = {
    idprov?: number
    nom?: string | null
    dir?: string | null
    dep?: string | null
    logo?: Buffer | null
    estado?: boolean | null
    nit?: string | null
  }

  export type telefonoCreateManyPersonaInput = {
    idtel?: number
    numero: string
    estado?: boolean | null
  }

  export type usuarioCreateManyPersonaInput = {
    idu?: number
    sexo: string
    foto?: Buffer | null
    fecnac: Date | string
    estado?: boolean | null
    idem?: number | null
    base64?: string | null
  }

  export type clienteUpdateWithoutPersonaInput = {
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    cotizacion?: cotizacionUpdateManyWithoutClienteNestedInput
    ordent?: ordentUpdateManyWithoutClienteNestedInput
  }

  export type clienteUncheckedUpdateWithoutPersonaInput = {
    idcli?: IntFieldUpdateOperationsInput | number
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    cotizacion?: cotizacionUncheckedUpdateManyWithoutClienteNestedInput
    ordent?: ordentUncheckedUpdateManyWithoutClienteNestedInput
  }

  export type clienteUncheckedUpdateManyWithoutPersonaInput = {
    idcli?: IntFieldUpdateOperationsInput | number
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type empresaUpdateWithoutPersonaInput = {
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    dir?: NullableStringFieldUpdateOperationsInput | string | null
    des?: NullableStringFieldUpdateOperationsInput | string | null
    dep?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    nit?: NullableStringFieldUpdateOperationsInput | string | null
    auto?: NullableStringFieldUpdateOperationsInput | string | null
    base64?: NullableStringFieldUpdateOperationsInput | string | null
    leyenda?: leyendaUpdateManyWithoutEmpresaNestedInput
    usuario?: usuarioUpdateManyWithoutEmpresaNestedInput
  }

  export type empresaUncheckedUpdateWithoutPersonaInput = {
    idem?: IntFieldUpdateOperationsInput | number
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    dir?: NullableStringFieldUpdateOperationsInput | string | null
    des?: NullableStringFieldUpdateOperationsInput | string | null
    dep?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    nit?: NullableStringFieldUpdateOperationsInput | string | null
    auto?: NullableStringFieldUpdateOperationsInput | string | null
    base64?: NullableStringFieldUpdateOperationsInput | string | null
    leyenda?: leyendaUncheckedUpdateManyWithoutEmpresaNestedInput
    usuario?: usuarioUncheckedUpdateManyWithoutEmpresaNestedInput
  }

  export type empresaUncheckedUpdateManyWithoutPersonaInput = {
    idem?: IntFieldUpdateOperationsInput | number
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    dir?: NullableStringFieldUpdateOperationsInput | string | null
    des?: NullableStringFieldUpdateOperationsInput | string | null
    dep?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    nit?: NullableStringFieldUpdateOperationsInput | string | null
    auto?: NullableStringFieldUpdateOperationsInput | string | null
    base64?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type proveedorUpdateWithoutPersonaInput = {
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    dir?: NullableStringFieldUpdateOperationsInput | string | null
    dep?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    nit?: NullableStringFieldUpdateOperationsInput | string | null
    inventario?: inventarioUpdateManyWithoutProveedorNestedInput
  }

  export type proveedorUncheckedUpdateWithoutPersonaInput = {
    idprov?: IntFieldUpdateOperationsInput | number
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    dir?: NullableStringFieldUpdateOperationsInput | string | null
    dep?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    nit?: NullableStringFieldUpdateOperationsInput | string | null
    inventario?: inventarioUncheckedUpdateManyWithoutProveedorNestedInput
  }

  export type proveedorUncheckedUpdateManyWithoutPersonaInput = {
    idprov?: IntFieldUpdateOperationsInput | number
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    dir?: NullableStringFieldUpdateOperationsInput | string | null
    dep?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    nit?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type telefonoUpdateWithoutPersonaInput = {
    numero?: StringFieldUpdateOperationsInput | string
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type telefonoUncheckedUpdateWithoutPersonaInput = {
    idtel?: IntFieldUpdateOperationsInput | number
    numero?: StringFieldUpdateOperationsInput | string
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type telefonoUncheckedUpdateManyWithoutPersonaInput = {
    idtel?: IntFieldUpdateOperationsInput | number
    numero?: StringFieldUpdateOperationsInput | string
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type usuarioUpdateWithoutPersonaInput = {
    sexo?: StringFieldUpdateOperationsInput | string
    foto?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    fecnac?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    base64?: NullableStringFieldUpdateOperationsInput | string | null
    arte_arte_iduTousuario?: arteUpdateManyWithoutUsuario_arte_iduTousuarioNestedInput
    arte_arte_iduaTousuario?: arteUpdateManyWithoutUsuario_arte_iduaTousuarioNestedInput
    cotizacion?: cotizacionUpdateManyWithoutUsuarioNestedInput
    datos?: datosUpdateManyWithoutUsuarioNestedInput
    factura?: facturaUpdateManyWithoutUsuarioNestedInput
    ordent?: ordentUpdateManyWithoutUsuarioNestedInput
    registrolaboral?: registrolaboralUpdateManyWithoutUsuarioNestedInput
    empresa?: empresaUpdateOneWithoutUsuarioNestedInput
    usurol?: usurolUpdateManyWithoutUsuarioNestedInput
  }

  export type usuarioUncheckedUpdateWithoutPersonaInput = {
    idu?: IntFieldUpdateOperationsInput | number
    sexo?: StringFieldUpdateOperationsInput | string
    foto?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    fecnac?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    idem?: NullableIntFieldUpdateOperationsInput | number | null
    base64?: NullableStringFieldUpdateOperationsInput | string | null
    arte_arte_iduTousuario?: arteUncheckedUpdateManyWithoutUsuario_arte_iduTousuarioNestedInput
    arte_arte_iduaTousuario?: arteUncheckedUpdateManyWithoutUsuario_arte_iduaTousuarioNestedInput
    cotizacion?: cotizacionUncheckedUpdateManyWithoutUsuarioNestedInput
    datos?: datosUncheckedUpdateManyWithoutUsuarioNestedInput
    factura?: facturaUncheckedUpdateManyWithoutUsuarioNestedInput
    ordent?: ordentUncheckedUpdateManyWithoutUsuarioNestedInput
    registrolaboral?: registrolaboralUncheckedUpdateManyWithoutUsuarioNestedInput
    usurol?: usurolUncheckedUpdateManyWithoutUsuarioNestedInput
  }

  export type usuarioUncheckedUpdateManyWithoutPersonaInput = {
    idu?: IntFieldUpdateOperationsInput | number
    sexo?: StringFieldUpdateOperationsInput | string
    foto?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    fecnac?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    idem?: NullableIntFieldUpdateOperationsInput | number | null
    base64?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type detcotCreateManyProductoInput = {
    iddetcot?: number
    idcot?: number | null
    cant?: number | null
    punit?: number | null
    stotal?: number | null
    material?: string | null
    gr?: string | null
    tintas?: string | null
    estado?: boolean | null
  }

  export type detotCreateManyProductoInput = {
    iddetot?: number
    idot?: number | null
    cant?: number | null
    punit?: number | null
    stotal?: number | null
    material?: string | null
    gr?: string | null
    tintas?: string | null
    estado?: boolean | null
  }

  export type detcotUpdateWithoutProductoInput = {
    cant?: NullableIntFieldUpdateOperationsInput | number | null
    punit?: NullableFloatFieldUpdateOperationsInput | number | null
    stotal?: NullableFloatFieldUpdateOperationsInput | number | null
    material?: NullableStringFieldUpdateOperationsInput | string | null
    gr?: NullableStringFieldUpdateOperationsInput | string | null
    tintas?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    cotizacion?: cotizacionUpdateOneWithoutDetcotNestedInput
  }

  export type detcotUncheckedUpdateWithoutProductoInput = {
    iddetcot?: IntFieldUpdateOperationsInput | number
    idcot?: NullableIntFieldUpdateOperationsInput | number | null
    cant?: NullableIntFieldUpdateOperationsInput | number | null
    punit?: NullableFloatFieldUpdateOperationsInput | number | null
    stotal?: NullableFloatFieldUpdateOperationsInput | number | null
    material?: NullableStringFieldUpdateOperationsInput | string | null
    gr?: NullableStringFieldUpdateOperationsInput | string | null
    tintas?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type detcotUncheckedUpdateManyWithoutProductoInput = {
    iddetcot?: IntFieldUpdateOperationsInput | number
    idcot?: NullableIntFieldUpdateOperationsInput | number | null
    cant?: NullableIntFieldUpdateOperationsInput | number | null
    punit?: NullableFloatFieldUpdateOperationsInput | number | null
    stotal?: NullableFloatFieldUpdateOperationsInput | number | null
    material?: NullableStringFieldUpdateOperationsInput | string | null
    gr?: NullableStringFieldUpdateOperationsInput | string | null
    tintas?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type detotUpdateWithoutProductoInput = {
    cant?: NullableIntFieldUpdateOperationsInput | number | null
    punit?: NullableFloatFieldUpdateOperationsInput | number | null
    stotal?: NullableFloatFieldUpdateOperationsInput | number | null
    material?: NullableStringFieldUpdateOperationsInput | string | null
    gr?: NullableStringFieldUpdateOperationsInput | string | null
    tintas?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    ordent?: ordentUpdateOneWithoutDetotNestedInput
  }

  export type detotUncheckedUpdateWithoutProductoInput = {
    iddetot?: IntFieldUpdateOperationsInput | number
    idot?: NullableIntFieldUpdateOperationsInput | number | null
    cant?: NullableIntFieldUpdateOperationsInput | number | null
    punit?: NullableFloatFieldUpdateOperationsInput | number | null
    stotal?: NullableFloatFieldUpdateOperationsInput | number | null
    material?: NullableStringFieldUpdateOperationsInput | string | null
    gr?: NullableStringFieldUpdateOperationsInput | string | null
    tintas?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type detotUncheckedUpdateManyWithoutProductoInput = {
    iddetot?: IntFieldUpdateOperationsInput | number
    idot?: NullableIntFieldUpdateOperationsInput | number | null
    cant?: NullableIntFieldUpdateOperationsInput | number | null
    punit?: NullableFloatFieldUpdateOperationsInput | number | null
    stotal?: NullableFloatFieldUpdateOperationsInput | number | null
    material?: NullableStringFieldUpdateOperationsInput | string | null
    gr?: NullableStringFieldUpdateOperationsInput | string | null
    tintas?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type inventarioCreateManyProveedorInput = {
    idin?: number
    codigo?: string | null
    nom?: string | null
    precio?: number | null
    gr?: number | null
    tam?: string | null
    des?: string | null
    cant?: number | null
    estado?: boolean | null
  }

  export type inventarioUpdateWithoutProveedorInput = {
    codigo?: NullableStringFieldUpdateOperationsInput | string | null
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    precio?: NullableFloatFieldUpdateOperationsInput | number | null
    gr?: NullableFloatFieldUpdateOperationsInput | number | null
    tam?: NullableStringFieldUpdateOperationsInput | string | null
    des?: NullableStringFieldUpdateOperationsInput | string | null
    cant?: NullableIntFieldUpdateOperationsInput | number | null
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type inventarioUncheckedUpdateWithoutProveedorInput = {
    idin?: IntFieldUpdateOperationsInput | number
    codigo?: NullableStringFieldUpdateOperationsInput | string | null
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    precio?: NullableFloatFieldUpdateOperationsInput | number | null
    gr?: NullableFloatFieldUpdateOperationsInput | number | null
    tam?: NullableStringFieldUpdateOperationsInput | string | null
    des?: NullableStringFieldUpdateOperationsInput | string | null
    cant?: NullableIntFieldUpdateOperationsInput | number | null
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type inventarioUncheckedUpdateManyWithoutProveedorInput = {
    idin?: IntFieldUpdateOperationsInput | number
    codigo?: NullableStringFieldUpdateOperationsInput | string | null
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    precio?: NullableFloatFieldUpdateOperationsInput | number | null
    gr?: NullableFloatFieldUpdateOperationsInput | number | null
    tam?: NullableStringFieldUpdateOperationsInput | string | null
    des?: NullableStringFieldUpdateOperationsInput | string | null
    cant?: NullableIntFieldUpdateOperationsInput | number | null
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type rolmenuCreateManyRolesInput = {
    idm: number
  }

  export type usurolCreateManyRolesInput = {
    idu: number
  }

  export type rolmenuUpdateWithoutRolesInput = {
    menu?: menuUpdateOneRequiredWithoutRolmenuNestedInput
  }

  export type rolmenuUncheckedUpdateWithoutRolesInput = {
    idm?: IntFieldUpdateOperationsInput | number
  }

  export type rolmenuUncheckedUpdateManyWithoutRolesInput = {
    idm?: IntFieldUpdateOperationsInput | number
  }

  export type usurolUpdateWithoutRolesInput = {
    usuario?: usuarioUpdateOneRequiredWithoutUsurolNestedInput
  }

  export type usurolUncheckedUpdateWithoutRolesInput = {
    idu?: IntFieldUpdateOperationsInput | number
  }

  export type usurolUncheckedUpdateManyWithoutRolesInput = {
    idu?: IntFieldUpdateOperationsInput | number
  }

  export type arteCreateManyUsuario_arte_iduTousuarioInput = {
    idar?: number
    idot?: number | null
    fechar?: Date | string | null
    fechaa?: Date | string | null
    idua?: number | null
    estado?: string | null
    obs?: string | null
    precio?: number | null
  }

  export type arteCreateManyUsuario_arte_iduaTousuarioInput = {
    idar?: number
    idu?: number | null
    idot?: number | null
    fechar?: Date | string | null
    fechaa?: Date | string | null
    estado?: string | null
    obs?: string | null
    precio?: number | null
  }

  export type cotizacionCreateManyUsuarioInput = {
    idcot?: number
    idcli?: number | null
    fecha?: Date | string | null
    precio?: number | null
    descuento?: number | null
    preciofinal?: number | null
    tiempo?: number | null
    arte?: string | null
    obs?: string | null
    estado?: string | null
  }

  export type datosCreateManyUsuarioInput = {
    login: string
    contrasenia: string
  }

  export type facturaCreateManyUsuarioInput = {
    idfac?: number
    idot?: number | null
    monto?: number | null
    fecha?: Date | string | null
    aux?: string | null
    aux1?: string | null
  }

  export type ordentCreateManyUsuarioInput = {
    idot?: number
    idcli?: number | null
    idcot?: number | null
    fecha?: Date | string | null
    precio?: number | null
    descuento?: number | null
    preciofinal?: number | null
    tiempo?: number | null
    arte?: string | null
    obs?: string | null
    estado?: string | null
    factura?: string | null
  }

  export type registrolaboralCreateManyUsuarioInput = {
    idre?: number
    tiporegistro?: string | null
    fecha?: Date | string | null
    hora?: Date | string | null
    mes?: string | null
    estado?: string | null
    adicional?: string | null
    adicional2?: string | null
    atraso?: Date | string | null
  }

  export type usurolCreateManyUsuarioInput = {
    idr: number
  }

  export type arteUpdateWithoutUsuario_arte_iduTousuarioInput = {
    fechar?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fechaa?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estado?: NullableStringFieldUpdateOperationsInput | string | null
    obs?: NullableStringFieldUpdateOperationsInput | string | null
    precio?: NullableFloatFieldUpdateOperationsInput | number | null
    ordent?: ordentUpdateOneWithoutArte1NestedInput
    usuario_arte_iduaTousuario?: usuarioUpdateOneWithoutArte_arte_iduaTousuarioNestedInput
  }

  export type arteUncheckedUpdateWithoutUsuario_arte_iduTousuarioInput = {
    idar?: IntFieldUpdateOperationsInput | number
    idot?: NullableIntFieldUpdateOperationsInput | number | null
    fechar?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fechaa?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    idua?: NullableIntFieldUpdateOperationsInput | number | null
    estado?: NullableStringFieldUpdateOperationsInput | string | null
    obs?: NullableStringFieldUpdateOperationsInput | string | null
    precio?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type arteUncheckedUpdateManyWithoutUsuario_arte_iduTousuarioInput = {
    idar?: IntFieldUpdateOperationsInput | number
    idot?: NullableIntFieldUpdateOperationsInput | number | null
    fechar?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fechaa?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    idua?: NullableIntFieldUpdateOperationsInput | number | null
    estado?: NullableStringFieldUpdateOperationsInput | string | null
    obs?: NullableStringFieldUpdateOperationsInput | string | null
    precio?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type arteUpdateWithoutUsuario_arte_iduaTousuarioInput = {
    fechar?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fechaa?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estado?: NullableStringFieldUpdateOperationsInput | string | null
    obs?: NullableStringFieldUpdateOperationsInput | string | null
    precio?: NullableFloatFieldUpdateOperationsInput | number | null
    ordent?: ordentUpdateOneWithoutArte1NestedInput
    usuario_arte_iduTousuario?: usuarioUpdateOneWithoutArte_arte_iduTousuarioNestedInput
  }

  export type arteUncheckedUpdateWithoutUsuario_arte_iduaTousuarioInput = {
    idar?: IntFieldUpdateOperationsInput | number
    idu?: NullableIntFieldUpdateOperationsInput | number | null
    idot?: NullableIntFieldUpdateOperationsInput | number | null
    fechar?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fechaa?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estado?: NullableStringFieldUpdateOperationsInput | string | null
    obs?: NullableStringFieldUpdateOperationsInput | string | null
    precio?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type arteUncheckedUpdateManyWithoutUsuario_arte_iduaTousuarioInput = {
    idar?: IntFieldUpdateOperationsInput | number
    idu?: NullableIntFieldUpdateOperationsInput | number | null
    idot?: NullableIntFieldUpdateOperationsInput | number | null
    fechar?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fechaa?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estado?: NullableStringFieldUpdateOperationsInput | string | null
    obs?: NullableStringFieldUpdateOperationsInput | string | null
    precio?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type cotizacionUpdateWithoutUsuarioInput = {
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    precio?: NullableFloatFieldUpdateOperationsInput | number | null
    descuento?: NullableFloatFieldUpdateOperationsInput | number | null
    preciofinal?: NullableFloatFieldUpdateOperationsInput | number | null
    tiempo?: NullableIntFieldUpdateOperationsInput | number | null
    arte?: NullableStringFieldUpdateOperationsInput | string | null
    obs?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableStringFieldUpdateOperationsInput | string | null
    cliente?: clienteUpdateOneWithoutCotizacionNestedInput
    detcot?: detcotUpdateManyWithoutCotizacionNestedInput
    ordent?: ordentUpdateManyWithoutCotizacionNestedInput
  }

  export type cotizacionUncheckedUpdateWithoutUsuarioInput = {
    idcot?: IntFieldUpdateOperationsInput | number
    idcli?: NullableIntFieldUpdateOperationsInput | number | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    precio?: NullableFloatFieldUpdateOperationsInput | number | null
    descuento?: NullableFloatFieldUpdateOperationsInput | number | null
    preciofinal?: NullableFloatFieldUpdateOperationsInput | number | null
    tiempo?: NullableIntFieldUpdateOperationsInput | number | null
    arte?: NullableStringFieldUpdateOperationsInput | string | null
    obs?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableStringFieldUpdateOperationsInput | string | null
    detcot?: detcotUncheckedUpdateManyWithoutCotizacionNestedInput
    ordent?: ordentUncheckedUpdateManyWithoutCotizacionNestedInput
  }

  export type cotizacionUncheckedUpdateManyWithoutUsuarioInput = {
    idcot?: IntFieldUpdateOperationsInput | number
    idcli?: NullableIntFieldUpdateOperationsInput | number | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    precio?: NullableFloatFieldUpdateOperationsInput | number | null
    descuento?: NullableFloatFieldUpdateOperationsInput | number | null
    preciofinal?: NullableFloatFieldUpdateOperationsInput | number | null
    tiempo?: NullableIntFieldUpdateOperationsInput | number | null
    arte?: NullableStringFieldUpdateOperationsInput | string | null
    obs?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type datosUpdateWithoutUsuarioInput = {
    login?: StringFieldUpdateOperationsInput | string
    contrasenia?: StringFieldUpdateOperationsInput | string
  }

  export type datosUncheckedUpdateWithoutUsuarioInput = {
    login?: StringFieldUpdateOperationsInput | string
    contrasenia?: StringFieldUpdateOperationsInput | string
  }

  export type datosUncheckedUpdateManyWithoutUsuarioInput = {
    login?: StringFieldUpdateOperationsInput | string
    contrasenia?: StringFieldUpdateOperationsInput | string
  }

  export type facturaUpdateWithoutUsuarioInput = {
    monto?: NullableFloatFieldUpdateOperationsInput | number | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    aux?: NullableStringFieldUpdateOperationsInput | string | null
    aux1?: NullableStringFieldUpdateOperationsInput | string | null
    ordent?: ordentUpdateOneWithoutFactura1NestedInput
  }

  export type facturaUncheckedUpdateWithoutUsuarioInput = {
    idfac?: IntFieldUpdateOperationsInput | number
    idot?: NullableIntFieldUpdateOperationsInput | number | null
    monto?: NullableFloatFieldUpdateOperationsInput | number | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    aux?: NullableStringFieldUpdateOperationsInput | string | null
    aux1?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type facturaUncheckedUpdateManyWithoutUsuarioInput = {
    idfac?: IntFieldUpdateOperationsInput | number
    idot?: NullableIntFieldUpdateOperationsInput | number | null
    monto?: NullableFloatFieldUpdateOperationsInput | number | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    aux?: NullableStringFieldUpdateOperationsInput | string | null
    aux1?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ordentUpdateWithoutUsuarioInput = {
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    precio?: NullableFloatFieldUpdateOperationsInput | number | null
    descuento?: NullableFloatFieldUpdateOperationsInput | number | null
    preciofinal?: NullableFloatFieldUpdateOperationsInput | number | null
    tiempo?: NullableIntFieldUpdateOperationsInput | number | null
    arte?: NullableStringFieldUpdateOperationsInput | string | null
    obs?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableStringFieldUpdateOperationsInput | string | null
    factura?: NullableStringFieldUpdateOperationsInput | string | null
    arte1?: arteUpdateManyWithoutOrdentNestedInput
    detot?: detotUpdateManyWithoutOrdentNestedInput
    factura1?: facturaUpdateManyWithoutOrdentNestedInput
    cliente?: clienteUpdateOneWithoutOrdentNestedInput
    cotizacion?: cotizacionUpdateOneWithoutOrdentNestedInput
    pago?: pagoUpdateManyWithoutOrdentNestedInput
  }

  export type ordentUncheckedUpdateWithoutUsuarioInput = {
    idot?: IntFieldUpdateOperationsInput | number
    idcli?: NullableIntFieldUpdateOperationsInput | number | null
    idcot?: NullableIntFieldUpdateOperationsInput | number | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    precio?: NullableFloatFieldUpdateOperationsInput | number | null
    descuento?: NullableFloatFieldUpdateOperationsInput | number | null
    preciofinal?: NullableFloatFieldUpdateOperationsInput | number | null
    tiempo?: NullableIntFieldUpdateOperationsInput | number | null
    arte?: NullableStringFieldUpdateOperationsInput | string | null
    obs?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableStringFieldUpdateOperationsInput | string | null
    factura?: NullableStringFieldUpdateOperationsInput | string | null
    arte1?: arteUncheckedUpdateManyWithoutOrdentNestedInput
    detot?: detotUncheckedUpdateManyWithoutOrdentNestedInput
    factura1?: facturaUncheckedUpdateManyWithoutOrdentNestedInput
    pago?: pagoUncheckedUpdateManyWithoutOrdentNestedInput
  }

  export type ordentUncheckedUpdateManyWithoutUsuarioInput = {
    idot?: IntFieldUpdateOperationsInput | number
    idcli?: NullableIntFieldUpdateOperationsInput | number | null
    idcot?: NullableIntFieldUpdateOperationsInput | number | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    precio?: NullableFloatFieldUpdateOperationsInput | number | null
    descuento?: NullableFloatFieldUpdateOperationsInput | number | null
    preciofinal?: NullableFloatFieldUpdateOperationsInput | number | null
    tiempo?: NullableIntFieldUpdateOperationsInput | number | null
    arte?: NullableStringFieldUpdateOperationsInput | string | null
    obs?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableStringFieldUpdateOperationsInput | string | null
    factura?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type registrolaboralUpdateWithoutUsuarioInput = {
    tiporegistro?: NullableStringFieldUpdateOperationsInput | string | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hora?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    mes?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableStringFieldUpdateOperationsInput | string | null
    adicional?: NullableStringFieldUpdateOperationsInput | string | null
    adicional2?: NullableStringFieldUpdateOperationsInput | string | null
    atraso?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type registrolaboralUncheckedUpdateWithoutUsuarioInput = {
    idre?: IntFieldUpdateOperationsInput | number
    tiporegistro?: NullableStringFieldUpdateOperationsInput | string | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hora?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    mes?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableStringFieldUpdateOperationsInput | string | null
    adicional?: NullableStringFieldUpdateOperationsInput | string | null
    adicional2?: NullableStringFieldUpdateOperationsInput | string | null
    atraso?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type registrolaboralUncheckedUpdateManyWithoutUsuarioInput = {
    idre?: IntFieldUpdateOperationsInput | number
    tiporegistro?: NullableStringFieldUpdateOperationsInput | string | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hora?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    mes?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableStringFieldUpdateOperationsInput | string | null
    adicional?: NullableStringFieldUpdateOperationsInput | string | null
    adicional2?: NullableStringFieldUpdateOperationsInput | string | null
    atraso?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type usurolUpdateWithoutUsuarioInput = {
    roles?: rolesUpdateOneRequiredWithoutUsurolNestedInput
  }

  export type usurolUncheckedUpdateWithoutUsuarioInput = {
    idr?: IntFieldUpdateOperationsInput | number
  }

  export type usurolUncheckedUpdateManyWithoutUsuarioInput = {
    idr?: IntFieldUpdateOperationsInput | number
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use ClienteCountOutputTypeDefaultArgs instead
     */
    export type ClienteCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ClienteCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CotizacionCountOutputTypeDefaultArgs instead
     */
    export type CotizacionCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CotizacionCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EmpresaCountOutputTypeDefaultArgs instead
     */
    export type EmpresaCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EmpresaCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MarcaCountOutputTypeDefaultArgs instead
     */
    export type MarcaCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MarcaCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MenuCountOutputTypeDefaultArgs instead
     */
    export type MenuCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MenuCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use OrdentCountOutputTypeDefaultArgs instead
     */
    export type OrdentCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = OrdentCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PersonaCountOutputTypeDefaultArgs instead
     */
    export type PersonaCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PersonaCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProductoCountOutputTypeDefaultArgs instead
     */
    export type ProductoCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProductoCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProveedorCountOutputTypeDefaultArgs instead
     */
    export type ProveedorCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProveedorCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RolesCountOutputTypeDefaultArgs instead
     */
    export type RolesCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RolesCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UsuarioCountOutputTypeDefaultArgs instead
     */
    export type UsuarioCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UsuarioCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use arteDefaultArgs instead
     */
    export type arteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = arteDefaultArgs<ExtArgs>
    /**
     * @deprecated Use clienteDefaultArgs instead
     */
    export type clienteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = clienteDefaultArgs<ExtArgs>
    /**
     * @deprecated Use colorDefaultArgs instead
     */
    export type colorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = colorDefaultArgs<ExtArgs>
    /**
     * @deprecated Use configuracionlaboralDefaultArgs instead
     */
    export type configuracionlaboralArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = configuracionlaboralDefaultArgs<ExtArgs>
    /**
     * @deprecated Use cotizacionDefaultArgs instead
     */
    export type cotizacionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = cotizacionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use datosDefaultArgs instead
     */
    export type datosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = datosDefaultArgs<ExtArgs>
    /**
     * @deprecated Use detcotDefaultArgs instead
     */
    export type detcotArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = detcotDefaultArgs<ExtArgs>
    /**
     * @deprecated Use detotDefaultArgs instead
     */
    export type detotArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = detotDefaultArgs<ExtArgs>
    /**
     * @deprecated Use empresaDefaultArgs instead
     */
    export type empresaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = empresaDefaultArgs<ExtArgs>
    /**
     * @deprecated Use eventosDefaultArgs instead
     */
    export type eventosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = eventosDefaultArgs<ExtArgs>
    /**
     * @deprecated Use facturaDefaultArgs instead
     */
    export type facturaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = facturaDefaultArgs<ExtArgs>
    /**
     * @deprecated Use inventarioDefaultArgs instead
     */
    export type inventarioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = inventarioDefaultArgs<ExtArgs>
    /**
     * @deprecated Use leyendaDefaultArgs instead
     */
    export type leyendaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = leyendaDefaultArgs<ExtArgs>
    /**
     * @deprecated Use marcaDefaultArgs instead
     */
    export type marcaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = marcaDefaultArgs<ExtArgs>
    /**
     * @deprecated Use menuDefaultArgs instead
     */
    export type menuArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = menuDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ordentDefaultArgs instead
     */
    export type ordentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ordentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use pagoDefaultArgs instead
     */
    export type pagoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = pagoDefaultArgs<ExtArgs>
    /**
     * @deprecated Use personaDefaultArgs instead
     */
    export type personaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = personaDefaultArgs<ExtArgs>
    /**
     * @deprecated Use productoDefaultArgs instead
     */
    export type productoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = productoDefaultArgs<ExtArgs>
    /**
     * @deprecated Use proveedorDefaultArgs instead
     */
    export type proveedorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = proveedorDefaultArgs<ExtArgs>
    /**
     * @deprecated Use registrolaboralDefaultArgs instead
     */
    export type registrolaboralArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = registrolaboralDefaultArgs<ExtArgs>
    /**
     * @deprecated Use rolesDefaultArgs instead
     */
    export type rolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = rolesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use rolmenuDefaultArgs instead
     */
    export type rolmenuArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = rolmenuDefaultArgs<ExtArgs>
    /**
     * @deprecated Use telefonoDefaultArgs instead
     */
    export type telefonoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = telefonoDefaultArgs<ExtArgs>
    /**
     * @deprecated Use terminadoDefaultArgs instead
     */
    export type terminadoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = terminadoDefaultArgs<ExtArgs>
    /**
     * @deprecated Use usuarioDefaultArgs instead
     */
    export type usuarioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = usuarioDefaultArgs<ExtArgs>
    /**
     * @deprecated Use usurolDefaultArgs instead
     */
    export type usurolArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = usurolDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}